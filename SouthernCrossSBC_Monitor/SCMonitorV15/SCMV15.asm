;--------------------------------------------
; S O U T H E R N   C R O S S   M O N I T O R
;--------------------------------------------
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
; 
;
; VERSION : 1.2  01/93. V1.21 7/93
;
; Version 1.3  02/2003  ADDED SOFTWARE SCANNED KEYBOARD (UNRELEASED)
; Version 1.4  03/2021  MADE INTELH A SYSTEM CALL, REMOVED CANCEL FUNCTIONALITY FROM RXDATA
;
; Version 1.5  06/2021  ADDED SBUG SERIAL MONITOR
;                       ADDED HELP FOR SBUG COMMANDS
;                       ADDED SBUG ROUTINES TO SYSTEM CALLS
;                       MOVED THE STACK DOWN TO 3E00H TO RESERVE SOME MORE ROOM FOR MONITOR VARIABLES  
;                       ADDED INITIALISATION CODE FOR KEYTIM
;    
;-----------------
; SYSTEM VARIABLES
;-----------------
RAMSRT	EQU	2000H	;START OF USER RAM
RAMEND	EQU	3BFFH	;END OF USER RAM
SYSTEM	EQU	3E00H	;INITIAL STACK POINTER
;
; BAUD RATE CONSTANTS
;
B300	EQU	0220H	;300 BAUD
B1200	EQU	0080H	;1200 BAUD
B2400	EQU	003FH	;2400 BAUD
B4800	EQU	001BH	;4800 BAUD
B9600	EQU	000BH	;9600 BAUD
;
; I/O PORT ADDRESSES
;
IO0	EQU	80H	;IO PORT 0
IO1	EQU	81H	;IO PORT 1
IO2	EQU	82H	;IO PORT 2
IO3	EQU	83H	;IO PORT 3
DISPLY	EQU	84H	;DISPLAY LATCH
SCAN	EQU	85H	;DISPLAY SCAN LATCH
KEYBUF	EQU	86H	;KEYBOARD BUFFER
IO7	EQU	87H	;SPARE IO ADDRESS
;-------------------------
; MONITOR GLOBAL VARIABLES
;-------------------------
;
; SERIAL MONITOR VARIABLES
;
MSGBUF  EQU 3E00H   ;STRING HANDLING AREA
;
PUTCH   EQU 3FAAH   ;OUTPUT A CHARACTER TO SERIAL
GETCH   EQU 3FACH   ;WAIT FOR A CHARACTER FROM SERIAL
ISTACK  EQU 3FAEH   ;SAVE THE INITIAL STACK POINTER    
ADDR    EQU 3FB0H   ;THE ADDRESS  
DATA    EQU 3FB2H   ;THE DATA
;
SYSFLG	EQU	3FB3H	;SYSTEM FLAGS  BIT 0=KEYBOARD FLAG
FUNTBL	EQU	3FB4H	;FN TABLE ADDRESS
;
; DALLAS SMARTWATCH REGISTERS
;
CALMDE	EQU	3FB6H	;CALENDAR MODE
SWREG0	EQU	3FB8H	;10THS, 100THS
SWREG1	EQU	3FB9H	;SECONDS
SWREG2	EQU	3FBAH	;MINUTES
SWREG3	EQU	3FBBH	;HOURS
SWREG4	EQU	3FBCH	;DAY
SWREG5	EQU	3FBDH	;DATE
SWREG6	EQU	3FBEH	;MONTH
SWREG7	EQU	3FBFH	;YEAR
;
BAUD	EQU	3FC0H	;BAUD RATE
KEYTIM	EQU	3FC2H	;BEEP DELAY
SPTEMP	EQU	3FC4H	;TEMP SYSTEM CALL SP
;
; BLOCK FUNCTIONS
;
COUNT	EQU	3FC6H	;NUMBER OF BYTES TO MOVE
BLKSRT	EQU	3FC8H	;BLOCK START ADDRESS
BLKEND	EQU	3FCAH	;BLOCK END ADDRESS
BLKDST	EQU	3FCCH	;DESTINATION ADDRESS
;
FUNJMP	EQU	3FCEH	;FN FN KEY JUMP ADDRESS
;
; DISPLAY SCAN REGISTERS
;
DISBUF	EQU	3FD0H	;DISPLAY BUFFER
ONTIM	EQU	3FD6H	;DISPLAY SCAN ON TIME
OFTIM	EQU	3FD7H	;DISPLAY SCAN OFF TIME
;
; MONITOR VARIABLES
;
MODE	EQU	3FD8H	;DISPLAY MODE
ADRESS	EQU	3FDAH	;USER ADDRESS
KEYDEL	EQU	3FDCH	;AUTO INCREMENT DELAY
;
; TEMPORARY REGISTER STORAGE
;
REGPNT	EQU	3FDEH	;REGISTER POINTER
PC_REG	EQU	3FE0H	;PROGRAM COUNTER
AF_REG	EQU	3FE2H	;ACCUMULATOR,FLAG
BC_REG	EQU	3FE4H	;BC REGISTER PAIR
DE_REG	EQU	3FE6H	;DE REGISTER PAIR
HL_REG	EQU	3FE8H	;HL REGISTER PAIR
IX_REG	EQU	3FEAH	;INDEX REGISTER X
IY_REG	EQU	3FECH	;INDEX REGISTER Y
SP_REG	EQU	3FEEH	;STACK POINTER
;
; RESTART JUMP TABLE AND HARWARE TEST
;
RST08	EQU	3FF0H	;RESTART 08H JUMP
RST10	EQU	3FF2H	;RESTART 10H JUMP
RST18	EQU	3FF4H	;RESTART 18H JUMP
RST20	EQU	3FF6H	;RESTART 20H JUMP
RST28	EQU	3FF8H	;RESTART 28H JUMP
RST38	EQU	3FFAH	;INT INTERRUPT JUMP
RST66	EQU	3FFCH	;NMI INTERRUPT JUMP
RAMSUM	EQU	3FFEH	;USER RAM CHECKSUM
DALLAS	EQU	3FFFH	;RAM TEST LOCATION
;----------------
; RESTART VECTORS
;----------------
;
;  RESTART 00H - RST 0
;WHEN POWER IS APPLIED TO THE SOUTHERN CROSS
;THE Z80 STARTS EXECUTING INSTRUCTIONS FROM HERE
;
	ORG	0000H
RSTVEC	JP	RESET
;
; RESTART 08H - RST 1
;
	ORG	0008H
	PUSH	HL
	LD	HL,(RST08)
	JP	(HL)
;
; RESTART 10H - RST 2
;
	ORG	0010H
	PUSH	HL
	LD	HL,(RST10)
	JP	(HL)
;
; RESTART 18H - RST 3
;
	ORG	0018H
	PUSH	HL
	LD	HL,(RST18)
	JP	(HL)
;
; RESTART 20H - RST 4
;
	ORG	0020H
	PUSH	HL
	LD	HL,(RST20)
	JP	(HL)
;
; RESTART 28H - RST 5
;
	ORG	0028H
	PUSH	HL
	LD	HL,(RST28)
	JP	(HL)
;
; RESTART 30H - RST 6 - MONITOR ROUTINES ENTRY POINT
;
	ORG	0030H
RST30	JP	SYSCALL
;
; RESTART 38H - RST 7     BREAKPOINT HANDLER
;IF INTERRUPTS ARE ENABLED,AND AN
;INT OCCURS- FURTHER INTERRUPTS
;ARE DISABLED, THE PROGRAM COUNTER
;IS PUSHED ONTO THE STACK, AND EXECUTION
;STARTS HERE
;
	ORG	0038H
	PUSH	HL
	LD	HL,(RST38)
	JP	(HL)
;
; RESTART 66H NMI VECTOR
; SAME AS ABOVE BUT NMI CANNOT BE DISABLED.
;
	ORG	0066H
	PUSH	HL
	LD	HL,(RST66)
	JP	(HL)
;--------------------
; SYSTEM CALL HANDLER
;--------------------
;CALLS TO BASIC I/O AND OTHER ROUTINES
;WITHIN THE MONITOR HAVE BEEN ASSIGNED
;SYSTEM CALL NUMBERS TO AVOID RE-WRITING
;USER SOFTWARE IF MONITOR ABSOLUTE ADDRESSES
;CHANGE IN SUBSEQUENT MONITORS
;
;ENTRY : C = CALL NUMBER
;SEE ROUTINES FOR ENTRY AND EXIT
;PARAMETERS
;
SYSCALL	DEC	SP
	DEC	SP	;LEAVE SPACE FOR SYSCALL
	LD	(SPTEMP),SP	;POINTS TO SYSCALL LO
	PUSH	AF
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	LD	A,C	;GET CALL NUMBER
	AND	127	;ENSURE IN LIMITS
	SLA	A	;MULTIPLY BY TWO
	LD	H,1	;LOAD JUMP TABLE HIGH BYTE
	LD	L,A	;LOAD INDEX
	LD	A,(HL)
	INC	HL
	LD	D,(HL)	;GET JUMP ADDRESS
	LD	HL,(SPTEMP)	;POINT TO SYSCALL LO
	LD	(HL),A	;PUT SYSCALL LO ON STACK
	INC	HL
	LD	A,D
	LD	(HL),A	;PUT SYSCALL HI ON STACK
	POP	HL
	POP	DE
	POP	AF	;RESTORE REGISTERS
	RET		;JUMPS TO SYSTEM CALL
;-----------------------
; SYSTEM CALL JUMP TABLE
;-----------------------
	ORG	0100H
SYSJMP	.DW	MAIN,VERS
	.DW	DISADD,DISBYT,CLRBUF,SCAND
	.DW	CONBYT,CONVHI,CONVLO
	.DW	SKEYIN,SKEYRL,KEYIN,KEYREL
	.DW	MENU,CHKSUM
	.DW	MUL16,RAND
	.DW	INDEXB,INDEXW
	.DW	MUSIC,TONE,BEEP
	.DW	SKATE
	.DW	TXDATA,RXDATA,ASCHEX
	.DW	WWATCH,RWATCH,ONESEC
	.DW	RLSTEP,DELONE,SCANKEY
    .DW INTELH,SPLIT
    .DW SNDMSG,BITASC                       
    .DW WRDASC,BYTASC,NYBASC 
;------------------------------
; POWER UP RESET / MANUAL RESET
;------------------------------
	ORG	0200H
;
; WAIT FOR SMART SOCKET
; TO RECOVER FROM POWER DOWN
;
RESET	LD	A,55H
	LD	(DALLAS),A	;WRITE TO RAM
	XOR	A
	OUT	(DISPLY),A	;WRITE NOTHING TO
	OUT	(SCAN),A	;ON BOARD I/O
	IN	A,(KEYBUF)	;TO HELP DEBUGGING
	LD	A,(DALLAS)	;READ FROM RAM
	CP	55H	;IS IT READY?
	JP	NZ,RESET	;KEEP TRYING
;
; LOAD STACK POINTER
;
RESET1	LD	SP,SYSTEM
;
; SET UP RESTART VECTORS
;
	LD	HL,RESET1
	LD	(RST08),HL
	LD	(RST10),HL
	LD	(RST18),HL
	LD	(RST20),HL
	LD	(RST28),HL
	LD	(RST66),HL	;NMI INTERRUPT
	LD	HL,SSTEP
	LD	(RST38),HL	;SINGLE STEPPER
;
; SET INTERRUPT MODE 1 - USE THE AUTOMATED INTERRUPT
;
	IM	1
	EI		;ENABLE INTERRUPTS
;
; PERFORM CHECKSUM ON USER RAM
;
	LD	HL,RAMSRT	;START OF USER RAM
	LD	DE,RAMEND	;END OF USER RAM
	CALL	CHKSUM
	LD	(RAMSUM),A	;RAM CHECKSUM
;
; SET UP DEFAULT VARIABLES
;
	LD	HL,FUNLST
	LD	(FUNTBL),HL	;FUNCTION KEY TABLE
;
; PRESS THE FUNCTION KEY TWICE TO JUMP INTO THE SERIAL MONITOR
;
    LD  HL,SCBUG    ;JUMP TO SERIAL MONITOR 
	LD	(FUNJMP),HL	;FN FN JUMP
    
	LD	A,00H
	LD	(REGPNT),A	;INIT SINGLE STEPPER
	LD	HL,B4800
	LD	(BAUD),HL	;DEFAULT SERIAL=4800 BAUD
	LD	HL,0100H
	LD	(KEYDEL),HL	;AUTO-INC/DEC DELAY
    LD  HL,1000H
    LD  (KEYTIM),HL ;DELAY TIME INSTEAD OF A BEEP
	LD	A,0AH
	LD	(OFTIM),A	;DISPLAY OFF TIME
	CALL	BEEP
	CALL	BEEP
;
; SOFTWARE KEYBOARD ENCODER
;
	LD	A,00H
	SET	0,A		        ;SOFTWARE SCANNED
	LD	(SYSFLG),A
	LD	A,20H
	LD	(ONTIM),A	    ;DISPLAY ON TIME FOR SOFTWARE KEYBOARD	
	IN  A,(KEYBUF)      ;READ KEY BUFFER
	BIT	5,A		        ;DA HIGH? MUST BE SOFTWARE SCANNING
	JR	NZ,MAIN
;
; HARDWARE KEYBOARD ENCODER
;
	LD	A,(SYSFLG)	    ;GET SYSTEM FLAGS
	RES	0,A		        ;HARDWARE ENCODER
	LD	(SYSFLG),A
	LD	A,20H
	LD	(ONTIM),A	;DISPLAY ON TIME FOR KEYBOARD ENCODER
 
;-----------------
; SET UP MAIN LOOP
;-----------------
MAIN	LD	SP,SYSTEM	;SET STACK
	LD	HL,RAMSRT
	LD	(ADRESS),HL	;DEFAULT ADDRESS
	LD	A,(MODE)
	OR	80H	;START OFF IN DATA MODE
	LD	(MODE),A 
;
; SCAN THE DISPLAYS UNTIL A KEY IS PRESSED
;
MAIN1	CALL	UPDATE
MAIN2	CALL	SKEYIN	;WAIT FOR A KEY
	LD	HL,MENLST	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
	CALL	UPDATE	;UPDATE BUFFER AND
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	MAIN2
;
; MAIN MENU KEY TABLE
;
MENLST	.DB	20
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	FUNKEY,ADDKEY,INCKEY,DECKEY
;---------------------------------------------------
; ENTER HEX KEY AS LEAST SIGNIFICANT ADDRESS OR DATA
;---------------------------------------------------
HEXKEY	CALL	BEEP
	LD	HL,MODE
	BIT	7,(HL)	;ADDR OR DATA MODE?
	JP	Z,HEXKY2	;IN ADDR MODE
;
; IN DATA MODE
;
HEXKY1	LD	HL,(ADRESS)
	SLA	(HL)	;FROM THE CURRENT
	SLA	(HL)	;ADDRESS,MOVE THE
	SLA	(HL)	;LSN TO THE MSN.
	SLA	(HL)	;PUT THE KEY IN
	OR	(HL)	;THE NEW DATA BACK AT
	LD	(HL),A	;THE CURRENT ADDRESS.
	RET
;
; IN ADDRESS MODE
;
HEXKY2	LD	HL,(ADRESS)
	SLA	L	;CURRENT ADDRESS
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(ADRESS),HL	;SAVE CURRENT ADDRESS
	RET
;-------------
; CHANGE MODES
;-------------
ADDKEY	CALL	BEEP
	LD	A,(MODE)
	XOR	80H	;TOGGLE MODE
	LD	(MODE),A
	RET
;------------------
; INCREMENT ADDRESS
;------------------
INCKEY	CALL	BEEP
INCKY1	LD	HL,(ADRESS)
	INC	HL	;INC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)
INCKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF +
	JR	Z,INCKY3	;KEY RELEASED
	CP	32H
	JR	NZ,INCKY3	;NOT INC KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,INCKY2
	JP	INCKY1
INCKY3	RET
;------------------
; DECREMENT ADDRESS
;------------------
DECKEY	CALL	BEEP
DECKY1	LD	HL,(ADRESS)
	DEC	HL	;DEC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)
DECKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF
	JR	Z,DECKY3	; - KEY RELEASED
	CP	33H
	JR	NZ,DECKY3	;NOT DEC KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,DECKY2
	JP	DECKY1
DECKY3	RET
;-----------------------------------------
; UPDATE DISPLAY BUFFER TO CURRENT ADDRESS
;-----------------------------------------
UPDATE	LD	HL,(ADRESS)
	CALL	DISADD	;AND DATA, PUT IN
	LD	A,(HL)
	CALL	DISBYT	;DISPLAY BUFFER
;
; IN ADDRESS OR DATA MODE?
;
	LD	HL,MODE
	BIT	7,(HL)	;DATA OR ADDR MODE?
	JP	Z,ADMODE	;ADDRESS MODE
;
; SHOW DATA MODE
;
	LD	HL,DISBUF
	LD	B,2	;IN THE DATA
	JP	SETDP	;DISPLAY
;
; SHOW ADDRESS MODE
;
ADMODE	LD	HL,DISBUF+2
	LD	B,4	;SET THE DP'S IN THE
;
; SET DECIMAL POINT
;
;SET BIT 7 IN THE BYTE POINTED TO BY HL
;
SETDP	SET	7,(HL)	;SET BIT 7
	INC	HL	;POINT TO NEXT BYTE
	DJNZ	SETDP	;MORE BITS TO SET
	RET
;---------------
; VERSION NUMBER
;---------------
;RETURNS THE SOFTWARE VERSION NUMBER
;SHOULD FUTURE MONITORS EXHIBIT DIFFERENCES
;THE VERSION NUMBER CAN BE USED TO COMPENSATE
;
;	ENTRY : NONE
; EXIT : H = ASCII MINOR VERSION NUMBER
;        L = ASCII MAJOR VERSION NUMBER
;
VERS	LD	HL,3135H
	RET
;-------------------------
; ADDRESS > DISPLAY BUFFER
;-------------------------
;CONVERT HL TO SEVEN SEGMENT CODE
;AND PUT IN ADDRESS DISPLAY BUFFER.
;
; ENTRY : HL = ADDRESS TO BE DISPLAYED
;
; EXIT  : NO REGISTERS MODIFIED
;
DISADD	PUSH	AF
	PUSH	HL
	PUSH	 HL
	LD	A,H
	CALL	CONBYT
	LD	(DISBUF+4),HL
	POP	HL
	LD	A,L
	CALL	CONBYT
	LD	(DISBUF+2),HL
	POP	HL
	POP	AF
	RET
;---------------------------
; DATA BYTE > DISPLAY BUFFER
;---------------------------
;CONVERT THE ACC TO SEVEN SEGMENT CODE
;AND PUT IN DATA DISPLAY BUFFER.
;
; ENTRY :  A = DATA DISPLAY BYTE
;
; EXIT  : NO REGISTERS MODIFIED
;
DISBYT	PUSH	HL
	CALL	CONBYT
	LD	(DISBUF),HL
	POP	HL
	RET
;---------------------------------------
; CONVERT BYTE TO 7 SEGMENT DISPLAY CODE
;---------------------------------------
; CONVERTS BYTE IN ACC TO SEVEN SEGMENT CODE
; FOR DISPLAY
; ENTRY : A = BYTE TO BE CONVERTED
; EXIT  : H = HI NYBBLE SEVEN SEGMENT CODE
;         L = LO NYBBLE SEVEN SEGMENT CODE
;         A = NOT MODIFIED
CONBYT	PUSH	AF
	PUSH	AF
	CALL	CONVHI	;CONVERT HI NYBBLE
	LD	H,A
	POP	AF
	CALL	CONVLO	;CONVERT LO NYBBLE
	LD	L,A
	POP	AF
	RET
;---------------------------------------------
; HEXADECIMAL TO SEVEN SEGMENT CODE CONVERSION
;---------------------------------------------
; CONVERTS NYBBLE IN ACC TO SEVEN SEGMENT CODE
; FOR SEVEN SEGMENT DISPLAYS
; CONVHI = CONVERTS HIGH NYBBLE
; CONVLO = CONVERTS LO NYBBLE
;
; ENTRY : A = NYBBLE TO BE CONVERTED
; EXIT  : A = SEVEN SEGMENT CODE
;
CONVHI	RLCA
	RLCA
	RLCA	;MOVE TO LO NYBBLE
	RLCA	;FOR CONVERSION
CONVLO	PUSH	BC
	PUSH	HL
	LD	HL,SEGMNT	;USE THE HEX VALUE
	AND	0FH	;TO INDEX TO THE
	LD	C,A	;THE SEVEN SEGMENT
	LD	B,00H	;CODE FOR THAT VALUE
	ADD	HL,BC	;AND RETURN WITH
	LD	A,(HL)	;CODE IN A
	POP	HL
	POP	BC
	RET
;
; HEXADECIMAL TO 7 SEGMENT DISPLAY CODE TABLE
;
SEGMNT	.DB	3FH,06H,5BH,4FH ;0,1,2,3
	.DB	66H,6DH,7DH,07H ;4,5,6,7
	.DB	7FH,6FH,77H,7CH ;8,9,A,B
	.DB	39H,5EH,79H,71H ;C,D,E,F
;-------------
; SCAN DISPLAY
;-------------
;AS THE DISPLAYS ARE MULTIPLEXED, THE DATA FOR EACH
;DISPLAY MUST BE LATCHED INTO THE DISPLAY SEGMENT
;LATCH IN TURN AND THE CORRESPONDING BIT IN THE DISPLAY
;SCAN LATCH TURNED ON TO DISPLAY THE DATA.
;TWO SHORT DELAYS ARE USED TO ADJUST THE DUTY
;CYCLE AND HENCE DISPLAY BRIGHTNESS.
;
; ENTRY : NONE
; EXIT  : NO REGISTERS MODIFIED
;
SCAND   PUSH    AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	HL,DISBUF+5
	LD	C,20H
SCAND1	LD	A,(HL)
	OUT	(DISPLY),A	;OUTPUT CHARACTER
	LD	A,C
	OUT	(SCAN),A	;TURN ON DISPLAY
	LD	A,(ONTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST ON TIME
SCAND2	DJNZ	SCAND2	;OF DISPLAY
	LD	A,B	;B IS NOW CLEAR, USE
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	LD	A,(OFTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST OFF TIME
SCAND3	DJNZ	SCAND3	;OF DISPLAY
	DEC	HL	;POINT TO NEXT
	RRC	C	;ELEMENT IN BUFFER
	JR	NC,SCAND1	;DISPLAY NEXT ELEMENT
	LD	A,B	;B IS NOW CLEAR, USE
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	OUT	(DISPLY),A	;AND CLEAR DISPLAY LATCH
	POP	HL
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;---------------------
; CLEAR DISPLAY BUFFER
;---------------------
CLRBUF	PUSH	HL
	PUSH	BC
	LD	HL,DISBUF
	LD	B,6
CLRBF1	LD	(HL),00H	;PUT ZERO IN 6
	INC	HL	;LOCATIONS POINTED
	DJNZ	CLRBF1	;TO BY HL
	POP	BC
	POP	HL
	RET
;--------------
; SCAN KEYBOARD
;--------------
; USE DISPLAY SCAN DRIVERS FOR COLUMNS
; AND KEYBOARD BUFFER AS ROWS.
; MAKE EACH DATA LINE HIGH IN TURN AND CHECK
; IF EACH INDIVIDUAL PUSHBUTTON IS PRESSED.
;
; NEW ROUTINE VERSION 1.3
;
; ENTRY : NONE
; EXIT  : A = 00H IF NO KEY DETECTED
;         A = DETECTED KEY WITH BIT 5 SET
;         BIT 5 USED AS DATA AVAILABLE LIKE 74C922 KEYBOARD ENCODER
SCANKEY PUSH    BC
	PUSH    DE              ;SAVE REGISTERS
	PUSH	HL
	LD	A,(SYSFLG)
	BIT	0,A
	JR	NZ,SCANKY1
	IN	A,(KEYBUF)	;READ HARDWARE ENCODER
	AND	3FH		;STRIP UNUSED BITS
	JR	SCANKY7		;EXIT
;
; SOFTWARE SCAN KEYBOARD
;
SCANKY1	LD      A,00H
	OUT     (DISPLY),A      ;CLEAR DISPLAY LATCH
	LD      B,A		;KEY
	LD	D,A		;COUNT
	LD      E,01H           ;MASK
SCANKY2 LD      C,08H           ;SCAN
SCANKY3 LD      A,C
	OUT     (SCAN),A        ;OUTPUT SCAN
	NOP
	NOP
	NOP
	IN      A,(KEYBUF)      ;READ KEY BUFFER
	AND     E               ;MASK 
	JR      Z,SCANKY4       ;KEY NOT DETECTED
	INC	D
	LD	L,B		;SAVE KEY
;
; END OF ROWS?
;
SCANKY4 INC     B               ;NEXT KEY
	SRA     C               ;SHIFT SCAN RIGHT
	JR      NC,SCANKY3      ;NEXT ROW
;
; END OF COLUMNS?
;
	SLA     E               ;SHIFT MASK LEFT
	BIT     5,E             ;END OF KEYSCAN?
	JR      Z,SCANKY2	;NEXT COLUMN
;
; END OF SCAN
;
	LD	A,D
	CP	00H
	JR	Z,SCANKY6	;NO KEY PRESSED
	CP	01H
	JR	NZ,SCANKY1	;MORE THAN ONE KEY PRESSED
;
; ONE KEY DETECTED
;
	LD	A,00H
	OUT	(SCAN),A	;CLEAR SCAN REG
	LD	A,L		;RETURN KEY IN A
	SET	5,A		;SET DATA AVAILABLE FLAG
	JR	SCANKY7
;
; NO KEY
;	
SCANKY6	LD	A,00H
	OUT	(SCAN),A	;CLEAR SCAN REG
SCANKY7 POP	HL
	POP     DE
	POP     BC
	RET
;-----------------------------
; SCAN DISPLAY UNTIL KEY PRESS
;-----------------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
SKEYIN	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A	;DA  HIGH?
	JR	Z,SKEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
; ENTRY : NONE
; EXIT  : NONE
;
SKEYRL	PUSH	AF
SKEYL1	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A	;DA LOW?
	JR	NZ,SKEYL1	;KEY NOT RELEASED
	POP	AF
	RET
;-------------------
; WAIT FOR KEY PRESS
;-------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
KEYIN	CALL	SCANKEY
	BIT	5,A
	JR	Z,KEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;---------------------
; WAIT FOR KEY RELEASE
;---------------------
; ENTRY : NONE
; EXIT  : NONE
;
KEYREL	PUSH	AF
KEYRL1  CALL	SCANKEY
	BIT	5,A
	JR	NZ,KEYRL1
	POP	AF
	RET
;-----------------
; KEY MENU HANDLER
;-----------------
; COMPARES ACC AGAINST TABLE OF ELEMENTS,
; IF FOUND JUMP TO ADDRESS CORRESPONDING TO
; THAT ELEMENT, RETURNS IF ELEMENT NOT FOUND.
; ENTRY :  A = ELEMENT TO LOOK FOR
;         HL = POINTS TO TABLE
; EXIT  :  ELEMENT NOT FOUND
;           HL HOLDS ADDRESS OF LAST ELEMENT
;          ELEMENT FOUND
;           CONTROL PASSES TO JUMP ADDRESS WITH
;          RETURN ADDRESS OF MENU CALL ON STACK
;
MENU	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
	PUSH	HL	;CALCULATE ADDRESS
	LD	D,00H	;OF THE JUMP TABLE BY
	LD	E,(HL)	;ADDING THE INDEX TO
	INC	HL	;THE ELEMENTS
	ADD	HL,DE	;TO THE ADDR OF THE
	LD	D,H	;TABLE
	LD	E,L
	POP	HL
	LD	B,(HL)	;GET NUMBER OF ENTRIES
	INC	HL	;POINT TO LIST OF ENTRIES
MENU1	CP	(HL)	;COMPARE WITH ENTRY
	JR	Z,MENU2	;FOUND VALUE IN TABLE
	INC	HL	;NEXT ENTRY IN LIST
	INC	DE	;NEXT ENTRY IN
	INC	DE	;JUMP TABLE
	DJNZ	MENU1	;CHECK MORE ENTRIES
	POP	DE
	POP	BC
	POP	AF
	RET	;NOT IN TABLE
;
; FOUND ELEMENT IN THE TABLE
; PASS CONTROL TO THE JUMP HANDLER
;
MENU2	LD	A,(DE)	;GET THE JUMP ADDR
	LD	L,A	;FROM THE TABLE
	INC	DE	;AND JUMP TO
	LD	A,(DE)	;THE JUMP ADDRESS
	LD	H,A	;FOR THAT ENTRY
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	JP	(HL)
;-------------------
; CALCULATE CHECKSUM
;-------------------
;CALCULATES CHECKSUM BETWEEN START AND END (INCLUSIVE)
;
; ENTRY : HL = START OF BLOCK TO SUM
;         DE = END OF BLOCK TO SUM
; EXIT  : A =  CHECKSUM
;         FLAG REGISTER MODIFIED
;
CHKSUM	PUSH	HL
	PUSH	DE
	INC	DE	;END OF BLOCK+1
	XOR	A	;CLEAR CHECKSUM
CHKSM1	ADD	A,(HL)	;COMPUTE CHEKSUM
	INC	HL	;POINT TO NEXT ELEMENT
	AND	A	;SET CARRY
	PUSH	HL
	SBC	HL,DE	;SUBTRACT
	POP	HL
	JR	C,CHKSM1	;MORE ELEMENTS
	POP	DE
	POP	HL
	RET
;--------------------------
; ACCESS BYTE LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS BYTE LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF ELEMENT A
;
INDEXB	PUSH	DE
	LD	E,A	;USE DE AS INDEX
	LD	D,0	;TO ELEMENT IN TABLE
	ADD	HL,DE	;BY ADDING TO HL
	POP	DE
	RET
;--------------------------
; ACCESS WORD LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS WORD LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF 2 BYTE ELEMENT A
;
INDEXW	PUSH	DE
	LD	E,A
	SLA	E	;MULTIPLY BY TWO
	LD	D,0
	ADD	HL,DE
	POP	DE
	RET
;-------------------------------
; GENERATE A QUASI-RANDOM NUMBER
;-------------------------------
; GENERATE AN 16 BIT RANDOM NUMBER
; USING LINEAR CONGRUENTIAL METHOD.
;     Rn+1 = (aRn+c) MOD m
; REFRESH REGISTER USED FOR Rn AND c
;	ENTRY : NONE
;	EXIT  : HL = RANDOM WORD
;	NO REGISTERS MODIFIED
;
RAND	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
;
; CALCULATE aRn
;
	LD	A,R	;MULTIPLY RANDOM NUMBER
	LD	E,A	;(Rn) BY
	LD	D,0
	LD	HL,0548H	;CONSTANT (a)
	CALL	MUL16
;
; CALCULATE aRn+c
;
	LD	A,R	;ADD IT TO ANOTHER
	LD	B,0	;READ OF THE
	LD	C,A	;THE REFRESH
	ADD	HL,BC	;REGISTER (c)
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;----------------------
; 16 BIT MULTIPLICATION
;----------------------
;16 BIT MULTIPLY
; ENTRY : HL = MULTIPLICAND (MPD)
;         DE = MULTIPLIER (MPR)
; EXIT : HL = RESULT
;SEE ZAKS 'PROGRAMMING THE Z80'
;
MUL16	PUSH	AF
	PUSH	BC
	LD	C,H	;MPR(H)
	LD	A,L	;MPR(L)
	LD	B,16	;BIT COUNTER
	LD	HL,0	;CLEAR RESULT
MULT	SRL	C	;MPR (H)
	RRA	;MPR (L)
	JR	NC,MULT1	;TEST CARRY
	ADD	HL,DE	;ADD MPD TO RESULT
MULT1	EX	DE,HL
	ADD	HL,HL	;DOUBLE -SHIFT MPD LEFT
	EX	DE,HL
	DJNZ	MULT	;DONE?
	POP	BC
	POP	AF
	RET
;----------------
; MUSIC SEQUENCER
;----------------
; SEQUENCES THROUGH A TABLE OF NOTES
; 1EH = REPEAT TUNE UNTIL RESET
; 1FH = PLAY ONCE AND RETURN
; ENTRY : HL = ADDRESS OF NOTE TABLE
; EXIT : NO REGISTERS MODIFIED
MUSIC	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF MUSIC
;
; PLAY EACH NOTE IN TURN
;
STEP	LD	A,(DE)	;GET ELEMENT FROM TABLE
	AND	1FH	;STRIP UNUSED BITS
;
; IF ELEMENT IS 00H PAUSE FOR A WHILE
;
	CP	00H
	JP	NZ,STEP1
	LD	BC,1000H
PAUSE	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,PAUSE	;LOOP UNTIL DE = 0
	INC	DE	;POINT TO NEXT ELEMENT
	JP	STEP
;
; IF ELEMENT IS 1EH REPEAT TUNE
;
STEP1	CP	1EH
	JP	NZ,STEP2
	POP	DE	;GET TABLE ADDRESS BACK
	PUSH	DE	;SAVE IT FOR LATER
	JP	STEP
;
; IF ELEMENT IS 1FH RETURN
;
STEP2	CP	1FH	;END OF TUNE TABLE?
	JP	NZ,STEP3
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
;NOW PLAY THE NOTE
;
STEP3	LD	B,A	;SAVE ELEMENT IN B
	LD	HL,PERIOD	;POINT TO PERIOD/2 TABLE
	CALL	INDEXB	;GET PERIOD/2
	LD	A,(HL)	;GET ELEMENT
	PUSH	AF	;SAVE FOR LATER
	LD	A,B	;GET ELEMENT BACK IN A
	LD	HL,LENGTH	;POINT TO DURATION/2 TABLE
	CALL	INDEXB	;GET DURATION/2
	LD	A,(HL)	;GET ELEMENT
	LD	L,A
	LD	H,0	;HL = DURATION/2
	POP	AF
	CALL	TONE	;DO NOTE ROUTINE
	INC	DE
	JP	STEP	;STEP TO NEXT ELEMENT
;
; PERIOD/2 OF NOTE
;
PERIOD	.DB	8CH,83H,7CH,75H,70H,67H,62H,5CH
	.DB	57H,52H,4EH,48H,45H,41H,3CH,39H
	.DB	36H,32H,2FH,2CH,2AH,27H,25H,23H
;
; NOTE DURATION/2
;
LENGTH	.DB	19H,1AH,1CH,1DH,1EH,20H,23H,25H
	.DB	27H,29H,2CH,2EH,31H,33H,37H,3AH
	.DB	3DH,41H,45H,49H,4DH,52H,57H,5CH
	.DB	10H
;--------------
; OUTPUT A TONE
;--------------
;
; ENTRY : A = PERIOD/2 OF NOTE
;         HL = DURATION/2 OF NOTE
; EXIT NO REGISTERS MODIFIED
TONE PUSH	AF
	 PUSH	BC
	 PUSH	DE
	 PUSH	HL
	 LD	DE,0001H
	 LD	C,A
	 ADD	HL,HL	;DOUBLE DURATION
	 XOR	A
TONE1	XOR	80H	;TOGGLE SPEAKER BIT
	OUT	(SCAN),A	;OUTPUT SPEAKER BIT
	LD	B,C
TONE2	PUSH	BC
	LD	B,02H
TONE3	DJNZ	TONE3	;DELAY FOR PERIOD/2
	POP	BC
	DJNZ	TONE2	; DELAY FOR PERIOD/2
	SBC	HL,DE	;END OF NOTE?
	JR	NZ,TONE1	;DO AGAIN
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;---------------
; KEY ENTRY BEEP
;---------------
BEEP	PUSH	HL
	PUSH	AF
	LD	HL,MODE
	BIT	6,(HL)	;BEEP ENABLED?
	JR	Z,BEEP2	;BEEP IS ENABLED
;
; DO KEYPRESS DELAY
;
	PUSH	DE	;DO A SHORT
	LD	DE,0001H	;DELAY TO PREVENT
	LD	HL,(KEYTIM)	;RECOGNITION
BEEP1	SBC	HL,DE	;OF DOUBLE
	JR	NC,BEEP1	;KEY STROKES
	POP     DE
	JR	BEEP3
;
; OUTPUT KEYPRESS TONES
;
BEEP2	LD	A,24H
	LD	HL,0030H
	CALL	TONE	;DO FIRST TONE
	LD	A,0EH
	LD	HL,0050H
	CALL	TONE	;DO SECOND TONE
BEEP3	POP	AF
	POP	HL
	RET
;----------------------------------------
; BREAKPOINT AND SINGLE STEPPING ROUTINES
;----------------------------------------
;DISPLAYS AND MODIFIES REGISTERS AFTER BREAKPOINT
; (RST 38H) OR SINGLE STEP INTERRUPT (IF HARDWARE
; ATTACHED).
;INSERT RST 38H (FFH) IN PROGRAM TO EXAMINE
; AND MODIFY REGISTERS.
;
SSTEP	POP	HL	;GET HL BACK
	PUSH	AF	;SAVE AF FOR LATER
	LD	(HL_REG),HL
	LD	(DE_REG),DE
	LD	(BC_REG),BC
	LD	(IX_REG),IX
	LD	(IY_REG),IY	;SAVE REGISTERS
	POP	HL	;GET AF BACK
	LD	(AF_REG),HL	;SAVE AF
	POP	HL	;GET PC RETURN ADDRESS
	LD	(PC_REG),HL	;SAVE PC
	LD	(SP_REG),SP	;SAVE STACK POINTER
;
; STEP THROUGH,DISPLAY AND EDIT REGISTERS
;
	CALL	BEEP
	LD	A,(REGPNT)	;GET CURRENT REG
	AND	7	;MAKE SURE IN LIMITS
	LD	(REGPNT),A	;SAVE IT
DISREG	CALL	SETREG	;SET UP DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR A KEY
	CALL	SKEYIN	;WAIT FOR KEY RELEASE
	LD	HL,REGTBL	;HANDLE THE KEY
	CALL	MENU	;AND UPDATE DISPLAY
	JP	DISREG	;BEFORE RETURNING TO LOOP
;
; REGISTER DISPLAY KEY TABLE
;
REGTBL	.DB	14H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	RETMON,RETPGM,INCSTP,DECSTP
;
; REGISTER NAME CHARACTERS
;
REGNAM	.DW	7339H
	.DW	7771H,7C39H,5E79H
	.DW	7438H,0676H,066EH
	.DW	6D73H
;--------------
; EDIT REGISTER
;--------------
REGKEY	CALL	BEEP
	PUSH	AF	;SAVE KEY FOR LATER
	LD	A,(REGPNT)
;
; EDIT REGISTER
;
	LD	HL,PC_REG
	CALL	INDEXW
	LD	C,(HL)
	INC	HL
	LD	B,(HL)	;GET REG CONTENTS
	SLA	C
	RL	B
	SLA	C
	RL	B
	SLA	C
	RL	B	;SHIFT REGISTER
	SLA	C	;FOUR BITS
	RL	B	;LEFT AND
	POP	AF	;PUT THE KEY
	OR	C	;INTO THE LSN
	LD	C,A	;AND PUT THE
	LD	(HL),B	;REGISTER BACK
	DEC	HL	;WHERE IT BELONGS
	LD	(HL),C
	RET
;------------------
; RETURN TO MONITOR
;------------------
RETMON	CALL	BEEP
	CALL	SKEYRL
	EI	;ENABLE INTERRUPTS AGAIN
	JP	MAIN
;------------------
; RETURN TO PROGRAM
;------------------
RETPGM	LD	SP,(SP_REG)	;PUT STACK POINTER BACK
	LD	HL,(PC_REG)	;PUT RETURN
	PUSH	HL	;ADDRESS BACK ON STACK
	LD	HL,(AF_REG)
	PUSH	HL	;SAVE AF REG FOR LATER
	LD	IY,(IY_REG)
	LD	IX,(IX_REG)
	LD	BC,(BC_REG)
	LD	DE,(DE_REG)	;RESTORE REGISTERS
	POP	AF	;RESTORE AF
	LD	HL,(HL_REG)	;RETORE HL
	EI	;ENABLE INTERRUPTS
	RET	;AND RETURN TO PROGRAM
;----------------------
; DISPLAY NEXT REGISTER
;----------------------
INCSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	A,7	;END OF REG TABLE?
	JP	Z,INCSP1
	INC	A
	LD	(REGPNT),A
	RET
INCSP1	XOR	A
	LD	(REGPNT),A
	RET
;--------------------------
; DISPLAY PREVIOUS REGISTER
;--------------------------
DECSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	A,0	;START OF REG TABLE?
	JP	Z,DECSP1
	DEC	A
	LD	(REGPNT),A
	RET
DECSP1	LD	A,7
	LD	(REGPNT),A
	RET
;-----------------
; DISPLAY REGISTER
;-----------------
SETREG	LD	A,(REGPNT)
	LD	HL,PC_REG	;START OF TABLE
	CALL	INDEXW	;GET ELEMENT ADDRESS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL	;LOAD REGISTER CONTENTS
	CALL	DISADD
;
; DISPLAY REGISTER NAME
;
	LD	HL,REGNAM
	CALL	INDEXW
	LD	A,(HL)
	LD	(DISBUF+0),A
	INC	HL
	LD	A,(HL)
	LD	(DISBUF+1),A
	RET
;------------------
; FUNCTION KEY MENU
;------------------
; WHEN THE FN KEY IS PRESSED, Fn IS DISPLAYED IN THE
; DATA DISPLAYS, THE CURRENT ADDRESS REMAINS IN THE
; ADDRESS DISPLAYS THE PROGRAM THEN WAITS FOR A
; KEYPRESS WHICH WILL SELECT 1 OF 16 ROUTINES.
;
FUNKEY	POP	HL	;REMOVE RETURN ADDRESS
	CALL	BEEP
FUNKY1	LD	HL,(ADRESS)
	CALL	DISADD	;DISP ADDR TO REMOVE DP'S
	LD	HL,7154H
	LD	(DISBUF),HL	;DISPLAY FN
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
FUNKY2	CALL	SKEYIN
	LD	HL,(FUNTBL)	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
	JP	FUNKY2	;TRY AGAIN
;
; RETURN TO MAIN
;
CANCEL	CALL	BEEP
CANCL1	CALL	UPDATE	;UPDATE DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	POP	HL	;REMOVE MENU RETURN
	JP	MAIN2
;
; FUNCTION MENU KEY TABLE
;
FUNLST	.DB	11H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H
	.DW	GOEXEC,INTELFN,ADDRA,ADDRB
	.DW	BLKMVE,BLKSUM,BRANCH,TRACE
	.DW	PLAY1,PLAY2,PLAY3,SWBEEP
	.DW	SECRET,RELSQR,SCOPE,TIME
	.DW	FUNFUN
;--------------------------
; JUMP TO FUNCTION FUNCTION
;--------------------------
FUNFUN	LD	HL,(FUNJMP)
	JP	(HL)
;------------------------------------------
; FUNCTION 0 - EXECUTE FROM CURRENT ADDRESS
;------------------------------------------
GOEXEC	CALL	BEEP
	CALL	KEYREL
	POP	HL	;REMOVE EXEC RETURN
	LD	HL,(ADRESS)
	JP	(HL)	;START EXECUCTION
;------------------------------------
; FUNCTION 1 RECEIVE INTEL HEX FORMAT
;------------------------------------
INTELFN	CALL	BEEP
	    CALL	KEYREL
        CALL  INTELH
        JP    NZ,BLKMV1      ;SHOW THE ERROR 
        JP    CANCEL         ;JUST RETURN IF ALL OK
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTELH	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
;
; WAIT FOR RECORD MARK
;
INTEL1	XOR	A
	LD	(IX+3),A	;CLEAR CHECKSUM
	CALL	RXDATA	;WAIT FOR THE RECORD MARK
	CP	':'	;TO BE TRANSMITTED
	JR	NZ,INTEL1	;NOT RECORD MARK
;
; GET RECORD LENGTH
;
	CALL	GETBYT
	LD	(IX+0),A	;NUMBER OF DATA BYTES
;
; GET ADDRESS FIELD
;
	CALL	GETBYT
	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
	CALL	GETBYT
	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
;
; GET RECORD TYPE
;
	CALL	GETBYT
	JR	NZ,INTEL4	;END OF FILE RECORD
;
; READ IN THE DATA
;
	LD	B,(IX+0)	;NUMBER OF DATA BYTES
	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE

INTEL2	CALL	GETBYT	;GET DATA BYTE
	LD	(HL),A	;STORE DATA BYTE
	INC	HL
	DJNZ	INTEL2	;LOAD MORE BYTES
;
; GET CHECKSUM AND COMPARE
;
	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE RECORD CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
    RET             ;NZ=CHECKSUM ERROR
;
; END OF FILE RECORD
;
INTEL4	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE EOF CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	RET  	    ;NZ=CHECKSUM ERROR
;--------------------------
; GET BYTE FROM SERIAL PORT
;--------------------------
GETBYT	PUSH	BC
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT1
	ADD	A,09H
GETBT1	AND	0FH
	SLA 	A
	SLA	A
	SLA	A
	SLA	A
	LD	C,A
;
; GET LOW NYBBLE
;
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT2
	ADD	A,09H
GETBT2	AND	0FH
	OR	C
	LD	B,A
	ADD	A,(IX+3)
	LD	(IX+3),A	;ADD TO CHECKSUM
	LD	A,B
	AND	A	;CLEAR CARRY
    POP	BC
	RET
;-------------------------------
; CONVERT ASCII CHARACTER TO HEX
;-------------------------------
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : A= HEX 0-F IN LSN
; A AND F REGISTERS MODIFIED
;
ASCHEX BIT   6,A
	   JR    Z,ACHEX1
	   ADD   A,09H
ACHEX1 AND   0FH
       RET
;------------------------
; SERIAL TRANSMIT ROUTINE
;------------------------
;TRANSMIT BYTE SERIALLY ON DOUT
;
; ENTRY : A = BYTE TO TRANSMIT
;  EXIT : NO REGISTERS MODIFIED
;
TXDATA	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(BAUD)
	LD	C,A
;
; TRANSMIT START BIT
;
	XOR	A
	OUT	(SCAN),A
	CALL	BITIME
;
; TRANSMIT DATA
;
	LD	B,08H
	RRC	C
NXTBIT	RRC	C	;SHIFT BITS TO D6,
	LD	A,C	;LSB FIRST AND OUTPUT
	AND	40H	;THEM FOR ONE BIT TIME.
	OUT	(SCAN),A
	CALL	BITIME
	DJNZ	NXTBIT
;
; SEND STOP BITS
;
	LD	A,40H
	OUT	(SCAN),A
	CALL	BITIME
	CALL	BITIME
	POP	HL
	POP	BC
	POP	AF
	RET
;-----------------------
; SERIAL RECEIVE ROUTINE
;-----------------------
;RECEIVE SERIAL BYTE FROM DIN
;
; ENTRY : NONE
;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
;
; REGISTERS MODIFIED A AND F
;
RXDATA	PUSH	BC
	PUSH	HL
;
; WAIT FOR START BIT 
;
RXDAT1 IN	A,(KEYBUF)
	   BIT	7,A
	   JR	NZ,RXDAT1	;NO START BIT
;
; DETECTED START BIT
;
	LD	HL,(BAUD)
	SRL	H
	RR	L 	;DELAY FOR HALF BIT TIME
	CALL 	BITIME
	IN	A,(KEYBUF)
	BIT	7,A
	JR	NZ,RXDAT1	;START BIT NOT VALID
;
; DETECTED VALID START BIT,READ IN DATA
;
	LD	B,08H
RXDAT2	LD	HL,(BAUD)
	CALL	BITIME	;DELAY ONE BIT TIME
	IN	A,(KEYBUF)
	RL	A
	RR	C	;SHIFT BIT INTO DATA REG
	DJNZ	RXDAT2
	LD	A,C
	OR	A	;CLEAR CARRY FLAG
    POP	HL
	POP	BC
	RET
;---------------
; BIT TIME DELAY
;---------------
;DELAY FOR ONE SERIAL BIT TIME
;ENTRY : HL = DELAY TIME
; NO REGISTERS MODIFIED
;
BITIME	PUSH	HL
	PUSH	DE
	LD	DE,0001H
BITIM1	SBC	HL,DE
	JP	NC,BITIM1
	POP	DE
	POP	HL
	RET
;-----------------------------
; FUNCTION 2 - ENTER ADDRESS 1
;-----------------------------
ADDRA	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKSRT),HL	;ADDRESS AS START
	LD	HL,3900H	;ADDRESS
	CALL	SDELAY
	JP	CANCL1
;-----------------------------
; FUNCTION 3 - ENTER ADDRESS 2
;-----------------------------
ADDRB	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKEND),HL	;ADDRESS AS END
	LD	HL,000FH	;ADDRESS
	CALL	SDELAY
	JP	CANCL1
;------------------------
; FUNCTION 4 - BLOCK MOVE
;------------------------
BLKMVE	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKDST),HL	;ADDRESS AS
	LD	HL,390FH	;DESTINATION
	CALL	SDELAY
;
; CALCULATE NUMBER OF BYTES TO MOVE
;
	LD	HL,(BLKEND)
	LD	DE,(BLKSRT)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE MOVE INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKMV3	;IF OK MOVE BLOCK
;
; SHOW ERROR
;
BLKMV1	LD	HL,0079H	;SHOW ERROR
BLKMV2	CALL	BEEP
	LD	(DISBUF),HL	;AND WAIT
	CALL	SKEYIN	;FOR KEYPRESS
	CALL	BEEP
	CALL	SKEYRL
	JP	CANCL1
;
; MOVE BLOCK
;
BLKMV3	CALL	MOVE
	JP	CANCL1
;-----------
; BLOCK MOVE
;-----------
MOVE	LD	BC,(COUNT)
	LD	HL,(BLKSRT)	;START ADDR
	LD	DE,(BLKDST)	;DESTINATION ADDR
	LDIR
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
SDELAY	LD	(DISBUF),HL	;SHOW HL
	LD	B,255	;IN DATA DISPLAYS
SDELY1	CALL	SCAND	;UNTIL KEY
	DJNZ SDELY1	;IS RELEASED
	CALL	SKEYRL
	RET
;---------------------------
;FUNCTION 5 - BLOCK CHECKSUM
;---------------------------
BLKSUM	CALL	BEEP
	LD	HL,396DH
	CALL	SDELAY	;SHOW PROMPT
	LD	DE,(BLKSRT)
	LD	HL,(BLKEND)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE CHECKSUM INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKSM1	;IF OK SUM BLOCK
;
; SHOW ERROR
;
	JP	BLKMV1
;
; CALCULATE CHECKSUM
;
BLKSM1	LD	HL,(BLKSRT)
	LD	DE,(BLKEND)
	CALL	CHKSUM	;DO THE CHECKSUM,
	CALL	DISBYT	;DISPLAY
	LD	HL,(COUNT)	;NUMBER OF BYTES
	CALL	DISADD	;SUMMED AND
	CALL	BEEP
	CALL	SKEYIN	;CHECKSUM UNTIL
	CALL	BEEP	;A KEY IS PRESSED
	CALL	SKEYRL
	JP	CANCL1
;----------------------------------------
; FUNCTION 6 - RELATIVE BRANCH CALCULATOR
;----------------------------------------
BRANCH	CALL	BEEP
	LD	HL,507CH
	CALL	SDELAY
	LD	HL,(ADRESS)	;GET CURRENT ADDRESS
	LD	DE,(BLKSRT)
	INC	DE	;POINT TO PC+2
	AND	A
	SBC	HL,DE	;SUBTRACT
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF BACKWARD BRANCH
;
	LD	A,H
	CP	255	;BACKWARD BRANCH?
	JP	NZ,BRNCH1	;CHECK IF FORWARD
;
;CHECK IF WE HAVE BRANCHED BEYOND -128
;
	LD	A,L
	BIT	7,A
	JR	NZ,BRNCH2	;BRANCH IS WITHIN LIMITS
	JP	BLKMV1	;TOO FAR BACK
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF FORWARD BRANCH
;
BRNCH1	CP	0	;FORWARD BRANCH?
	JP	NZ,BLKMV1	;TOO FAR IN ANY DIRECTION
;
; CHECK IF WE HAVE BRANCHED BEYOND +128
;
	LD	A,L
	BIT	7,A
	JP	NZ,BLKMV1	;TOO FAR FORWARD
;
; WITHIN LIMITS PUT IN RAM
; AND SHOW AS CURRENT ADDRESS
;
BRNCH2	LD	HL,(BLKSRT)
	LD	(ADRESS),HL
	LD	(HL),A
	JP	CANCL1
;-----------------------------------------
; FUNCTION 7 - TOGGLE HARDWARE SINGLE STEP
;-----------------------------------------
TRACE	CALL	BEEP
	OUT	(IO7),A	;TOGGLE HARDWARE LATCH
	LD	HL,0070H	;SHOW T
	CALL	SDELAY
	JP	CANCL1
;-------------------------
; FUNCTION 8 - PLAY TUNE 1
;-------------------------
PLAY1	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE1
	CALL	MUSIC
	JP	CANCL1
;-------------------------
; FUNCTION 9 - PLAY TUNE 2
;-------------------------
PLAY2	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE2
	CALL	MUSIC
	JP	CANCL1
;------------------------------
; FUNCTION A - PLAY TUNE IN RAM
;------------------------------
PLAY3	CALL	BEEP
	CALL	KEYREL
	LD	HL,(ADRESS)
	CALL	MUSIC
	JP	CANCL1
;-----------------------------
; FUNCTION B - TOGGLE KEY BEEP
;-----------------------------
SWBEEP	CALL	BEEP
	LD	A,(MODE)
	XOR	40H
	LD	(MODE),A
	JP	CANCL1
;
; TUNE 1
;
TUNE1	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,0FH,0AH,0DH,0FH
	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,06H,12H,00H,1EH
;
; TUNE 2
;
TUNE2	.DB	0BH,0AH,08H,0AH,0AH,0AH,06H,06H
	.DB	06H,0BH,0AH,08H,0AH,0AH,0AH,0AH
	.DB	0AH,0AH,0BH,0AH,08H,0AH,0AH,0AH
	.DB	06H,06H,06H,0AH,08H,0AH,0DH,0DH
	.DB	0DH,0DH,0DH,00H,0DH,05H,08H,0BH
	.DB	0BH,0BH,06H,06H,06H,0BH,0AH,08H
	.DB	0AH,0AH,0AH,06H,06H,06H,0BH,0AH
	.DB	06H,08H,08H,08H,08H,08H,0AH,0BH
	.DB	0AH,08H,06H,06H,06H,06H,06H,06H
	.DB	00H,00H,00H,1EH
;---------------------------
; FUNCTION C - SECRET NUMBER
;---------------------------
SECRET	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND CLEAR DISPLAY
	CALL	CLRBUF	;BUFFER
	LD	IX,SYSTEM	;USE IX FOR LOCAL VARIABLES
;
; SEPARATE NYBBLES IN RANDOM NUMBER
;
	CALL	RAND
	LD	(IX+11),L
	LD	(IX+12),H	;RANDOM NUMBER
	LD	A,(IX+11)	;SEPARATE THE RANDOM
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+4),L	;FOUR NYBBLES
	LD	(IX+5),H	;TO MAKE CHECKING
	LD	A,(IX+12)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+6),L
	LD	(IX+7),H
	XOR	A
	LD	I,A	;CLEAR NUMBER OF TRIES
	LD	HL,0
	LD	(IX+8),L
	LD	(IX+9),H
	CALL	DISADD	;AND DISPLAY GUESS
;
; SCAN THE KEYBOARD
;
SECRT1	CALL	SKEYIN	;WAIT FOR KEY
	LD	HL,SECNUM
	CALL	MENU	;EXECUTE KEY HANDLER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	SECRT1
;
; SECRET NUMBER KEY TABLE
;
SECNUM	.DB	12H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	ENDKEY,CHKKEY
;---------------
; EDIT GUESS KEY
;---------------
EDTKEY	PUSH	AF
	LD	L,(IX+8)
	LD	H,(IX+9)	;GET CURRENT GUESS
	SLA	L
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	POP	AF
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(IX+8),L
	LD	(IX+9),H	;SAVE GUESS
	CALL	DISADD
	CALL	BEEP
	RET
;----------
; QUIT GAME
;----------
ENDKEY	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND RETURN TO
	JP	MAIN	;MONITOR
;---------------------------
; SEE IF ITS THE RIGHT GUESS
;---------------------------
CHKKEY	CALL	BEEP
	LD	A,I
	INC	A
	DAA	;INC BCD NO. OF TRIES
;
; BRIEFLY SHOW GUESS NO.
;
	LD	I,A
	CALL	DISBYT
	LD	B,255
CHKKY1	CALL	SCAND
	DJNZ	CHKKY1
;
; SEPARATE GUESS INTO NYBBLES
;
	LD	A,(IX+8)	;GET CURRENT GUESS
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+0),L	;FOUR NYBBLES
	LD	(IX+1),H	;TO MAKE CHECKING
	LD	A,(IX+9)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+2),L
	LD	(IX+3),H
;
; CHECK FOR CORRECT NUMBER,CORRECT SPOT
;
	XOR	A
	LD	(IX+10),A	;CLEAR RESULT
	LD	HL,SYSTEM+4	;POINT TO RANDOM
	LD	DE,SYSTEM	;POINT TO GUESS
	LD	B,4	;NUMBER OF DIGITS
CHKKY2	LD	A,(HL)	;GET RANDOM
	EX	DE,HL
	CP	(HL)	;SAME AS GUESS?
	JR	NZ,CHKKY4	;NOT SAME
	LD	A,(IX+10)
	ADD	A,10H	;RIGHT POSITION
	LD	(IX+10),A
CHKKY3	INC	HL	;POINT TO NEXT
	EX	DE,HL	;DIGIT POSITION
	INC	HL	;AND GO
	DJNZ	CHKKY2	;CHECK OTHER POSITIONS
	JP	CHKKY8
;
; CHECK IF NUMBER IS THERE
;
CHKKY4	PUSH	BC
	PUSH	HL
	LD	B,4	;CHECK EACH DIGIT
	LD	HL,SYSTEM	;TO SEE IF THIS
CHKKY5	CP	(HL)	;NUMBER IS IN
	INC	HL	;THE WRONG
	JR	NZ,CHKKY6	;POSITION
	LD	A,(IX+10)	;AND UPDATE
	INC	A	;THE RESULT
	LD	(IX+10),A
	JP	CHKKY7
CHKKY6	DJNZ	CHKKY5
CHKKY7	POP	HL
	POP	BC
	JP	CHKKY3	;CHECK NEXT DIGIT
;
; CHECK IF CORRECT
;
CHKKY8	LD	A,(IX+10)
	CP	40H	;IS IT CORRECT?
	JP	Z,CHKKY9	;YES!
	LD	A,(IX+10)	;NOT CORRECT
	CALL	DISBYT	;IN DATA DISPLAYS
	LD	A,I	;WAS THAT THE
	CP	20H	;LAST GUESS?
	RET	NZ	;NO TRY AGAIN
;
; RAN OUT OF TRYS
;
	CALL	CLRBUF	;DISPLAY
	LD	L,(IX+11)
	LD	H,(IX+12)	;THE RANDOM NUMBER
	CALL	DISADD	;AND PLAY
	LD	HL,LOSE	;THE LOSE
	JP	CHKKYA	;MUSIC
;
; GOT THE RIGHT ANSWER
;
CHKKY9	LD	A,I	;DISPLAY HOW MANY
	CALL	DISBYT	;AND PLAY THE WIN
	LD	L,(IX+11)
	LD	H,(IX+12)
	LD	HL,WIN	;MUSIC
;
; PLAY MUSIC AND WAIT FOR ANY KEY TO RESTART
;
CHKKYA	CALL	MUSIC	;PLAY THE MUSIC
	CALL	SKEYIN	;WAIT FOR A KEY
	CALL	BEEP
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	POP	HL	;AND RESTART THE GAME
	JP	SECRET
;
; WIN AND LOSE MUSIC
;
WIN	.DB	14H,12H,14H,17H,17H,12H,14H,10H,1FH
LOSE	.DB	01H,11H,01H,11H,01H,11H,1FH
;-------------------------------
; SEPARATE BYTE INTO TWO NYBBLES
;-------------------------------
;SEPARATES A BYTE INTO TWO
;RIGHT JUSTIFIED NYBBLES
; ENTRY : A = BYTE TO BE SEPARATED
; EXIT  : H = MSN
;         L = LSN
;
SPLIT	PUSH	AF
	PUSH	BC
	LD	B,A	;SAVE BYTE
	AND	0FH	;STRIP BITS LSN
	LD	L,A	;RETURN LSN IN L
	LD	A,B
	SRL	A
	SRL	A
	SRL	A	;MOVE MSN
	SRL	A	;INTO LSN
	LD	H,A	;RETURN MSN IN H
	POP	BC
	POP	AF
	RET
;-----------------------------------
; FUNCTION D - RELAY BOARD SEQUENCER
;-----------------------------------
RELSQR	CALL	BEEP
	CALL	KEYREL
	LD	HL,RLTEST	;POINT TO TEST SEQUENCE
	CALL	RLSTEP
	JP	CANCL1
;--------------
; TEST SEQUENCE
;--------------
;RLTEST	.DB	55H,01H,AAH,01H,00H,0FFH
RLTEST	.DB	0x55,0x01,0xAA,0x01,0x00,0xFF
;----------------
; RELAY SEQUENCER
;----------------
; SEQUENCES RELAYS ON RELAY BOARD
; USES TWO BYTES TO SPECIFY OUTPUT DATA AND DELAY TIME
; DELAY TIME BYTE ALSO DETERMINES IF SEQUENCE IS TO STOP
; OR REPEAT.
;  TABLE:
;  <BYTE1>,<BYTE2>
;  BYTE1 = DATA TO GO TO OUTPUT LATCH (USES PORT IO1)
;  BYTE2 = FF - REPEAT
;          00 - FINISHED
;  ENTRY : HL POINTS TO TABLE OF OUTPUT DATA
;  EXIT : NONE MODIFIED
;
RLSTEP	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF DATA
RELSR1	LD	A,(DE)
	LD	C,A	;GET OUTPUT DATA
	INC	DE
	LD	A,(DE)	;GET TIME DELAY
	CP	0
	JR	Z,RELSR4	;END OF SEQUENCE
	CP	255
	JR	Z,RELSR3	;REPEAT SEQUENCE
	LD	B,A
	LD	A,C
	OUT	(IO1),A
	INC	DE
RELSR2	CALL	DELONE	;1 SEC DELAY
	DJNZ	RELSR2	;MORE SECONDS TO GO
	JP	RELSR1
;
; REPEAT
;
RELSR3	POP	DE	;GET START ADDRESS
	PUSH	DE	;SAVE FOR LATER
	JP	RELSR1
;
; FINISHED
;
RELSR4	LD	A,00H
	OUT	(IO1),A	;CLEAR OUTPUT REG
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
;
; ENTRY : NONE
; EXIT : FLAG REGISTER MODIFIED
;
DELONE	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	HL,0870H
DELON1	LD	B,92H
DELON2	DJNZ	DELON2	;INNER LOOP
	SBC	HL,DE
	JP	NC,DELON1	;OUTER LOOP
	POP	HL
	POP	DE
	POP	BC
	RET
;--------------------------
; FUNCTION E - KALEIDOSCOPE
;--------------------------
SCOPE	CALL	BEEP
	CALL	KEYREL
	CALL	RAND	;GENERATE RANDOM
	EX	DE,HL
	LD	HL,SYSTEM	;NUMBER AND SET UP
	LD	A,E	;THE FIRST QUADRANT
	CALL	SEED	;WITH A RANDOM BIT
	LD	A,D	;PATTERN
	CALL	SEED
;
; GENERATE MIRROR IMAGES
;
SCOPE2	LD	B,04H
	LD	HL,SYSTEM
	LD	DE,SYSTEM+7
SCOPE3	LD	A,(HL)	;MIRROR THE FIRST
	LD	(DE),A	;QUADRANT INTO
	INC	HL	;THE FOURTH
	DEC	DE	;QUADRANT
	DJNZ	SCOPE3
;
; MIRROR ACROSS CENTRE OF DISPLAY
;
	LD	B,8	;MIRROR THE FIRST
	LD	HL,SYSTEM	;AND FOURTH QUADRANT
	LD	A,(HL)	;ACROSS THE CENTRE
	AND	0FH	;OF THE DISPLAY
	LD	(HL),A	;INTO THE SECOND
SCOPE4	BIT	0,(HL)	;AND THIRD QUADRANTS.
	JP	Z,SCOPE5	;CHECKING IF THE
	SET	7,(HL)	;BITS IN THE LSN ARE
SCOPE5	BIT	1,(HL)	;SET, AND SETTING THE
	JP	Z,SCOPE6	;CORRESPONDING
	SET	6,(HL)	;MIRROR IMAGE
SCOPE6	BIT	2,(HL)	;BIT IN THE MSN
	JP	Z,SCOPE7	;IF THEY ARE.
	SET	5,(HL)	;DO THIS FOR
SCOPE7	BIT	3,(HL)	;THE EIGHT ROWS
	JP	Z,SCOPE8	;OF DATA BYTES
	SET	4,(HL)	;IN THE DISPLAY
SCOPE8	INC	HL
	DJNZ	SCOPE4	;MORE ROWS TO DO
;
; DISPLAY RANDOM BIT PATTERN
;
	LD	DE,0001H	;SCAN THE DISPLAY
	CALL	RAND	;A RANDOM
	LD	A,H	;TIME
	AND	7	;NOT GREATER THAN
	OR	1	;NOT LESS THAN
	LD	H,A
SCOPE9	PUSH	HL
	LD	HL,SYSTEM
	CALL	SKATE	;SCAN 8X8
	POP	HL
	SBC	HL,DE
	JP	NZ,SCOPE9
;
; MANIPULATE BITS FOR NEXT IMAGE
;
SCOPEA	LD	HL,SYSTEM
	LD	A,5
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 5 TO FIRST LSN
	INC	HL
	LD	A,03H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 3 TO SECOND LSN
	INC	HL
	LD	A,01H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 1 TO THIRD LSN
	INC	HL
	LD	A,07H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 15 TO FOURTH LSN
	JP	SCOPE2	;MIRROR BIT PATTERN
;
; SEED THE FIRST QUADRANT WITH RANDOM BITS
;
SEED	LD	B,A	;PUT THE
	AND	0FH	;RANDOM NUMBER
	LD	(HL),A	;INTO THE
	INC	HL	;FIRST QUADRANT
	LD	A,B	;OF THE
	AND	240	;DISPLAY
	RRA
	RRA
	RRA
	RRA
	LD	(HL),A
	INC	HL
	RET
;-----------------
; SCAN 8X8 DISPLAY
;-----------------
;PUT THE 8 RAM LOCATIONS POINTED TO
;BY HL ON THE 8X8 DISPLAY,LOW BYTE
;ON TOP ROW.
;  ROUTINE PERIOD IS 500uS
;  PULSE WIDTH 15uS  GIVES 3% DUTY
;
; ENTRY : HL = ADDRESS OF 8X8 BUFFER
;	EXIT : NO REGISTERS MODIFIED
;
SKATE	PUSH	AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	C,80H
SKATE1	LD	A,(HL)
	OUT	(IO0),A	;OUTPUT X
	LD	A,C
	OUT	(IO2),A	;OUTPUT Y
	LD	B,02H
SKATE2	DJNZ	SKATE2	;ON TIME DELAY
	XOR	A
	OUT	(IO0),A
	OUT	(IO2),A	;CLEAR DISPLAY LATCHES
	LD	B,08H
SKATE3	DJNZ	SKATE3	;OFF TIME DELAY
	INC	HL
	RRC	C
	JR	NC,SKATE1	;MORE TO OUTPUT
	POP	HL
	POP	BC
	POP	AF
	RET
;----------------------------
; FUNCTION F - CLOCK CALENDAR
;----------------------------
TIME	CALL	BEEP
	CALL	KEYREL	;WAIT FOR KEY RELEASE
	LD	IX,SYSTEM	;USE IX FOR TEMP VARIABLES
	LD	A,(ONTIM)
	LD	(IX+0),A	;SAVE DISPLAY SCAN DELAY
	LD	A,60H
	LD	(ONTIM),A	;USE NEW DELAY
	LD	(IX+1),A	;START IN TIME MODE
;
; DISPLAY TIME,CHECK FOR KEY
;
TIME1	CALL	RWATCH	;READ THE CLOCK/CALENDAR
	CALL	UPDBUF	;UPDATE THE DISPLAY BUFFER
	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A
	JR	Z,TIME1	;NO KEY KEEP LOOKING
	AND	1FH
	LD	HL,TIMKEY
	CALL	MENU
	JR	TIME1

TIMKEY	.DB	4
	.DB	10H,11H,12H,13H
	.DW	CLKEXT,SETCLK,CALKEY,CALKEY
;--------------------
; EXIT CLOCK CALENDAR
;--------------------
CLKEXT	POP	HL	;REMOVE RETURN
	LD	A,(IX+0)
	LD	(ONTIM),A	;RESTORE DELAY TIME
	JP	CANCEL
;--------------------
; TOGGLE DISPLAY MODE
;--------------------
CALKEY	CALL	BEEP
	CALL	KEYREL
	LD	A,(IX+1)
	XOR	80H	;TOGGLE DISPLAY
	LD	(IX+1),A
	RET
;----------------------
; UPDATE DISPLAY BUFFER
;----------------------
UPDBUF	BIT	7,(IX+1)	;WHICH DISPLAY MODE?
	JR	NZ,UPDBF2	;CALENDAR DISPLAY
;
; TIME DISPLAY
;
UPDBF1	LD	A,(SWREG1)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF),HL	;SHOW SECONDS (0-59)
	LD	A,(SWREG2)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF+2),HL	;SHOW MINUTES (0-59)
	LD	A,(SWREG3)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF+4),HL	;SHOW HOURS (0-23)
	RET
;
; CALENDAR DISPLAY
;
UPDBF2	LD	A,(SWREG7)
	CALL	CONBYT
	LD	(DISBUF),HL	;SHOW YEAR (0-99)
;
; CHECK MODE FOR DD/MM/YY OR MM/DD/YY
;
	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,UPDBF3	;MM/DD/YY MODE
;
; DD/MM/YY MODE
;
	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW DATE (1-31)
	JR	UPDBF4
;
; MM/DD/YY MODE
;
UPDBF3	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW DATE (1-31)
;
; SHOW DAY
;
UPDBF4	LD	A,(SWREG4)	;GET DAY REG
	AND	07H
	JR	Z,UPDBF5	;ZERO IS ILLEGAL
	CP	07H
	JR	Z,UPDBF5	;DON'T SHOW SATURDAY
	CPL	;WORK OUT
	SUB	01H	;WHICH DECIMAL POINT
	AND	07H	;TO LIGHT
	LD	HL,DISBUF	;ADDING THE DAY
	LD	B,00H	;TO A DISPLAY
	LD	C,A	;BUFFER INDEX
	ADD	HL,BC	;AND SETTING THE
	SET	7,(HL)	;DECIMAL POINT
UPDBF5	RET	;IN THAT DISPLAY
;--------------
; SET TIME/DATE
;--------------
SETCLK	CALL	BEEP
	CALL	KEYREL
;
; EDIT THE DISPLAY BUFFER
;
SETCK1	CALL	UPDBUF  ;UPDATE DISPLAY BUFFER
	CALL	SKEYIN
	CALL	KEYREL
	CP	10H	;FN KEY EXITS (NO CHANGE)
	RET	Z
	CP	11H	;AD KEY SETS CLOCK/CALENDAR
	JR	Z,SETCK8
	CP	12H
	JR	Z,SETCK4	;PLUS KEY
	CP	13H
	JR	Z,SETCK6	;MINUS KEY
	CP	0AH	;NO A-F KEYS
	JR	NC,SETCK1
;
; IS IT SET CLOCK OR SET CALENDAR?
;
	BIT	7,(IX+1)
	JR	NZ,SETCK2
;
; SET CLOCK DISPLAY
;
	LD	HL,SWREG1
	RLD	;MOVE THE NEW KEY
	INC	HL	;INTO THE CLOCK BUFFER
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR DISPLAY
;
SETCK2	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,SETCK3	;MM/DD/YY MODE
;
; SET CALENDAR AS DD/MM/YY
;
	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	RLD
	DEC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR AS MM/DD/YY
;
SETCK3	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	DEC	HL
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; INC DAY
;
SETCK4	BIT	7,(IX+1)
	JR	Z,SETCK1
	LD	A,(SWREG4)
	CP	07H	;IS THE DAY SUNDAY?
	JR	NZ,SETCK5
	LD	A,00H	;SET MONDAY
SETCK5	INC	A	;DAY=DAY+1
	LD	(SWREG4),A
	JP	SETCK1
;
; DEC DAY
;
SETCK6	BIT	7,(IX+1)
	JP	Z,SETCK1
	LD	A,(SWREG4)
	CP	01H	;IS THE DAY MONDAY?
	JR	NZ,SETCK7
	LD	A,08H	;SET SUNDAY
SETCK7	DEC	A	;DAY=DAY-1
	LD	(SWREG4),A
	JP	SETCK1
;
; SET THE CLOCK/CALENDAR WITH NEW DATA
;
SETCK8	CALL	BEEP
	CALL	KEYREL
	LD	A,(SWREG3)
	AND	3FH	;24 HOUR MODE
	LD	(SWREG3),A
	LD	A,(SWREG4)
	AND	07H	;OSC ON,RST ENABLED
	LD	(SWREG4),A
	CALL	WWATCH	;WRITE CHANGES
	RET
;---------------------
; READ FROM SMARTWATCH
;---------------------
; READS DATA FROM SMARTWATCH, USES LOOKUP TABLE TO
; WRITE 64 BIT ACCESS CODE TO ENABLE THE SMARTWATCH.
; READS ALL DATA INTO REGISTERS AS RAM CANNOT BE READ
; OR WRITTEN TO WHILE WATCH IS ENABLED.
;
;  ENTRY : NONE
;  EXIT  : NO WORKING REGISTERS MODIFIED
;          (ALTERNATE SET MODIFIED)
;  CONTENTS OF SMARTWATCH WRITTEN TO SWREG0 - SWREG7
;
;
; ENABLE SMARTWATCH
;
RWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	HL,PATERN	;WRITE D0 OF ALL THE BYTES
	LD	B,64	;IN THE TABLE TO THE RAM TO
RWACH1	LD	A,(HL)	;ENABLE THE SMARTWATCH
	LD	(DALLAS),A
	INC	HL
	DJNZ	RWACH1
;
; READ DATA FROM WATCH
;
	LD	B,32
RWACH2	LD	A,(DALLAS)	;SHIFT THE FIRST 32 BITS
	SRL	A	;INTO THE 16 BIT REGISTERS
	RR	D	;DE AND HL
	RR	E	;THEN EXCHANGE THEM WITH
	RR	H	;THE ALTERNATE PAIR
	RR	L
	DJNZ	RWACH2
	EXX
	LD	B,32
RWACH3	LD	A,(DALLAS)	;NOW SHIFT THE LAST 32 BITS
	SRL	A	;INTO THE SAME 16 BIT REGISTERS
	RR	D
	RR	E
	RR	H
	RR	L
	DJNZ	RWACH3
;
; SAVE IN WATCH REGISTERS
;
	LD	(SWREG4),HL	;SMARTWATCH READ IS COMPLETE
	LD	(SWREG6),DE	;GET THE DATA
	EXX
	LD	(SWREG0),HL
	LD	(SWREG2),DE
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
; SMARTWATCH ACCESS PATTERN
;
PATERN	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
;--------------------
; WRITE TO SMARTWATCH
;--------------------
;
; WRITE DATA TO SMARTWATCH BY FIRST ACCESSING
; IT USING BIT MANIPULATION.
; DATA IS WRITTEN BY FIRSTLY PUTTING ALL 64 BITS
; INTO REGISTERS AS RAM CANNOT BE ACCESSED ONCE THE
; SMARTWATCH IS ENABLED.
;
; ENTRY : NONE
; THE DATA TO WRITE TO THE SMARTWATCH
; MUST BE IN SWREG0 - SWREG7
;  EXIT : NO WORKING REGISTERS MODIFIED
;  (ALTERNATE SET MODIFIED)
; GET DATA TO WRITE TO WATCH
;
WWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(SWREG4)	;SET UP THE
	LD	DE,(SWREG6)	;16 BIT REGISTERS
	EXX
	LD	HL,(SWREG0)	;WITH THE DATA TO BE
	LD	DE,(SWREG2)	;WRITTEN TO THE SMARTWATCH
;
; WRITE 64 BIT ACCESS CODE TO ENABLE SMARTWATCH
;
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	A,0C5H
	LD	C,80H	;NUMBER OF BYTES
WWACH1	LD	B,80H	;NUMBER OF BITS
WWACH2	LD	(DALLAS),A	;WRITE TO RAM
	RRC	A
	SRL	B
	JR	NC,WWACH2	;MORE BITS
	SRL	C
	JR	C,WWACH4	;NO MORE BYTES
	BIT	0,A
	JR	NZ,WWACH3
	RRC	A
	RRC	A
	RRC	A
	RRC	A
	JR	WWACH1
WWACH3	CPL
	JR	WWACH1
;
; WRITE DATA TO WATCH
;
WWACH4	LD	B,32	;SHIFT THE FIRST 32 BITS
WWACH5	SRL	D	;OUT OF THE 16 BIT REGISTERS
	RR	E	;ONTO D0 AND INTO
	RR	H	;THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH5
	EXX	;RESTORE REGISTERS
	LD	B,32	;GET THE OTHER 32 BITS FROM
WWACH6	SRL	D	;THE ALTERNATE REGISTER SET
	RR	E	;AND SHIFT THEM ONTO D0
	RR	H	;AND INTO THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH6
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
; USES SMARTWATCH TO DELAY FOR 1 SECOND
; BY WAITING FOR SECONDS REGISTER TO ROLLOVER
;
; FIRST READ GETS A REFERENCE, SUBSEQUENT READS
; WAIT UNTIL THE SECONDS COUNTER NO LONGER
; READS THE SAME AS THE REFERENCE VALUE,
; THEN THE ROUTINE RETURNS
;
; ENTRY : NONE
; EXIT : NONE MODIFIED
;
ONESEC	PUSH	AF
	PUSH	BC
	CALL	RWATCH	;READ WATCH
	LD	A,(SWREG1)
	LD	B,A	;SAVE REF COUNT
ONESC1	CALL	RWATCH
	LD	A,(SWREG1)
	CP	B	;SAME AS REF?
	JP	Z,ONESC1	;YES SO WAIT AGAIN
	POP	BC
	POP	AF
	RET
    
;---------------
; SERIAL MONITOR
;---------------

;------------
; ASCII CODES
;------------
ESC    EQU   0x1B 
CR     EQU   0x0D
LF     EQU   0x0A

           
SCBUG  LD    A,0x40
       OUT   (SCAN),A    ;TURN OFF THE DISPLAY MAKE SERIAL TX HIGH
;
; START UP THE MONITOR
;          
COLD   LD    (ISTACK),SP ;SAVE STACK POINTER
       LD    HL,SSSTEP
       LD    (RST38),HL ;HIJACK THE SINGLE STEPPER
       CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
       LD    HL,TXDATA
       LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
       LD    HL,RXDATA
       LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
       LD    HL,INITSZ  ;VT100 TERMINAL COMMANDS FOR CLEAR SCREEN,CURSOR HOME
       CALL  SNDMSG     ;INITIALISE THE TERMINAL
       LD    HL,SIGNON
       CALL  SNDMSG     ;SEND THE SIGNON
;
; DISPLAY THE PROMPT AND WAIT FOR COMMANDS
;
START2 LD    A,'>'
       CALL  OUTCH       ;DISPLAY THE PROMPT
START3 CALL  INCH        ;GET A CHARACTER FROM THE CONSOLE
;
; IF THE COMMAND IS NOT IN THE COMMAND LIST REJECT IT
;
       LD    HL,MONMENU 
       LD    B,(HL) ;NUMBER OF COMMANDS
       INC   HL
START4 CP    A,(HL)      ;IN THE LIST?
       JR    Z,START5    ;OK DO IT
       INC   HL
       DJNZ  START4      ;KEEP LOOKING
       JR    START3
START5 CALL  OUTCH       ;ECHO 
       LD    HL,MONMENU  ;USE THE MENU HANDLER 
       CALL  MENU        ;KEY IN A, EXECUTE MENU
;      
; THE MENU FUNCTION CALL LEAVES THE RETURN ADDRESS OF THE MENU CALL
; ON THE STACK SO ANY CALLED SUBROUTINES CAN COME BACK HERE WITH A RET.
;           
WARM   CALL  TXCRLF     ;START ON A NEW LINE
       JP    START2
;
; SCBUG MONITOR COMMANDS
;
MONMENU     .DB 7
            .DB 'D','H','T','M','G','I','X'

            .DW DSPLAY,HELP,SSTOGL,MODIFY
            .DW GOJUMP,INTHEX,EXIT
;-----------------------------
; GET A BYTE FROM THE TERMINAL
;-----------------------------
GETCHR CALL  INCH
       CP    ESC
       JR    Z,GETOUT
       LD    B,A                ;SAVE TO ECHO      
       CALL  ASC2HEX
       JR    NC,GETCHR          ;REJECT NON HEX CHARS    
       LD    HL,DATA
       LD    (HL),A 
       LD    A,B         
       CALL  OUTCH             ;ECHO VALID HEX
       
GETNYB CALL  INCH
       CP    ESC
       JR    Z,GETOUT
       LD    B,A               ;SAVE TO ECHO
       CALL  ASC2HEX
       JR    NC,GETNYB         ;REJECT NON HEX CHARS
       RLD
       LD    A,B
       CALL  OUTCH             ;ECHO VALID HEX
       LD    A,(HL)
       CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
       CCF                    ;AND THEN COMPLEMENTING IT
       RET   
GETOUT SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
       RET
;---------------
; OUTPUT A SPACE
;---------------
OUTSP  LD    A,20H
       CALL  OUTCH
       RET
;-------------      
; OUTPUT CRLF
;------------
TXCRLF LD   A,CR
       CALL OUTCH   
       LD   A,LF
;-----------------------------------
; OUTPUT A CHARACTER TO THE TERMINAL
;-----------------------------------       
OUTCH  LD   IX,(PUTCH)
       JP   (IX)
;------------------------------------
; INPUT A CHARACTER FROM THE TERMINAL
;------------------------------------
INCH  LD   IX,(GETCH)
      JP   (IX)
;------------------------------
; GO <ADDR>
; TRANSFERS EXECUTION TO <ADDR>
;------------------------------
GOJUMP CALL  OUTSP       
       CALL  GETCHR      ;GET ADDRESS HIGH BYTE
       RET   C
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR      ;GET ADDRESS LOW BYTE
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR A CR OR ESC
;       
GOJMP1 CALL  INCH
       CP    ESC         ;ESC KEY?
       RET   Z
       CP    CR
       JR    NZ,GOJMP1
       CALL  TXCRLF
       POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
       LD    HL,(ADDR)
       JP    (HL)        ;GOOD LUCK WITH THAT!
;---------------------
; DISPLAY COMMAND HELP
;---------------------
HELP   LD   HL,COMANDS
       CALL SNDMSG
       LD   HL,COMANDS1
       CALL SNDMSG
       RET
;-----------------------------------------------
; T COMMAND TOGGLE SINGLE STEPPER (IF INSTALLED)
;-----------------------------------------------
; CAN'T TELL IF THE SINGLE STEPPER IS ON OR OFF
; SO WE WILL JUST TOGGLE THE FLIP FLOP.
;
SSTOGL LD    HL,TOGGLE
       CALL  SNDMSG  
       OUT   (IO7),A               ;TOGGLE
       RET
;----------------------------
; M DISPLAY AND MODIFY MEMORY
;----------------------------
MODIFY CALL  OUTSP
;
;GET THE ADDRESS        
;
       CALL  GETCHR 
       RET   C        
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; DISPLAY ON A NEW LINE
;       
MDIFY1 CALL  TXCRLF       
       LD    DE,(ADDR)    
       LD    HL,MSGBUF   
       CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
       LD    HL,MSGBUF
       CALL  WRDOUT      ;OUTPUT THE ADDRESS
       CALL  OUTSP    
;      
;GET THE DATA AT THE ADDRESS        
;
        LD   HL,(ADDR)       
        LD   A,(HL)
;
; DISPLAY THE DATA
;        
       LD    HL,MSGBUF
       CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
       LD    HL,MSGBUF
       CALL  BYTOUT      ;OUTPUT THE BYTE
       CALL  OUTSP
;
; GET NEW DATA,EXIT OR CONTINUE
;
       CALL  GETCHR
       RET   C
       LD    B,A         ;SAVE IT FOR LATER
       LD    HL,(ADDR)
       LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
       LD    A,B
       CP    (HL)
       JR    Z,MDIFY2
       LD    A,'?'
       CALL  OUTCH       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
;
; INCREMENT THE ADDRESS
;
MDIFY2 INC   HL
       LD    (ADDR),HL
       JP    MDIFY1      
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------       
INTHEX LD    HL,TXFILE
       CALL  SNDMSG      ;SEND FILE
       CALL  INTELH
       JR    NZ,ITHEX1      
       LD    HL,FILEOK
       CALL  SNDMSG      ;GOT FILE OK
       RET
ITHEX1 LD    HL,CSUMERR
       CALL  SNDMSG      ;CHECKSUM ERROR
       RET    
;------------------------
; EXIT BACK TO SC MONITOR
;------------------------       
EXIT   LD    HL,BYE
       CALL  SNDMSG       
       JP    MAIN      ;STACK IS RESET TO TOP OF RAM IN MAIN             
;----------------------------------------
; CONVERT ASCII CHARACTER INTO HEX NYBBLE
;----------------------------------------
; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
; ENTRY OTHER THAN HEXADECIMAL KEYS
;
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : CARRY =  1
;          A= HEX 0-F IN LSN    
;      : CARRY = 0
;          A= OUT OF RANGE CHARACTER & 0x7F
; A AND F REGISTERS MODIFIED
;
ASC2HEX AND   0x7F        ;STRIP OUT PARITY
       CP    0x30
       JR    C,AC2HEX3    ;LESS THAN 0
       CP    0x3A
       JR    NC,AC2HEX2   ;MORE THAN 9
AC2HEX1 SCF               ;SET THE CARRY - IS HEX
       RET
;     
AC2HEX2 CP    0x41
       JR    C,AC2HEX3    ;LESS THAN A
       CP    0x47
       JR    NC,AC2HEX3   ;MORE THAN F
       SUB   0x07        ;CONVERT TO NYBBLE
       JR    AC2HEX1  
AC2HEX3 AND   0xFF        ;RESET THE CARRY - NOT HEX
       RET
;--------------------------
; D DISPLAY MEMORY LOCATION
;--------------------------
DSPLAY CALL  OUTSP       ;A SPACE
       CALL  GETCHR
       RET   C         
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR CR OR ESC
;
DPLAY1 CALL  INCH
       CP    ESC
       RET   Z
       CP    CR
       JR    NZ,DPLAY1          
       CALL  TXCRLF      ;NEWLINE
;
; DISPLAY THE LINE
;
DPLAY2 CALL  DPLINE
       LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
;
; DISPLAY MORE LINES OR EXIT
;       
DPLAY3 CALL  INCH
       JR    C,DPLAY3   
       CP    0x20        ;SPACE DISPLAYS THE NEXT LINE
       JR    Z,DPLAY2
       CP    ESC         ;ESC EXITS
       JR    NZ,DPLAY3     
       RET   
;-------------------------
; DISPLAY A LINE OF MEMORY
;-------------------------      
DPLINE LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
       LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
;
; DISPLAY THE ADDRESS
;         
       CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
       CALL  SPCBUF        
;
; DISPLAY 16 BYTES
;
       LD    B,16
DLINE1 LD    A,(DE)
       CALL  BYTASC
       CALL  SPCBUF
       INC   DE        
       DJNZ  DLINE1
       CALL  SPCBUF
;
; NOW DISPLAY THE ASCII CHARACTER
; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
; BE DIFFERENT BETWEEN THE TWO PASSES!
;
       LD    DE,(ADDR)    
       LD    B,16
DLINE2 LD    A,(DE)   
       CP    0x20
       JR    C,DOT
       CP    0x7F
       JR    NC,DOT
       JP    NDOT
DOT    LD    A,'.'
NDOT   CALL  INBUF
       INC   DE       
       DJNZ  DLINE2
;         
;TERMINATE AND DISPLAY STRING
;       
       CALL  BCRLF
       LD    A,0x00
       LD    (HL),A
       LD    HL,MSGBUF
       CALL  SNDMSG
       RET
;
; PUT A SPACE IN THE BUFFER
;
SPCBUF LD    A,0x20
INBUF  LD    (HL),A
       INC   HL
       RET
;
; PUT A CR LF IN THE BUFFER
;        
BCRLF  LD    A,CR  
       CALL  INBUF
       LD    A,LF
       CALL  INBUF
       RET
;----------------------     
; SEND ASCII HEX VALUES        
;----------------------
;
; OUTPUT THE 4 BYTE, WRDOUT
; THE 2 BYTE, BYTOUT
; OR THE SINGLE BYTE, NYBOUT
; ASCII STRING AT HL TO THE SERIAL PORT
;
WRDOUT CALL  BYTOUT
BYTOUT CALL  NYBOUT
NYBOUT LD    A,(HL)
       CALL  OUTCH
       INC   HL
       RET       
;----------------
;CONVERT TO ASCII 
;----------------
;
; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
;
;         ENTRY :  A = BINARY TO CONVERT
;                  HL = CHARACTER BUFFER ADDRESS   
;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
;   
;        MODIFIES : DE

WRDASC LD    A,D         ;CONVERT AND
       CALL  BYTASC      ;OUTPUT D
       LD    A,E         ;THEN E
;
;CONVERT A BYTE TO ASCII 
;
BYTASC PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
       RRCA              ;SHIFT HIGH NYBBLE ACROSS
       RRCA
       RRCA
       RRCA
       CALL NYBASC       ;CALL NYBBLE CONVERTER 
       POP AF            ;RESTORE LOW NYBBLE
;           
; CONVERT A NYBBLE TO ASCII
;
NYBASC AND   0FH         ;MASK OFF HIGH NYBBLE 
       ADD   A,90H       ;CONVERT TO
       DAA               ;ASCII
       ADC   A,40H
       DAA
;            
; SAVE IN STRING
;
INSBUF LD    (HL),A
       INC   HL 
       RET 
;------------------------------------------------------
; CONVERT A BYTE INTO A STRING OF ASCII ONES AND ZEROES
;------------------------------------------------------
;       
;        DESCRIPTION : CONVERTS A BYTE, STARTING AT BIT 7,
;                      INTO A STRING OF ASCII
;                      ONES AND ZEROES.
;
;           ENTRY :  A = BINARY TO CONVERT
;                   HL = CHARACTER BUFFER ADDRESS   
;           EXIT :  HL = POINTS TO LAST CHARACTER+1
;   
;        MODIFIES : NONE
;
;
BITASC PUSH  BC
       LD    B,08H       ;LOOK AT ALL 8 BITS
BTASC1 BIT   7,A         ;A 1 OR A 0?
       JR    NZ,BTASC3
       LD    C,30H       ;IT'S A ZERO
BTASC2 LD    (HL),C
       JR    BTASC4
            
BTASC3 LD    C,31H       ;IT'S A ONE
       LD    (HL),C
            
BTASC4 INC   HL
       RLA
       DJNZ  BTASC1      ;NEXT BIT
       POP   BC
       RET
;-----------------------------------------
; SEND AN ASCII STRING OUT THE SERIAL PORT
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. OUT THE SERIAL PORT
;
;      ENTRY : HL = POINTER TO 0x00 TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDMSG LD    B,128         ;128 CHARS MAX
SDMSG1 LD    A,(HL)        ;GET THE CHAR
       CP    0x00          ;ZERO TERMINATOR?
       JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
       CALL  OUTCH         ;TRANSMIT THE CHAR
       INC   HL
       DJNZ  SDMSG1        ;128 CHARS MAX!    
SDMSG2 RET
;----------------------
; SERIAL SINGLE STEPPER
;----------------------
SSSTEP POP   HL          ;GET HL BACK
       PUSH  AF          ;SAVE AF FOR LATER  
       LD    (HL_REG),HL
       LD    (DE_REG),DE
       LD    (BC_REG),BC
       LD    (IX_REG),IX
       LD    (IY_REG),IY ;SAVE REGISTERS
       POP   HL          ;GET AF BACK
       LD    (AF_REG),HL ;SAVE AF
       POP   HL          ;GET PC RETURN ADDRESS
       LD    (PC_REG),HL ;SAVE PC
       LD    (SP_REG),SP ;SAVE STACK POINTER
;            
;DISPLAY THE REGISTERS HEADING          
;          
       LD    HL,REGS
       CALL  SNDMSG
;
; DISPLAY THE REGISTERS
;            
       LD	 B,08H
       LD    HL,MSGBUF
       LD    IX,PC_REG
SSTEP1 LD    A,(IX+1)
       CALL  BYTASC
       LD    A,(IX+0)
       CALL  BYTASC
       INC   IX
       INC   IX
       LD    A,' '
       LD    (HL),A
       INC   HL
       DJNZ  SSTEP1       
;
; DISPLAY THE FLAGS 
;          
       LD    A,(AF_REG)  ;GET THE FLAGS AND      
       CALL  BITASC      ;SHOW THEM AS BITS 

SZCRLF CALL  BCRLF
       LD    A,0x00
       LD    (HL),A      ;TERMINATE THE STRING
;        
; DISPLAY THE REGISTERS
;        
       LD    HL,MSGBUF
       CALL  SNDMSG
;
; SPACE KEY CONTINUES
;
SSTEP3 CALL  INCH
       JR    C,SSTEP3      
       CP    0x20        ;IS IT SPACE
       JR    Z,SSTEP4
       CP    ESC         ;ESC QUITS
       JR    NZ,SSTEP3
;       
; RETURN TO MONITOR
; 
       LD    SP,(ISTACK) ;RESTORE THE STACK POINTER
       EI                ;RE-ENABLE INTERRUPTS      
       JP    WARM        ;EXIT THE INTERRUPT ROUTINE
;
; RETURN TO PROGRAM
;
SSTEP4 LD    SP,(SP_REG) ;PUT STACK POINTER BACK
       LD    HL,(PC_REG) ;PUT RETURN
       PUSH  HL          ;ADDRESS BACK ON STACK
       LD    HL,(AF_REG)
       PUSH  HL          ;SAVE AF REG FOR LATER
       LD    IY,(IY_REG)
       LD    IX,(IX_REG)
       LD    BC,(BC_REG)
       LD    DE,(DE_REG) ;RESTORE REGISTERS
       POP   AF          ;RESTORE AF
       LD    HL,(HL_REG) ;RESTORE HL
       EI                ;RE-ENABLE INTERRUPTS
       RET               ;AND RETURN TO PROGRAM  
;
; STRING CONSTANTS
;
CRLF        .DB     CR,LF,0x00
SIGNON      .DB     "SCM 1.5 SERIAL MONITOR",CR,LF,"ACCEPTS ONLY UPPER CASE - H FOR COMMAND LIST",CR,LF,0x00
REGS        .DB     CR,LF,"PC   AF   BC   DE   HL   IX   IY   SP   SZ-H-VNC",CR,LF,0x00
TOGGLE      .DB     CR,LF,"SINGLE STEP TOGGLE",CR,LF,0x00
TXFILE      .DB     CR,LF,"SEND INTEL HEX FILE...",0x00
FILEOK      .DB     CR,LF,"FILE RECEIVED OK",CR,LF,0x00
CSUMERR     .DB     CR,LF,"CHECKSUM ERROR",CR,LF,0x00
BYE         .DB     CR,LF,"BYE...",CR,LF,0x00

COMANDS     .DB     CR,LF,"D AAAA    DISPLAY DATA AT ADDRESS AAAA"
            .DB     CR,LF,"T         TOGGLE SINGLE STEPPER"           
            .DB     CR,LF,"M AAAA    MODIFY ADDRESS AAAA",0x00
            
COMANDS1    .DB     CR,LF,"G AAAA    GO FROM AAAA"     
            .DB     CR,LF,"I         DOWNLOAD INTEL HEX"
            .DB     CR,LF,"X         EXIT"
            .DB     CR,LF,"H         THIS HELP MESSAGE",CR,LF,0x00
;
;VT100 TERMINAL COMMANDS FOR CLEAR SCREEN,CURSOR HOME
;
INITSZ      .DB     27,"[H",27,"[2J",0x00
	   END
