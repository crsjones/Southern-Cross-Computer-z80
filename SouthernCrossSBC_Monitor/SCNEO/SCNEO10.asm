;---------------------------------------------
; S O U T H E R N   C R O S S   N E O  (SCNEO)
;---------------------------------------------
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
;
; MUSIC AND SOUND CODE FROM
; TALKING ELECTRONICS TEC-1 MONITOR, MON-1
; BY JOHN HARDY AND KEN STONE
;
; 16 BIT MULTIPLY FROM ZAKS 'PROGRAMMING THE Z80'
;
; VERSION : 1.0  07/2023  INITIAL RELEASE
;
;IF DEFINED THE TARGET IS THE TEC-1F ELSE SC
;#DEFINE TEC-1F
; IF DEFINED USE THE 74C923 KEYBOARD ENCODER ELSE USE SOFTWARE SCANNING
#DEFINE 74C923
;
;---------------
; RAM MEMORY MAP
;---------------
BOTRAM	.EQU	2000H	;BOTTOM OF SRAM
TOPRAM	.EQU	3FFFH	;TOP OF SRAM
;
VARBLS	.EQU	TOPRAM-0FFH	;MONITOR VARIABLES
BUFFER	.EQU	VARBLS-0100H	;GENERAL PURPOSE BUFFER AREA
;
TXBUFFER	.EQU	BUFFER-0100H	;TRANSMIT BUFFER
RXBUFFER	.EQU	TXBUFFER-0100H	;RECEIVE BUFFER
;
ISTACK	.EQU	RXBUFFER	;INITIAL MONITOR STACK
;
RAMEND	.EQU	ISTACK-0400H	;END OF USER RAM
RAMSRT	.EQU	BOTRAM	;START OF USER RAM
;
; I/O PORT ADDRESSES
;
#IFDEF TEC-1F
;
; TEC-1 I/O ASSIGNMENTS
;
KEYBUF	.EQU	00H	;MM74C923N KEYBOARD ENCODER
SCAN	.EQU	01H	;DISPLAY SCAN LATCH
DISPLY	.EQU	02H	;DISPLAY LATCH
PORT3	.EQU	03H	;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
PORT4	.EQU	04H	;ST4 (8X8), LCD 'E' (DAT BOARD)
PORT5	.EQU	05H
PORT6	.EQU	06H
PORT7	.EQU	07H	;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
#ELSE
;
; SOUTHERN CROSS I/O ASSIGNMENTS
;
IO0	.EQU	80H	;IO PORT 0
IO1	.EQU	81H	;IO PORT 1
IO2	.EQU	82H	;IO PORT 2
IO3	.EQU	83H	;IO PORT 3
DISPLY	.EQU	84H	;DISPLAY LATCH
SCAN	.EQU	85H	;DISPLAY SCAN LATCH
KEYBUF	.EQU	86H	;KEYBOARD BUFFER
IO7	.EQU	87H	;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
#ENDIF
;
; 6850 ACIA REGISTERS
;
CONTROL	.EQU	4EH	;(WRITE) CONTROL REGISTER
STATUS	.EQU	4EH	;(READ) STATUS REGISTER
TDR	.EQU	4FH	;(WRITE) TRANSMIT DATA REGISTER
RDR	.EQU	4FH	;(READ) RECEIVE DATA REGISTER
;
; BIT BANG BAUD RATE CONSTANTS
;
B300	.EQU	0220H	;300 BAUD
B1200	.EQU	0080H	;1200 BAUD
B2400	.EQU	003FH	;2400 BAUD
B4800	.EQU	001BH	;4800 BAUD
B9600	.EQU	000BH	;9600 BAUD
;
; KEY CODES
;
KEYFN	.EQU	10H	;FN OR GO KEY
KEYAD	.EQU	11H	;ADDRESS KEY
KEYINC	.EQU	12H	;PLUS KEY
KEYDEC	.EQU	13H	;MINUS KEY
;-------------------------
; MONITOR GLOBAL VARIABLES
;-------------------------
;
	.ORG	VARBLS
;
;SERIAL MONITOR (SCBUG) VARIABLES
;
VARIDX	.BLOCK	16	;RESERVE SOME SPACE FOR INDEXED VARIABLES (SEE INTELH)
SPSAVE	.BLOCK	2	;SAVE THE STACK POINTER
ADDR	.BLOCK	2	;TEMP ADDRESS
DATA	.BLOCK	1	;TEMP DATA @ ADDRESS
;
FUNTBL	.BLOCK	 2	;FN TABLE ADDRESS
;
; DALLAS SMARTWATCH REGISTERS
;
CALMDE	.BLOCK	2	;CALENDAR MODE
SWREG0	.BLOCK	1	;10THS, 100THS
SWREG1	.BLOCK	1	;SECONDS
SWREG2	.BLOCK	1	;MINUTES
SWREG3	.BLOCK	1	;HOURS
SWREG4	.BLOCK	1	;DAY
SWREG5	.BLOCK	1	;DATE
SWREG6	.BLOCK	1	;MONTH
SWREG7	.BLOCK	1	;YEAR
;
BAUD	.BLOCK	2	;BIT BANG BAUD RATE
KEYTIM	.BLOCK	2	;BEEP DELAY
SPTEMP	.BLOCK	2	;TEMP SYSTEM CALL SP
;
; BLOCK FUNCTIONS
;
COUNT	.BLOCK	2	;NUMBER OF BYTES TO MOVE
BLKSRT	.BLOCK	2	;BLOCK START ADDRESS
BLKEND	.BLOCK	2	;BLOCK END ADDRESS
BLKDST	.BLOCK	2	;DESTINATION ADDRESS
;
FUNJMP	.BLOCK	2	;FN FN KEY JUMP ADDRESS
;
; DISPLAY SCAN REGISTERS
;
DISBUF	.BLOCK	6	;DISPLAY BUFFER
ONTIM	.BLOCK	1	;DISPLAY SCAN ON TIME
OFTIM	.BLOCK	1	;DISPLAY SCAN OFF TIME
;
; MONITOR VARIABLES
;
MODE	.BLOCK	2	;DISPLAY MODE
ADRESS	.BLOCK	2	;USER ADDRESS
KEYDEL	.BLOCK	2	;AUTO INCREMENT DELAY
;
; TEMPORARY REGISTER STORAGE
;
REGPNT	.BLOCK	2	;REGISTER POINTER
TMPPC	.BLOCK	2	;PROGRAM COUNTER
TMPAF	.BLOCK	2	;ACCUMULATOR,FLAG
TMPBC	.BLOCK	2	;BC REGISTER PAIR
TMPDE	.BLOCK	2	;DE REGISTER PAIR
TMPHL	.BLOCK	2	;HL REGISTER PAIR
TMPIX	.BLOCK	2	;INDEX REGISTER X
TMPIY	.BLOCK	2	;INDEX REGISTER Y
TMPSP	.BLOCK	2	;STACK POINTER
;
; RESTART JUMP TABLE AND HARWARE TEST
;
RST08	.BLOCK	2	;RESTART 08H JUMP
RST10	.BLOCK	2	;RESTART 10H JUMP
RST18	.BLOCK	2	;RESTART 18H JUMP
RST20	.BLOCK	2	;RESTART 20H JUMP
RST28	.BLOCK	2	;RESTART 28H JUMP
RST38	.BLOCK	2	;INT INTERRUPT JUMP
RST66	.BLOCK	2	;NMI INTERRUPT JUMP
RAMSUM	.BLOCK	1	;USER RAM CHECKSUM
DALLAS	.BLOCK	1	;RAM TEST LOCATION
SYSERR	.BLOCK	2	;SYSTEM CALL ERROR JUMP
;----------------------
; ACIA CIRCULAR BUFFERS
;----------------------
TXHEAD	.BLOCK	1	;LOW BYTE OF TRANSMIT HEAD POINTER
TXTAIL	.BLOCK	1	;LOW BYTE OF TRANSMIT TAIL POINTER
TXCOUNT	.BLOCK	1	;TRANSMIT CHAR COUNT
RXHEAD	.BLOCK	1	;LOW BYTE OF RECEIVE HEAD POINTER
RXTAIL	.BLOCK	1	;LOW BYTE OF RECEIVE TAIL POINTER
RXCOUNT	.BLOCK	1	;RECEIVE CHAR COUNT
;----------------
; RESTART VECTORS
;----------------
;
;  RESTART 00H - RST 0
;WHEN POWER IS APPLIED TO THE SOUTHERN CROSS
;THE Z80 STARTS EXECUTING INSTRUCTIONS FROM HERE
;
	.ORG	0000H
RSTVEC	JP	RESET
;
; RESTART 08H - RST 1
;
	.ORG	0008H
	PUSH	HL
	LD	HL,(RST08)
	JP	(HL)
;
; RESTART 10H - RST 2
;
	.ORG	0010H
	PUSH	HL
	LD	HL,(RST10)
	JP	(HL)
;
; RESTART 18H - RST 3
;
	.ORG	0018H
	PUSH	HL
	LD	HL,(RST18)
	JP	(HL)
;
; RESTART 20H - RST 4
;
	.ORG	0020H
	PUSH	HL
	LD	HL,(RST20)
	JP	(HL)
;
; RESTART 28H - RST 5
;
	.ORG	0028H
	PUSH	HL
	LD	HL,(RST28)
	JP	(HL)
;
; RESTART 30H - RST 6 - MONITOR ROUTINES ENTRY POINT
;
	.ORG	0030H
RST30	JP	SYSCALL
;
; RESTART 38H - RST 7     BREAKPOINT HANDLER
;IF INTERRUPTS ARE ENABLED,AND AN
;INT OCCURS- FURTHER INTERRUPTS
;ARE DISABLED, THE PROGRAM COUNTER
;IS PUSHED ONTO THE STACK, AND EXECUTION
;STARTS HERE
;
	.ORG	0038H
	EX	AF,AF'
	EXX
	LD	HL,(RST38)
	JP	(HL)
;
; RESTART 66H NMI VECTOR
; SAME AS ABOVE BUT NMI CANNOT BE DISABLED.
;
	.ORG	0066H
	PUSH	HL
	LD	HL,(RST66)
	JP	(HL)
NMIRET	RETN	;RETURN FROM NMI
;--------------------
; SYSTEM CALL HANDLER
;--------------------
;CALLS TO BASIC I/O AND OTHER ROUTINES
;WITHIN THE MONITOR HAVE BEEN ASSIGNED
;SYSTEM CALL NUMBERS TO AVOID RE-WRITING
;USER SOFTWARE IF MONITOR ABSOLUTE ADDRESSES
;CHANGE IN SUBSEQUENT MONITORS
;
;ENTRY : C = CALL NUMBER
;SEE ROUTINES FOR ENTRY AND EXIT
;PARAMETERS
;
SYSCALL	DEC	SP
	DEC	SP	;LEAVE SPACE FOR SYSCALL
	LD	(SPTEMP),SP	;POINTS TO SYSCALL LO
	PUSH	AF
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	LD	A,C	;GET CALL NUMBER
	AND	127	;ENSURE IN LIMITS
	SLA	A	;MULTIPLY BY TWO
	LD	H,1	;LOAD JUMP TABLE HIGH BYTE
	LD	L,A	;LOAD INDEX
	LD	A,(HL)
	INC	HL
	LD	D,(HL)	;GET JUMP ADDRESS
	LD	HL,(SPTEMP)	;POINT TO SYSCALL LO
	LD	(HL),A	;PUT SYSCALL LO ON STACK
	INC	HL
	LD	A,D
	LD	(HL),A	;PUT SYSCALL HI ON STACK
	POP	HL
	POP	DE
	POP	AF	;RESTORE REGISTERS
	RET		;JUMPS TO SYSTEM CALL
;
; ERROR TRAP
; HALT THE MACHINE UNTIL RESET OR INTERRUPT
TRAP	LD	HL,(SYSERR)
	JP	(HL)
;
STOP	HALT
;-----------------------
; SYSTEM CALL JUMP TABLE
;-----------------------
	.ORG	0100H
SYSJMP	.DW	MAIN,VERS,DISADD,DISBYT,CLRBUF,SCAND,CONBYT,CONVHI
	.DW CONVLO,SKEYIN,SKEYRL,KEYIN,KEYREL,MENU,CHKSUM,MUL16
	.DW RAND,INDEXB,INDEXW,MUSIC,TONE,BEEP,SKATE,TXBUF
	.DW WAITC,ASCHEX,WWATCH,RWATCH,ONESEC,RLSTEP,DELONE,SCANKEY
	
	.DW INTELH,SPLIT,SNDMSG,BITASC,WRDASC,BYTASC,NYBASC,PCBTYP
	.DW PRNTSZ,KBDTYP,UPDATE,VARRAM,SERINIT,SCBUG,ANYCHR,RXBUF
	.DW	MONNAME,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
	.DW	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP
;------------------------------
; POWER UP RESET / MANUAL RESET
;------------------------------
	.ORG	0200H
;
; WAIT FOR SMART SOCKET
; TO RECOVER FROM POWER DOWN
;
RESET	LD	A,55H
	LD	(DALLAS),A	;WRITE TO RAM
	XOR	A
	OUT	(DISPLY),A	;WRITE NOTHING TO
	OUT	(SCAN),A	;ON BOARD I/O
	IN	A,(KEYBUF)	;TO HELP DEBUGGING
	LD	A,(DALLAS)	;READ FROM RAM
	CP	55H	;IS IT READY?
	JP	NZ,RESET	;KEEP TRYING
;
; LOAD STACK POINTER
;
RESET1	LD	SP,ISTACK	;INITIALISE MONITOR STACK POINTER
	IM	1	;SET INTERRUPT MODE 1 - USE THE AUTOMATED INTERRUPT
;
; SET UP RESTART VECTORS
;
	LD	HL,RESET1
	LD	(RST08),HL
	LD	(RST10),HL
	LD	(RST18),HL
	LD	(RST20),HL
	LD	HL,NMIRET
	LD	(RST66),HL	;NMI INTERRUPT
	LD	HL,SSTEP	;SOFTWARE DEBUGGER
	LD	(RST28),HL	;USE RST 28H AS THE SOFTWARE DEBUGGER
	LD	HL,STOP
	LD	(SYSERR),HL	;INVALID SYSTEM CALL ERROR
;
	CALL	SERRST	;RESET THE 6850 ACIA
	CALL	SERVEC	;SET UP THE INTERRUPT VECTOR
;
; PERFORM CHECKSUM ON USER RAM
;
	LD	HL,RAMSRT	;START OF USER RAM
	LD	DE,RAMEND	;END OF USER RAM
	CALL	CHKSUM
	LD	(RAMSUM),A	;RAM CHECKSUM
;
; SET UP DEFAULT VARIABLES
;
	LD	HL,FUNLST
	LD	(FUNTBL),HL	;FUNCTION KEY TABLE
;
; PRESS THE FUNCTION KEY TWICE TO JUMP INTO THE SERIAL MONITOR
;
	LD	HL,SCBUG	;SERIAL MONITOR
	LD	(FUNJMP),HL	;FN FN JUMP
	LD	A,00H
	LD	(REGPNT),A	;INIT SINGLE STEPPER
	LD	(MODE),A	;START WITH SPEAKER ON
;
	LD	HL,B4800	;DEFAULT BAUD RATE
	CALL SERINI	;INITIALISE THE SERIAL BIT BANG PORT
;
	LD	HL,0100H
	LD	(KEYDEL),HL	;AUTO-INC/DEC DELAY
	LD	HL,1000H
	LD	(KEYTIM),HL	;DELAY TIME INSTEAD OF A BEEP
#IFDEF 74C923
	LD	A,20H
#ELSE
	LD	A,08H
#ENDIF
	LD	(OFTIM),A	;DISPLAY OFF TIME
	CALL	BEEP
	CALL	BEEP
#IFDEF 74C923
	LD	A,08H
#ELSE
	LD	A,10H
#ENDIF
	LD	(ONTIM),A	;DISPLAY ON TIME FOR KEYBOARD ENCODER
;
	EI		;ENABLE INTERRUPTS
;	CALL	SEREN	;ENABLE BUFFERED SERIAL
;-----------------
; SET UP MAIN LOOP
;-----------------
MAIN	LD	SP,ISTACK	;INITIALISE/RESET STACK
	LD	HL,RAMSRT
	LD	(ADRESS),HL	;DEFAULT ADDRESS
	LD	A,(MODE)
	OR	80H	;START OFF IN DATA MODE
	LD	(MODE),A
;
; SCAN THE DISPLAYS UNTIL A KEY IS PRESSED
;
MAIN1	CALL	UPDATE
MAIN2	CALL	SKEYIN	;WAIT FOR A KEY
	LD	HL,MENLST	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
	CALL	UPDATE	;UPDATE BUFFER AND
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	MAIN2
;
; MAIN MENU KEY TABLE
;
MENLST	.DB	20
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	FUNKEY,ADDKEY,INCKEY,DECKEY	;SC-1 KEYS  FN  AD  +  -
;---------------------------------------------------
; ENTER HEX KEY AS LEAST SIGNIFICANT ADDRESS OR DATA
;---------------------------------------------------
HEXKEY	CALL	BEEP
	LD	HL,MODE
	BIT	7,(HL)	;ADDR OR DATA MODE?
	JP	Z,HEXKY2	;IN ADDR MODE
;
; IN DATA MODE
;
HEXKY1	LD	HL,(ADRESS)
	SLA	(HL)	;FROM THE CURRENT
	SLA	(HL)	;ADDRESS,MOVE THE
	SLA	(HL)	;LSN TO THE MSN.
	SLA	(HL)	;PUT THE KEY IN
	OR	(HL)	;THE NEW DATA BACK AT
	LD	(HL),A	;THE CURRENT ADDRESS
	RET
;
; IN ADDRESS MODE
;
HEXKY2	LD	HL,(ADRESS)
	SLA	L	;CURRENT ADDRESS
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(ADRESS),HL	;SAVE CURRENT ADDRESS
	RET
;-------------
; CHANGE MODES
;-------------
ADDKEY	CALL	BEEP
	LD	A,(MODE)
	XOR	80H	;TOGGLE MODE
	LD	(MODE),A
	RET
;------------------
; INCREMENT ADDRESS
;------------------
INCKEY	CALL	BEEP
INCKY1	LD	HL,(ADRESS)
	INC	HL	;INC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)	;AUTO REPEAT DELAY
INCKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF
	JR	Z,INCKY3	; KEY RELEASED
	AND	1FH	;STRIP UNUSED BITS
	CP	KEYINC	; '+'
	JR	NZ,INCKY3	;NOT '+' KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,INCKY2	;SCAN DISPLAY FOR KEYDEL
	JP	INCKY1	;INC ADDRESS
INCKY3	RET
;------------------
; DECREMENT ADDRESS
;------------------
DECKEY	CALL	BEEP
DECKY1	LD	HL,(ADRESS)
	DEC	HL	;DEC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)	;AUTO REPEAT DELAY
DECKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF
	JR	Z,DECKY3	;KEY RELEASED
	AND	1FH
	CP	KEYDEC	; '-'
	JR	NZ,DECKY3	;NOT '-' KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,DECKY2	;SCAN DISPLAY FOR KEYDEL
	JP	DECKY1	;INC ADDRESS 
DECKY3	RET
;-----------------------------------------
; UPDATE DISPLAY BUFFER TO CURRENT ADDRESS
;-----------------------------------------
;
; UPDATE THE DISPLAY BUFFER WITH THE 
; CURRENT ADDRESS, THE DATA AT THE CURRENT ADDRESS
; AND SET THE DECIMAL POINTS TO
; ADDRESS OR DATA MODE
;
;	ENTRY : NONE
;	EXIT :  MODIFIES A
;
UPDATE	PUSH	HL
	PUSH	BC
	LD	HL,(ADRESS)
	CALL	DISADD	;AND DATA, PUT IN
	LD	A,(HL)
	CALL	DISBYT	;DISPLAY BUFFER
;
; IN ADDRESS OR DATA MODE?
;
	LD	HL,MODE
	BIT	7,(HL)	;DATA OR ADDR MODE?
	JP	Z,ADMODE	;ADDRESS MODE
;
; SHOW DATA MODE
;
	LD	HL,DISBUF	;SET THE DP'S
	LD	B,2	;IN THE DATA
	JP	SETDP	;DISPLAY
;
; SHOW ADDRESS MODE
;
ADMODE	LD	HL,DISBUF+2
	LD	B,4	;SET THE DP'S IN THE ADDRESS DISPLAY
;
; SET DECIMAL POINT
;
;SET DP IN THE BYTE POINTED TO BY HL
;
#IFDEF TEC-1F
SETDP	SET	4,(HL)	;SET BIT 4 FOR DP ON TEC-1F DISPLAY
#ELSE
SETDP	SET	7,(HL)	;SET BIT 7 FOR DP ON SC-1 DISPLAY
#ENDIF
	INC	HL	;POINT TO NEXT BYTE
	DJNZ	SETDP	;MORE BITS TO SET
	POP	BC
	POP	HL
	RET
;-----------------------------------------
; RETURN THE BASE ADDRESS OF RAM VARIABLES
;-----------------------------------------
;
;	ENTRY: NONE
;	EXIT: HL
;
VARRAM	LD	HL,VARBLS
		RET
;-------------
; MONITOR NAME
;-------------
; RETURNS THE MONITOR NAME
; ENTRY = NONE
; EXIT: HL -> 'SCNEO'    ACCA = 02H
;
MONNAME	LD	HL,NAMESZ
	LD	A,(NAMEBF)
	RET
;-----------
; BOARD TYPE
;-----------
; RETURNS THE TYPE OF BOARD THE MONITOR IS BUILT FOR
; ENTRY = NONE
; EXIT: HL -> 'SC-1'    ACCA = 01H
;             'TEC-1F'	ACCA = 02H
;
PCBTYP	LD	HL,TYPESZ
	LD	A,(TYPEBF)
	RET
;---------------
; VERSION NUMBER
;---------------
;RETURNS THE SOFTWARE VERSION NUMBER
;
;	ENTRY : NONE
; EXIT : HL -> VERSION NUMBER STRING
;        ACCA = BCD VERSION NUMBER D7-D4 = MAJOR, D3-D0 MINOR
;
VERS	LD	HL,VERSZ
	LD	A,(VERBCD)
	RET
;--------------
; KEYBOARD TYPE
;--------------
; RETURNS THE TYPE OF KEYBOARD USED
; ENTRY = NONE
; EXIT: HL -> KEYBOARD TYPE STRING
;       ACCA = 01H MM74C923 HARDWARE ENCODER
;       ACCA = 02H SOFTWARE SCANNED
;
KBDTYP	LD	HL,KYBSZ
	LD	A,(KYBDBF)
	RET

NAMESZ	.DB	"SCNEO",0
NAMEBF	.DB 02H

#IFDEF TEC-1F
TYPESZ	.DB	"TEC-1F",0
TYPEBF	.DB	02H
#ELSE
TYPESZ	.DB	"SC-1",0
TYPEBF	.DB 01H
#ENDIF

VERSZ	.DB	"1.0",0
VERBCD	.DB 18H

#IFDEF 74C923
KYBSZ	.DB "Hardware",0
KYBDBF	.DB	01H	
#ELSE
KYBSZ	.DB "Software",0
KYBDBF	.DB	02H	
#ENDIF

;-------------------------
; ADDRESS > DISPLAY BUFFER
;-------------------------
;CONVERT HL TO SEVEN SEGMENT CODE
;AND PUT IN ADDRESS DISPLAY BUFFER.
;
; ENTRY : HL = ADDRESS TO BE DISPLAYED
;
; EXIT  : NO REGISTERS MODIFIED
;
DISADD	PUSH	AF
	PUSH	HL
	PUSH	HL
	LD	A,H
	CALL	CONBYT
	LD	(DISBUF+4),HL
	POP	HL
	LD	A,L
	CALL	CONBYT
	LD	(DISBUF+2),HL
	POP	HL
	POP	AF
	RET
;---------------------------
; DATA BYTE > DISPLAY BUFFER
;---------------------------
;CONVERT THE ACC TO SEVEN SEGMENT CODE
;AND PUT IN DATA DISPLAY BUFFER.
;
; ENTRY :  A = DATA DISPLAY BYTE
;
; EXIT  : NO REGISTERS MODIFIED
;
DISBYT	PUSH	HL
	CALL	CONBYT
	LD	(DISBUF),HL
	POP	HL
	RET
;---------------------------------------
; CONVERT BYTE TO 7 SEGMENT DISPLAY CODE
;---------------------------------------
; CONVERTS BYTE IN ACC TO SEVEN SEGMENT CODE
; FOR DISPLAY
; ENTRY : A = BYTE TO BE CONVERTED
; EXIT  : H = HI NYBBLE SEVEN SEGMENT CODE
;         L = LO NYBBLE SEVEN SEGMENT CODE
;         A = NOT MODIFIED
CONBYT	PUSH	AF
	PUSH	AF
	CALL	CONVHI	;CONVERT HI NYBBLE
	LD	H,A
	POP	AF
	CALL	CONVLO	;CONVERT LO NYBBLE
	LD	L,A
	POP	AF
	RET
;---------------------------------------------
; HEXADECIMAL TO SEVEN SEGMENT CODE CONVERSION
;---------------------------------------------
; CONVERTS NYBBLE IN ACC TO SEVEN SEGMENT CODE
; FOR SEVEN SEGMENT DISPLAYS
; CONVHI = CONVERTS HIGH NYBBLE
; CONVLO = CONVERTS LO NYBBLE
;
; ENTRY : A = NYBBLE TO BE CONVERTED
; EXIT  : A = SEVEN SEGMENT CODE
;
CONVHI	RLCA
	RLCA
	RLCA	;MOVE TO LO NYBBLE
	RLCA	;FOR CONVERSION
CONVLO	PUSH	BC
	PUSH	HL
	LD	HL,SEGMNT	;USE THE HEX VALUE
	AND	0FH	;TO INDEX TO THE
	LD	C,A	;THE SEVEN SEGMENT
	LD	B,00H	;CODE FOR THAT VALUE
	ADD	HL,BC	;AND RETURN WITH
	LD	A,(HL)	;CODE IN A
	POP	HL
	POP	BC
	RET
;
; HEXADECIMAL TO 7 SEGMENT DISPLAY CODE TABLE
;
#IFDEF TEC-1F
SEGMNT	.DB	0EBH,28H,0CDH,0ADH	;0,1,2,3
	.DB	2EH,0A7H,0E7H,29H	;4,5,6,7
	.DB	0EFH,2FH,6FH,0E6H	;8,9,A,B
	.DB	0C3H,0ECH,0C7H,47H	;C,D,E,F
#ELSE
SEGMNT	.DB	3FH,06H,5BH,4FH	;0,1,2,3
	.DB	66H,6DH,7DH,07H	;4,5,6,7
	.DB	7FH,6FH,77H,7CH	;8,9,A,B
	.DB	39H,5EH,79H,71H	;C,D,E,F
#ENDIF
;-------------
; SCAN DISPLAY
;-------------
;AS THE DISPLAYS ARE MULTIPLEXED, THE DATA FOR EACH
;DISPLAY MUST BE LATCHED INTO THE DISPLAY SEGMENT
;LATCH IN TURN AND THE CORRESPONDING BIT IN THE DISPLAY
;SCAN LATCH TURNED ON TO DISPLAY THE DATA.
;TWO SHORT DELAYS ARE USED TO ADJUST THE DUTY
;CYCLE AND HENCE DISPLAY BRIGHTNESS.
;
; ENTRY : NONE
; EXIT  : NO REGISTERS MODIFIED
;
SCAND   PUSH    AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	HL,DISBUF+5
	LD	C,20H
SCAND1	LD	A,(HL)
	OUT	(DISPLY),A	;OUTPUT CHARACTER
	LD	A,C
	OR	40H	;KEEP D6 HIGH
	OUT	(SCAN),A	;TURN ON DISPLAY
	LD	A,(ONTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST ON TIME
SCAND2	DJNZ	SCAND2	;OF DISPLAY
	LD	A,B	;B IS NOW CLEAR, USE
	OR	40H	;KEEP D6 HIGH
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	LD	A,(OFTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST OFF TIME
SCAND3	DJNZ	SCAND3	;OF DISPLAY
	DEC	HL	;POINT TO NEXT
	RRC	C	;ELEMENT IN BUFFER
	JR	NC,SCAND1	;DISPLAY NEXT ELEMENT
	LD	A,B	;B IS NOW CLEAR, USE
	OUT	(DISPLY),A	;AND CLEAR DISPLAY LATCH
	OR	40H	;KEEP D6 HIGH
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	POP	HL
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;---------------------
; CLEAR DISPLAY BUFFER
;---------------------
CLRBUF	PUSH	HL
	PUSH	BC
	LD	HL,DISBUF
	LD	B,6
CLRBF1	LD	(HL),00H	;PUT ZERO IN 6
	INC	HL	;LOCATIONS POINTED
	DJNZ	CLRBF1	;TO BY HL
	POP	BC
	POP	HL
	RET
;--------------
; SCAN KEYBOARD
;--------------
; USE THE HARDWARE OR SOFTWARE SCANNED KEYBOARD
;
; BIT 7 NOT USED
; BIT 6 SHIFT KEY. HIGH IF SHIFT KEY PRESSED
;
; BIT 5 DATA AVAILABLE FLAG HIGH IF KEY PRESSED
; BITS 4 -0 KEY CODE
;
; SOFTWARE SCANNED KEYBOARD
; USE DISPLAY SCAN DRIVERS FOR COLUMNS
; AND KEYBOARD BUFFER AS ROWS.
; MAKE EACH DATA LINE HIGH IN TURN AND CHECK
; IF EACH INDIVIDUAL PUSHBUTTON IS PRESSED.
;
; MAPS KEYS AGAINST KEYMAP TABLE
;
; ENTRY : NONE
; EXIT  : A = 00H IF NO KEY DETECTED
;         A = DETECTED KEY BITS 0-4
;             BIT 5 = KEY AVAILABLE
;             BIT 6 = SHIFT KEY PUSHED
SCANKEY	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
	PUSH	HL
;
;USE THE KEYBOARD ENCODER
;
#IFDEF 74C923
;
; TEC-1F - 74C923 KEYBOARD ENCODER
;
#IFDEF TEC-1F
	IN	A,(KEYBUF)	;READ HARDWARE ENCODER
	AND	7FH	;STRIP UNUSED BIT
	BIT	6,A	;DA LOW?
	JR	Z,SCANKY1	;HANDLE THE KEY
	LD	A,00H
	JR	SCANKY4	;NO KEY
;
SCANKY1	BIT	5,A	;SHIFT KEY LOW?
	JR	Z,SCANKY2
	RES	5,A
	CALL	KEYCVT	;CONVERT TEC CODE TO SC CODE
	CALL	REMAP	;RE MAP THE KEYS
	RES	6,A	;RESET SHIFT BIT
	JR	SCANKY3
;
SCANKY2	CALL	KEYCVT	;CONVERT TEC CODE TO SC CODE
	CALL REMAP
	SET	6,A	;SET SHIFT BIT
SCANKY3	SET	5,A	;SET DATA AVAILABLE FLAG
SCANKY4	POP	HL
	POP	DE
	POP	BC
	RET
#ELSE
;
;SC - 74C923 KEYBOARD ENCODER
;
	IN	A,(KEYBUF)	;READ HARDWARE ENCODER
	AND	7FH	;STRIP UNUSED BIT
	BIT	5,A	;DA HIGH?
	JR	NZ,SCANKY1	;HANDLE THE KEY
	LD	A,00H
	JR SCANKY3	;NO KEY
;
SCANKY1	BIT	6,A	;SHIFT KEY LOW?
	JR	Z,SCANKY2
	CALL	REMAP
	RES	6,A	;RESET SHIFT BIT
	SET	5,A	;SET DA
	JR	SCANKY3
;
SCANKY2	CALL	REMAP
	SET	6,A	;SET SHIFT BIT
	SET	5,A	;SET DA
SCANKY3		POP	HL
	POP	DE
	POP	BC
	RET
#ENDIF
#ELSE
;
; SOFTWARE SCAN KEYBOARD 
; SAME FOR TEC-1 AND SC
;
SCANKY1	LD	A,00H
	OUT	(DISPLY),A	;CLEAR DISPLAY LATCH
	LD	B,A		;KEY
	LD	D,A		;COUNT
	LD	E,01H	;MASK
SCANKY2	LD	C,08H	;SCAN
SCANKY3	LD	A,C
	OR	40H	;KEEP SERIAL OUTPUT BIT HIGH
	OUT	(SCAN),A	;OUTPUT SCAN
	NOP
	NOP
	NOP
	IN	A,(KEYBUF)	;READ KEY BUFFER
	AND	E	;MASK
	JR	Z,SCANKY4	;KEY NOT DETECTED
	INC	D
	LD	L,B		;SAVE KEY
;
; END OF ROWS?
;
SCANKY4	INC	B	;NEXT KEY
	SRA	C	;SHIFT SCAN RIGHT
	JR	NC,SCANKY3	;NEXT ROW
;
; END OF COLUMNS?
;
	SLA	E	;SHIFT MASK LEFT
	BIT	5,E	;END OF KEYSCAN?
	JR	Z,SCANKY2	;NEXT COLUMN
;
; END OF SCAN
;
	LD	A,D
	CP	00H
	JR	Z,SCANKY6	;NO KEY PRESSED
	CP	01H
	JR	NZ,SCANKY1	;MORE THAN ONE KEY PRESSED
;
; ONE KEY DETECTED
;
	LD	A,40H
	OUT	(SCAN),A	;CLEAR SCAN REG (KEEP SERIAL DATA OUT BIT HIGH)
;
; HANDLE SHIFT KEY FOR TEC-1F SOFTWARE SCANNED KEYBOARD 
;
#IFDEF TEC-1F
	IN	A,(KEYBUF)
	BIT 5,A	;SHIFT LOW?
	JR	Z,SCANKY5
;
	LD	A,L		;RETURN KEY IN A
	CALL	KEYCVT	;CONVERT TEC CODE TO SC CODE
	CALL	REMAP
	SET	5,A	;SET DATA AVAILABLE FLAG
	JR	SCANKY7
;
SCANKY5	LD	A,L		;RETURN KEY IN A
	CALL	KEYCVT	;CONVERT TEC CODE TO SC CODE
	CALL	REMAP
	SET	5,A	;SET DATA AVAILABLE FLAG
	SET	6,A	;SET SHIFT KEY FLAG
	JR	SCANKY7
;
; HANDLE SHIFT KEY FOR SC SOFTWARE SCANNED KEYBOARD
;
#ELSE
	IN	A,(KEYBUF)
	BIT 6,A	;SHIFT LOW?
	JR	Z,SCANKY5
;
	LD	A,L		;RETURN KEY IN A
	CALL	REMAP
	SET	5,A	;SET DATA AVAILABLE FLAG
	JR	SCANKY7
;	
SCANKY5	LD	A,L		;RETURN KEY IN A
	CALL	REMAP
	SET	5,A	;SET DATA AVAILABLE FLAG
	SET	6,A	;SET SHIFT KEY FLAG
	JR	SCANKY7
#ENDIF
;
; NO KEY
;
SCANKY6	LD	A,40H
	OUT	(SCAN),A	;CLEAR SCAN REG (KEEP SERIAL DATA OUT BIT HIGH)
	XOR	A	;CLEAR A
SCANKY7	POP	HL
	POP	DE
	POP	BC
	RET
#ENDIF

#IFDEF TEC-1F 
;--------------------------------------------------
; CONVERT TEC KEY CODES TO SOUTHERN CROSS KEY CODES
;--------------------------------------------------
; CONVERT THE TEC KEYCODES;
; 'PLUS' (10H) TO 12H
; 'MINUS' (11H) TO 13H
; 'GO' (12H) TO 'FN' 10H
; 'AD' (13H) TO 11H
KEYCVT	AND	1FH
	BIT	4,A		;ONLY KEYS ABOVE 0FH
	JR	Z,KEYCVT1
	CP	12H		;TEC GO KEY?
	JR	Z,DEC2
	CP	13H		;TEC AD KEY?
	JR	Z,DEC2
INC2
	INC	A
	INC	A
	RET
DEC2
	DEC	A
	DEC	A
KEYCVT1	RET
#ENDIF
;----------------
; REMAP KEY CODES
;----------------
; CONVERT THE OUTPUT KEY CODES
; ACCORDING TO A REMAPPING TABLE
; ENTRY : A = KEY CODE
; EXIT  : A = REMAPPED KEY CODE
;
; REGISTERS MODIFIED A,F 
;
REMAP	PUSH	HL
	LD	HL,KEYMAP	;CHANGE TO ALTMAP,OR SOMETHING ELSE IF DESIRED
	AND	1FH
	CALL	INDEXB
	LD	A,(HL)
	POP	HL
	RET
;
;DEFAULT KEY MAP
; 0,1,2,3
; 4,5,6,7
; 8,9,A,B
; C,D,E,F
; FN,AD,+,-
KEYMAP	.DB	00H,01H,02H,03H
	.DB	04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH
	.DB	0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
;
; ALTERNATE MAP
; C,D,E,F
; 8,9,A,B
; 4,5,6,7
; 0,1,2,3
; FN,AD,-,+
ALTMAP	.DB	0CH,0DH,0EH,0FH
	.DB	08H,09H,0AH,0BH
	.DB	04H,05H,06H,07H
	.DB	00H,01H,02H,03H
	.DB	10H,11H,13H,12H
;-----------------------------
; SCAN DISPLAY UNTIL KEY PRESS
;-----------------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
SKEYIN	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A
	JR	Z,SKEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
; ENTRY : NONE
; EXIT  : NONE
;
SKEYRL	PUSH	AF
SKEYL1	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A
	JR	NZ,SKEYL1	;KEY NOT RELEASED
	POP	AF
	RET
;-------------------
; WAIT FOR KEY PRESS
;-------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
KEYIN	CALL	SCANKEY
	BIT	5,A
	JR	Z,KEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;---------------------
; WAIT FOR KEY RELEASE
;---------------------
; ENTRY : NONE
; EXIT  : NONE
;
KEYREL	PUSH	AF
KEYRL1	CALL	SCANKEY
	BIT	5,A
	JR	NZ,KEYRL1
	POP	AF
	RET
;-----------------
; KEY MENU HANDLER
;-----------------
; COMPARES ACC AGAINST TABLE OF ELEMENTS,
; IF FOUND JUMP TO ADDRESS CORRESPONDING TO
; THAT ELEMENT, RETURNS IF ELEMENT NOT FOUND.
; ENTRY :  A = ELEMENT TO LOOK FOR
;         HL = POINTS TO TABLE
; EXIT  :  ELEMENT NOT FOUND
;           HL HOLDS ADDRESS OF LAST ELEMENT
;          ELEMENT FOUND
;           CONTROL PASSES TO JUMP ADDRESS WITH
;          RETURN ADDRESS OF MENU CALL ON STACK
;
MENU	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
	PUSH	HL	;CALCULATE ADDRESS
	LD	D,00H	;OF THE JUMP TABLE BY
	LD	E,(HL)	;ADDING THE INDEX TO
	INC	HL	;THE ELEMENTS
	ADD	HL,DE	;TO THE ADDR OF THE
	LD	D,H	;TABLE
	LD	E,L
	POP	HL
	LD	B,(HL)	;GET NUMBER OF ENTRIES
	INC	HL	;POINT TO LIST OF ENTRIES
MENU1	CP	(HL)	;COMPARE WITH ENTRY
	JR	Z,MENU2	;FOUND VALUE IN TABLE
	INC	HL	;NEXT ENTRY IN LIST
	INC	DE	;NEXT ENTRY IN
	INC	DE	;JUMP TABLE
	DJNZ	MENU1	;CHECK MORE ENTRIES
	POP	DE
	POP	BC
	POP	AF
	RET	;NOT IN TABLE
;
; FOUND ELEMENT IN THE TABLE
; PASS CONTROL TO THE JUMP HANDLER
;
MENU2	LD	A,(DE)	;GET THE JUMP ADDR
	LD	L,A	;FROM THE TABLE
	INC	DE	;AND JUMP TO
	LD	A,(DE)	;THE JUMP ADDRESS
	LD	H,A	;FOR THAT ENTRY
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	JP	(HL)
;-------------------
; CALCULATE CHECKSUM
;-------------------
;CALCULATES CHECKSUM BETWEEN START AND END (INCLUSIVE)
;
; ENTRY : HL = START OF BLOCK TO SUM
;         DE = END OF BLOCK TO SUM
; EXIT  : A =  CHECKSUM
;         FLAG REGISTER MODIFIED
;
CHKSUM	PUSH	HL
	PUSH	DE
	INC	DE	;END OF BLOCK+1
	XOR	A	;CLEAR CHECKSUM
CHKSM1	ADD	A,(HL)	;COMPUTE CHEKSUM
	INC	HL	;POINT TO NEXT ELEMENT
	AND	A	;SET CARRY
	PUSH	HL
	SBC	HL,DE	;SUBTRACT
	POP	HL
	JR	C,CHKSM1	;MORE ELEMENTS
	POP	DE
	POP	HL
	RET
;--------------------------
; ACCESS BYTE LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS BYTE LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF ELEMENT A
;
INDEXB	PUSH	DE
	LD	E,A	;USE DE AS INDEX
	LD	D,0	;TO ELEMENT IN TABLE
	ADD	HL,DE	;BY ADDING TO HL
	POP	DE
	RET
;--------------------------
; ACCESS WORD LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS WORD LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF 2 BYTE ELEMENT A
;
INDEXW	PUSH	DE
	LD	E,A
	SLA	E	;MULTIPLY BY TWO
	LD	D,0
	ADD	HL,DE
	POP	DE
	RET
;-------------------------------
; GENERATE A QUASI-RANDOM NUMBER
;-------------------------------
; GENERATE AN 16 BIT RANDOM NUMBER
; USING LINEAR CONGRUENTIAL METHOD.
;     Rn+1 = (aRn+c) MOD m
; REFRESH REGISTER USED FOR Rn AND c
;	ENTRY : NONE
;	EXIT  : HL = RANDOM WORD
;	NO REGISTERS MODIFIED
;
RAND	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
;
; CALCULATE aRn
;
	LD	A,R	;MULTIPLY RANDOM NUMBER
	LD	E,A	;(Rn) BY
	LD	D,0
	LD	HL,0548H	;CONSTANT (a)
	CALL	MUL16
;
; CALCULATE aRn+c
;
	LD	A,R	;ADD IT TO ANOTHER
	LD	B,0	;READ OF THE
	LD	C,A	;THE REFRESH
	ADD	HL,BC	;REGISTER (c)
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;----------------------
; 16 BIT MULTIPLICATION
;----------------------
;16 BIT MULTIPLY
; ENTRY : HL = MULTIPLICAND (MPD)
;         DE = MULTIPLIER (MPR)
; EXIT : HL = RESULT
;FROM ZAKS 'PROGRAMMING THE Z80'
;
MUL16	PUSH	AF
	PUSH	BC
	LD	C,H	;MPR(H)
	LD	A,L	;MPR(L)
	LD	B,16	;BIT COUNTER
	LD	HL,0	;CLEAR RESULT
MULT	SRL	C	;MPR (H)
	RRA	;MPR (L)
	JR	NC,MULT1	;TEST CARRY
	ADD	HL,DE	;ADD MPD TO RESULT
MULT1	EX	DE,HL
	ADD	HL,HL	;DOUBLE -SHIFT MPD LEFT
	EX	DE,HL
	DJNZ	MULT	;DONE?
	POP	BC
	POP	AF
	RET
; MUSIC ROUTINE
; ADAPTED FROM TALKING ELECTRONICS TEC-1
; MONITOR MON-1
; BY JOHN HARDY AND KEN STONE
;
;----------------
; MUSIC SEQUENCER
;----------------
; SEQUENCES THROUGH A TABLE OF NOTES
; 1EH = REPEAT TUNE UNTIL RESET
; 1FH = PLAY ONCE AND RETURN
; ENTRY : HL = ADDRESS OF NOTE TABLE
; EXIT : NO REGISTERS MODIFIED
MUSIC	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF MUSIC
;
; PLAY EACH NOTE IN TURN
;
STEP	LD	A,(DE)	;GET ELEMENT FROM TABLE
	AND	1FH	;STRIP UNUSED BITS
;
; IF ELEMENT IS 00H PAUSE FOR A WHILE
;
	CP	00H
	JP	NZ,STEP1
	LD	BC,1000H
PAUSE	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,PAUSE	;LOOP UNTIL DE = 0
	INC	DE	;POINT TO NEXT ELEMENT
	JP	STEP
;
; IF ELEMENT IS 1EH REPEAT TUNE
;
STEP1	CP	1EH
	JP	NZ,STEP2
	POP	DE	;GET TABLE ADDRESS BACK
	PUSH	DE	;SAVE IT FOR LATER
	JP	STEP
;
; IF ELEMENT IS 1FH RETURN
;
STEP2	CP	1FH	;END OF TUNE TABLE?
	JP	NZ,STEP3
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
;NOW PLAY THE NOTE
;
STEP3	LD	B,A	;SAVE ELEMENT IN B
	LD	HL,PERIOD	;POINT TO PERIOD/2 TABLE
	CALL	INDEXB	;GET PERIOD/2
	LD	A,(HL)	;GET ELEMENT
	PUSH	AF	;SAVE FOR LATER
	LD	A,B	;GET ELEMENT BACK IN A
	LD	HL,LENGTH	;POINT TO DURATION/2 TABLE
	CALL	INDEXB	;GET DURATION/2
	LD	A,(HL)	;GET ELEMENT
	LD	L,A
	LD	H,0	;HL = DURATION/2
	POP	AF
	CALL	TONE	;DO NOTE ROUTINE
	INC	DE
	JP	STEP	;STEP TO NEXT ELEMENT
;
; PERIOD/2 OF NOTE
;
PERIOD	.DB	8CH,83H,7CH,75H,70H,67H,62H,5CH
	.DB	57H,52H,4EH,48H,45H,41H,3CH,39H
	.DB	36H,32H,2FH,2CH,2AH,27H,25H,23H
;
; NOTE DURATION/2
;
LENGTH	.DB	19H,1AH,1CH,1DH,1EH,20H,23H,25H
	.DB	27H,29H,2CH,2EH,31H,33H,37H,3AH
	.DB	3DH,41H,45H,49H,4DH,52H,57H,5CH
	.DB	10H
; TONE ROUTINE
; ADAPTED FROM TALKING ELECTRONICS TEC-1
; MONITOR MON-1
; BY JOHN HARDY AND KEN STONE
;
;--------------
; OUTPUT A TONE
;--------------
;
; ENTRY : A = PERIOD/2 OF NOTE
;         HL = DURATION/2 OF NOTE
; EXIT NO REGISTERS MODIFIED
TONE	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	C,A
	ADD	HL,HL	;DOUBLE DURATION
	XOR	A
TONE1	XOR	80H	;TOGGLE SPEAKER BIT
	OR	40H	;KEEP D6 HIGH
	OUT	(SCAN),A	;OUTPUT SPEAKER BIT
	LD	B,C
TONE2	PUSH	BC
	LD	B,02H
TONE3	DJNZ	TONE3	;DELAY FOR PERIOD/2
	POP	BC
	DJNZ	TONE2	; DELAY FOR PERIOD/2
	SBC	HL,DE	;END OF NOTE?
	JR	NZ,TONE1	;DO AGAIN
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;---------------
; KEY ENTRY BEEP
;---------------
BEEP	PUSH	HL
	PUSH	AF
	LD	HL,MODE
	BIT	6,(HL)	;BEEP ENABLED?
	JR	Z,BEEP2	;BEEP IS ENABLED
;
; DO KEYPRESS DELAY
;
	PUSH	DE	;DO A SHORT
	LD	DE,0001H	;DELAY TO PREVENT
	LD	HL,(KEYTIM)	;RECOGNITION
BEEP1	SBC	HL,DE	;OF DOUBLE
	JR	NC,BEEP1	;KEY STROKES
	POP	DE
	JR	BEEP3
;
; OUTPUT KEYPRESS TONES
;
BEEP2	LD	A,24H
	LD	HL,0030H
	CALL	TONE	;DO FIRST TONE
	LD	A,0EH
	LD	HL,0050H
	CALL	TONE	;DO SECOND TONE
BEEP3	POP	AF
	POP	HL
	RET
;----------------------------------------
; BREAKPOINT AND SINGLE STEPPING ROUTINES
;----------------------------------------
;DISPLAYS AND MODIFIES REGISTERS AFTER BREAKPOINT
; (RST 38H) OR SINGLE STEP INTERRUPT (IF HARDWARE
; ATTACHED).
;INSERT RST 38H (FFH) IN PROGRAM TO EXAMINE
; AND MODIFY REGISTERS.
;
SSTEP	POP	HL	;GET HL BACK
	PUSH	AF	;SAVE AF FOR LATER
	LD	(TMPHL),HL
	LD	(TMPDE),DE
	LD	(TMPBC),BC
	LD	(TMPIX),IX
	LD	(TMPIY),IY	;SAVE REGISTERS
	POP	HL	;GET AF BACK
	LD	(TMPAF),HL	;SAVE AF
	POP	HL	;GET PC RETURN ADDRESS
	LD	(TMPPC),HL	;SAVE PC
	LD	(TMPSP),SP	;SAVE STACK POINTER
;
; STEP THROUGH,DISPLAY AND EDIT REGISTERS
;
	CALL	BEEP
	LD	A,(REGPNT)	;GET CURRENT REG
	AND	7	;MAKE SURE IN LIMITS
	LD	(REGPNT),A	;SAVE IT
SSTEP1	CALL	SETREG	;SET UP DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR A KEY
	CALL	SKEYIN	;WAIT FOR KEY RELEASE
	LD	HL,REGTBL	;HANDLE THE KEY
	CALL	MENU	;AND UPDATE DISPLAY
	JP	SSTEP1	;BEFORE RETURNING TO LOOP
;
; REGISTER DISPLAY KEY TABLE
;
REGTBL	.DB	14H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
;
; MAKE THE GO KEY RETURN TO THE PROGRAM
; AND THE AD KEY RETURN TO THE MONITOR FOR THE TEC-1F
;
#IFDEF TEC-1F
	.DW RETPGM,RETMON,INCSTP,DECSTP
#ELSE
	.DW	RETMON,RETPGM,INCSTP,DECSTP
#ENDIF
;
; REGISTER NAME CHARACTERS
;
#IFDEF TEC-1F
REGNAM	.DW	4FC3H
	.DW	6F47H,0E6C3H,0ECC7H
	.DW	66C2H,286EH,28AEH
	.DW	0A74FH
#ELSE
REGNAM	.DW	7339H
	.DW	7771H,7C39H,5E79H
	.DW	7438H,0676H,066EH
	.DW	6D73H
#ENDIF
;--------------
; EDIT REGISTER
;--------------
REGKEY	CALL	BEEP
	PUSH	AF	;SAVE KEY FOR LATER
	LD	A,(REGPNT)
;
; EDIT REGISTER
;
	LD	HL,TMPPC
	CALL	INDEXW
	LD	C,(HL)
	INC	HL
	LD	B,(HL)	;GET REG CONTENTS
	SLA	C
	RL	B
	SLA	C
	RL	B
	SLA	C
	RL	B	;SHIFT REGISTER
	SLA	C	;FOUR BITS
	RL	B	;LEFT AND
	POP	AF	;PUT THE KEY
	OR	C	;INTO THE LSN
	LD	C,A	;AND PUT THE
	LD	(HL),B	;REGISTER BACK
	DEC	HL	;WHERE IT BELONGS
	LD	(HL),C
	RET
;------------------
; RETURN TO MONITOR
;------------------
RETMON	CALL	BEEP
	CALL	SKEYRL
	EI	;ENABLE INTERRUPTS AGAIN
	JP	MAIN
;------------------
; RETURN TO PROGRAM
;------------------
RETPGM	LD	SP,(TMPSP)	;PUT STACK POINTER BACK
	LD	HL,(TMPPC)	;PUT RETURN
	PUSH	HL	;ADDRESS BACK ON STACK
	LD	HL,(TMPAF)
	PUSH	HL	;SAVE AF REG FOR LATER
	LD	IY,(TMPIY)
	LD	IX,(TMPIX)
	LD	BC,(TMPBC)
	LD	DE,(TMPDE)	;RESTORE REGISTERS
	POP	AF	;RESTORE AF
	LD	HL,(TMPHL)	;RESTORE HL
	EI	;ENABLE INTERRUPTS
	RET	;AND RETURN TO PROGRAM
;----------------------
; DISPLAY NEXT REGISTER
;----------------------
INCSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	7	;END OF REG TABLE?
	JP	Z,INCSP1
	INC	A
	LD	(REGPNT),A
	RET
INCSP1	XOR	A
	LD	(REGPNT),A
	RET
;--------------------------
; DISPLAY PREVIOUS REGISTER
;--------------------------
DECSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	0	;START OF REG TABLE?
	JP	Z,DECSP1
	DEC	A
	LD	(REGPNT),A
	RET
DECSP1	LD	A,7
	LD	(REGPNT),A
	RET
;-----------------
; DISPLAY REGISTER
;-----------------
SETREG	LD	A,(REGPNT)
	LD	HL,TMPPC	;START OF TABLE
	CALL	INDEXW	;GET ELEMENT ADDRESS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL	;LOAD REGISTER CONTENTS
	CALL	DISADD
;
; DISPLAY REGISTER NAME
;
	LD	HL,REGNAM
	CALL	INDEXW
	LD	A,(HL)
	LD	(DISBUF+0),A
	INC	HL
	LD	A,(HL)
	LD	(DISBUF+1),A
	RET
;------------------
; FUNCTION KEY MENU
;------------------
; WHEN THE FN KEY IS PRESSED, Fn IS DISPLAYED IN THE
; DATA DISPLAYS, THE CURRENT ADDRESS REMAINS IN THE
; ADDRESS DISPLAYS THE PROGRAM THEN WAITS FOR A
; KEYPRESS WHICH WILL SELECT 1 OF 16 ROUTINES.
;
FUNKEY	CALL	BEEP
FUNKY1	LD	HL,(ADRESS)
	CALL	DISADD	;DISP ADDR TO REMOVE DP'S
#IFDEF TEC-1F
	LD	HL,0AF0FH	;USE THE GO KEY IN THE TEC
#ELSE
	LD	HL,7154H	;FN
#ENDIF
	LD	(DISBUF),HL	;DISPLAY FN
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
FUNKY2	CALL	SKEYIN
	LD	HL,(FUNTBL)	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
;
; RETURN TO MAIN
;
CANCEL	CALL	BEEP
CANCL1	CALL	UPDATE	;UPDATE DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	RET
;
; FUNCTION MENU KEY TABLE
;
FUNLST	.DB	11H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H	;FN KEY
	.DW	GOEXEC,INTELFN,ADDRA,ADDRB
	.DW	BLKMVE,BLKSUM,BRANCH,TRACE
	.DW	PLAY1,PLAY2,PLAY3,SWBEEP
	.DW	SECRET,RELSQR,SCOPE,TIME
	.DW	FUNFUN
;-----------------------
; CALL FUNCTION FUNCTION
;-----------------------
FUNFUN	LD	HL,(FUNJMP)
	JP	(HL)
;------------------------------------------
; FUNCTION 0 - EXECUTE FROM CURRENT ADDRESS
;------------------------------------------
GOEXEC	CALL	BEEP
	CALL	KEYREL
;	POP	HL	;REMOVE EXEC RETURN
	LD	HL,(ADRESS)
	JP	(HL)	;START EXECUCTION
;------------------------------------
; FUNCTION 1 RECEIVE INTEL HEX FORMAT
;------------------------------------
INTELFN	CALL	BEEP
	CALL	KEYREL
	CALL	INTELH
	JP	NZ,BLKMV1	;SHOW THE ERROR
	JP	CANCEL	;JUST RETURN IF ALL OK
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTELH	LD	IX,VARIDX	;POINT TO VARIABLES
;
; WAIT FOR RECORD MARK
;
INTEL1
	XOR	A
	LD	(IX+3),A	;CLEAR CHECKSUM
INTELC
	CALL	WAITC;WAIT FOR THE RECORD MARK
	CP	':'	;TO BE TRANSMITTED
	JR	NZ,INTEL1	;NOT RECORD MARK
;
; GET RECORD LENGTH
;
	CALL	GETBYT
	LD	(IX+0),A	;NUMBER OF DATA BYTES
;
; GET ADDRESS FIELD
;
	CALL	GETBYT
	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
	CALL	GETBYT
	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
;
; GET RECORD TYPE
;
	CALL	GETBYT
	JR	NZ,INTEL4	;END OF FILE RECORD
;
; READ IN THE DATA
;
	LD	B,(IX+0)	;NUMBER OF DATA BYTES
	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE

INTEL2	CALL	GETBYT	;GET DATA BYTE
	LD	(HL),A	;STORE DATA BYTE
	INC	HL
	DJNZ	INTEL2	;LOAD MORE BYTES
;
; GET CHECKSUM AND COMPARE
;
	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE RECORD CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
	RET	;NZ=CHECKSUM ERROR
;
; END OF FILE RECORD
;
INTEL4	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE EOF CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	RET	;NZ=CHECKSUM ERROR
;--------------------------
; GET BYTE FROM SERIAL PORT
;--------------------------
GETBYT	PUSH	BC
	CALL	WAITC
	BIT	6,A
	JR	Z,GETBT1
	ADD	A,09H
GETBT1	AND	0FH
	SLA 	A
	SLA	A
	SLA	A
	SLA	A
	LD	C,A
;
; GET LOW NYBBLE
;
	CALL	WAITC
	BIT	6,A
	JR	Z,GETBT2
	ADD	A,09H
GETBT2	AND	0FH
	OR	C
	LD	B,A
	ADD	A,(IX+3)
	LD	(IX+3),A	;ADD TO CHECKSUM
	LD	A,B
	AND	A	;CLEAR CARRY
	POP	BC
	RET
;-------------------------------
; CONVERT ASCII CHARACTER TO HEX
;-------------------------------
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : A= HEX 0-F IN LSN
; A AND F REGISTERS MODIFIED
;
ASCHEX	BIT	6,A
	JR	Z,ASCHX1
	ADD	A,09H
ASCHX1	AND	0FH
	RET
;------------------------------------
; BIT BANG SERIAL PORT INITIALISATION
;------------------------------------
; SET THE SERIAL TRANSMIT PIN HIGH SO THE 
; HOST CAN SEE THAT WE ARE PREPARING TO TRANSMIT
; 
; ENTRY : HL = BAUD RATE
;         HL = 0 USE EXISTING BAUD CONSTANT
; EXIT  : HL PRESERVED
;       ; AF MODIFIED
;
SERINI	LD	A,40H
	OUT	(SCAN),A	;TURN OFF THE DISPLAY MAKE SERIAL TX HIGH
	LD	B,50
	CALL	MSDELAY	;WAIT SO THE HOST SEES TX HIGH
	LD	A,H
	OR	L
	RET	Z	;HL IS ZERO DON'T UPDATE THE BAUD RATE
	LD  (BAUD),HL	;UPDATE THE BAUD RATE
    RET	
;------------------
; MILLISECOND DELAY
;------------------
; APPROX. 1 MILLISECOND DELAY
; 
; ENTRY : B = 1 TO 255 MILLISECONDS
; EXIT  : B = 0
;
MSDELAY	PUSH	BC	;11T
	LD	B,233	;7T
MSDEL1	NOP	;4T
	DJNZ	MSDEL1	;NZ=13T,Z=8T
	POP	BC	;10T
	DJNZ	MSDELAY	;NZ=13T,Z=8T
	RET	;10T
;------------------------
; SERIAL TRANSMIT ROUTINE
;------------------------
;TRANSMIT BYTE SERIALLY ON DOUT
;
; ENTRY : A = BYTE TO TRANSMIT
;  EXIT : NO REGISTERS MODIFIED
;
TXDATA	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(BAUD)
	LD	C,A
;
; TRANSMIT START BIT
;
	XOR	A
	OUT	(SCAN),A
	CALL	BITIME
;
; TRANSMIT DATA
;
	LD	B,08H
	RRC	C
NXTBIT	RRC	C	;SHIFT BITS TO D6,
	LD	A,C	;LSB FIRST AND OUTPUT
	AND	40H	;THEM FOR ONE BIT TIME.
	OUT	(SCAN),A
	CALL	BITIME
	DJNZ	NXTBIT
;
; SEND STOP BITS
;
	LD	A,40H
	OUT	(SCAN),A
	CALL	BITIME
	CALL	BITIME
	POP	HL
	POP	BC
	POP	AF
	RET
;-----------------------
; SERIAL RECEIVE ROUTINE
;-----------------------
;RECEIVE SERIAL BYTE FROM DIN
;
; ENTRY : NONE
;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
;
; REGISTERS MODIFIED A AND F
;
RXDATA	PUSH	BC
	PUSH	HL
;
; WAIT FOR START BIT
;
RXDAT1	IN	A,(KEYBUF)
	BIT	7,A
	JR	NZ,RXDAT1	;NO START BIT
;
; DETECTED START BIT
;
	LD	HL,(BAUD)
	SRL	H
	RR	L	;DELAY FOR HALF BIT TIME
	CALL	BITIME
	IN	A,(KEYBUF)
	BIT	7,A
	JR	NZ,RXDAT1	;START BIT NOT VALID
;
; DETECTED VALID START BIT,READ IN DATA
;
	LD	B,08H
RXDAT2	LD	HL,(BAUD)
	CALL	BITIME	;DELAY ONE BIT TIME
	IN	A,(KEYBUF)
	RL	A
	RR	C	;SHIFT BIT INTO DATA REG
	DJNZ	RXDAT2
	LD	A,C
	OR	A	;CLEAR CARRY FLAG
	POP	HL
	POP	BC
	RET
;---------------
; BIT TIME DELAY
;---------------
;DELAY FOR ONE SERIAL BIT TIME
;ENTRY : HL = DELAY TIME
; NO REGISTERS MODIFIED
;
BITIME	PUSH	HL
	PUSH	DE
	LD	DE,0001H
BITIM1	SBC	HL,DE
	JP	NC,BITIM1
	POP	DE
	POP	HL
	RET
;-----------------------------
; FUNCTION 2 - ENTER ADDRESS 1
;-----------------------------
ADDRA	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKSRT),HL	;ADDRESS AS START
#IFDEF TEC-1F
	LD	HL,0C300H	;ADDRESS [
#ELSE
	LD	HL,3900H	;ADDRESS [
#ENDIF
	CALL	SDELAY
	JP	CANCL1
;-----------------------------
; FUNCTION 3 - ENTER ADDRESS 2
;-----------------------------
ADDRB	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKEND),HL	;ADDRESS AS END
#IFDEF TEC-1F
	LD	HL,00A9H	;ADDRESS ]
#ELSE
	LD	HL,000FH	;ADDRESS ]
#ENDIF
	CALL	SDELAY
	JP	CANCL1
;------------------------
; FUNCTION 4 - BLOCK MOVE
;------------------------
BLKMVE	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKDST),HL	;ADDRESS AS
#IFDEF TEC-1F
	LD	HL,0C3A9H	;DESTINATION
#ELSE
	LD	HL,390FH	;DESTINATION
#ENDIF
	CALL	SDELAY
;
; CALCULATE NUMBER OF BYTES TO MOVE
;
	LD	HL,(BLKEND)
	LD	DE,(BLKSRT)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE MOVE INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKMV3	;IF OK MOVE BLOCK
;
; SHOW ERROR
;
#IFDEF TEC-1F
BLKMV1	LD	HL,00C7H	;SHOW ERROR E
#ELSE
BLKMV1	LD	HL,0079H	;SHOW ERROR E
#ENDIF
BLKMV2	CALL	BEEP
	LD	(DISBUF),HL	;AND WAIT
	CALL	SKEYIN	;FOR KEYPRESS
	CALL	BEEP
	CALL	SKEYRL
	JP	CANCL1
;
; MOVE BLOCK
;
BLKMV3	CALL	MOVE
	JP	CANCL1
;-----------
; BLOCK MOVE
;-----------
MOVE	LD	BC,(COUNT)
	LD	HL,(BLKSRT)	;START ADDR
	LD	DE,(BLKDST)	;DESTINATION ADDR
	LDIR
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
SDELAY	LD	(DISBUF),HL	;SHOW HL
	LD	B,255	;IN DATA DISPLAYS
SDELY1	CALL	SCAND	;UNTIL KEY
	DJNZ SDELY1	;IS RELEASED
	CALL	SKEYRL
	RET
;---------------------------
;FUNCTION 5 - BLOCK CHECKSUM
;---------------------------
BLKSUM	CALL	BEEP
#IFDEF TEC-1F
	LD	HL,0C3A7H	;CS
#ELSE
	LD	HL,396DH	;CS
#ENDIF
	CALL	SDELAY	;SHOW PROMPT
	LD	DE,(BLKSRT)
	LD	HL,(BLKEND)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE CHECKSUM INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKSM1	;IF OK SUM BLOCK
;
; SHOW ERROR
;
	JP	BLKMV1
;
; CALCULATE CHECKSUM
;
BLKSM1	LD	HL,(BLKSRT)
	LD	DE,(BLKEND)
	CALL	CHKSUM	;DO THE CHECKSUM,
	CALL	DISBYT	;DISPLAY
	LD	HL,(COUNT)	;NUMBER OF BYTES
	CALL	DISADD	;SUMMED AND
	CALL	BEEP
	CALL	SKEYIN	;CHECKSUM UNTIL
	CALL	BEEP	;A KEY IS PRESSED
	CALL	SKEYRL
	JP	CANCL1
;----------------------------------------
; FUNCTION 6 - RELATIVE BRANCH CALCULATOR
;----------------------------------------
BRANCH	CALL	BEEP
#IFDEF TEC-1F
	LD	HL,44E6H	;RB
#ELSE
	LD	HL,507CH	;RB
#ENDIF
	CALL	SDELAY
	LD	HL,(ADRESS)	;GET CURRENT ADDRESS
	LD	DE,(BLKSRT)
	INC	DE	;POINT TO PC+2
	AND	A
	SBC	HL,DE	;SUBTRACT
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF BACKWARD BRANCH
;
	LD	A,H
	CP	255	;BACKWARD BRANCH?
	JP	NZ,BRNCH1	;CHECK IF FORWARD
;
;CHECK IF WE HAVE BRANCHED BEYOND -128
;
	LD	A,L
	BIT	7,A
	JR	NZ,BRNCH2	;BRANCH IS WITHIN LIMITS
	JP	BLKMV1	;TOO FAR BACK
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF FORWARD BRANCH
;
BRNCH1	CP	0	;FORWARD BRANCH?
	JP	NZ,BLKMV1	;TOO FAR IN ANY DIRECTION
;
; CHECK IF WE HAVE BRANCHED BEYOND +128
;
	LD	A,L
	BIT	7,A
	JP	NZ,BLKMV1	;TOO FAR FORWARD
;
; WITHIN LIMITS PUT IN RAM
; AND SHOW AS CURRENT ADDRESS
;
BRNCH2	LD	HL,(BLKSRT)
	LD	(ADRESS),HL
	LD	(HL),A
	JP	CANCL1
;-----------------------------------------
; FUNCTION 7 - TOGGLE HARDWARE SINGLE STEP
;-----------------------------------------
TRACE	CALL	BEEP
#IFDEF TEC-1F
	OUT	(PORT7),A	;TOGGLE HARDWARE LATCH
	LD	HL,0046H	;SHOW T
#ELSE
	OUT	(IO7),A	;TOGGLE HARDWARE LATCH
	LD	HL,0070H	;SHOW T
#ENDIF
	CALL	SDELAY
	JP	CANCL1
;-------------------------
; FUNCTION 8 - PLAY TUNE 1
;-------------------------
PLAY1	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE1
	CALL	MUSIC
	JP	CANCL1
;-------------------------
; FUNCTION 9 - PLAY TUNE 2
;-------------------------
PLAY2	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE2
	CALL	MUSIC
	JP	CANCL1
;------------------------------
; FUNCTION A - PLAY TUNE IN RAM
;------------------------------
PLAY3	CALL	BEEP
	CALL	KEYREL
	LD	HL,(ADRESS)
	CALL	MUSIC
	JP	CANCL1
;-----------------------------
; FUNCTION B - TOGGLE KEY BEEP
;-----------------------------
SWBEEP	CALL	BEEP
	LD	A,(MODE)
	XOR	40H
	LD	(MODE),A
	JP	CANCL1
;
; TUNE 1
; FROM TALKING ELECTRONICS TEC-1
; MONITOR MON-1
; BY JOHN HARDY AND KEN STONE
;
TUNE1	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,0FH,0AH,0DH,0FH
	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,06H,12H,00H,1EH
;
; TUNE 2
; FROM TALKING ELECTRONICS TEC-1
; MONITOR MON-1
; BY JOHN HARDY AND KEN STONE
;
TUNE2	.DB	0BH,0AH,08H,0AH,0AH,0AH,06H,06H
	.DB	06H,0BH,0AH,08H,0AH,0AH,0AH,0AH
	.DB	0AH,0AH,0BH,0AH,08H,0AH,0AH,0AH
	.DB	06H,06H,06H,0AH,08H,0AH,0DH,0DH
	.DB	0DH,0DH,0DH,00H,0DH,05H,08H,0BH
	.DB	0BH,0BH,06H,06H,06H,0BH,0AH,08H
	.DB	0AH,0AH,0AH,06H,06H,06H,0BH,0AH
	.DB	06H,08H,08H,08H,08H,08H,0AH,0BH
	.DB	0AH,08H,06H,06H,06H,06H,06H,06H
	.DB	00H,00H,00H,1EH
;---------------------------
; FUNCTION C - SECRET NUMBER
;---------------------------
SECRET	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND CLEAR DISPLAY
	CALL	CLRBUF	;BUFFER
	LD	IX,VARIDX	;USE IX FOR LOCAL VARIABLES
;
; SEPARATE NYBBLES IN RANDOM NUMBER
;
	CALL	RAND
	LD	(IX+11),L
	LD	(IX+12),H	;RANDOM NUMBER
	LD	A,(IX+11)	;SEPARATE THE RANDOM
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+4),L	;FOUR NYBBLES
	LD	(IX+5),H	;TO MAKE CHECKING
	LD	A,(IX+12)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+6),L
	LD	(IX+7),H
	XOR	A
	LD	I,A	;CLEAR NUMBER OF TRIES
	LD	HL,0
	LD	(IX+8),L
	LD	(IX+9),H
	CALL	DISADD	;AND DISPLAY GUESS
;
; SCAN THE KEYBOARD
;
SECRT1	CALL	SKEYIN	;WAIT FOR KEY
	LD	HL,SECNUM
	CALL	MENU	;EXECUTE KEY HANDLER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	SECRT1
;
; SECRET NUMBER KEY TABLE
;
SECNUM	.DB	12H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
;
; MAKE THE GO KEY CHECK THE NUMBER
; AND THE AD KEY RETURN TO THE MONITOR FOR THE TEC-1F
;
#IFDEF TEC-1F
	.DW	CHKKEY,ENDKEY
#ELSE
	.DW	ENDKEY,CHKKEY
#ENDIF
;---------------
; EDIT GUESS KEY
;---------------
EDTKEY	PUSH	AF
	LD	L,(IX+8)
	LD	H,(IX+9)	;GET CURRENT GUESS
	SLA	L
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	POP	AF
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(IX+8),L
	LD	(IX+9),H	;SAVE GUESS
	CALL	DISADD
	CALL	BEEP
	RET
;----------
; QUIT GAME
;----------
ENDKEY	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND RETURN TO
	JP	MAIN	;MONITOR
;---------------------------
; SEE IF ITS THE RIGHT GUESS
;---------------------------
CHKKEY	CALL	BEEP
	LD	A,I
	INC	A
	DAA	;INC BCD NO. OF TRIES
;
; BRIEFLY SHOW GUESS NO.
;
	LD	I,A
	CALL	DISBYT
	LD	B,255
CHKKY1	CALL	SCAND
	DJNZ	CHKKY1
;
; SEPARATE GUESS INTO NYBBLES
;
	LD	A,(IX+8)	;GET CURRENT GUESS
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+0),L	;FOUR NYBBLES
	LD	(IX+1),H	;TO MAKE CHECKING
	LD	A,(IX+9)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+2),L
	LD	(IX+3),H
;
; CHECK FOR CORRECT NUMBER,CORRECT SPOT
;
	XOR	A
	LD	(IX+10),A	;CLEAR RESULT
	LD	HL,VARIDX+4	;POINT TO RANDOM
	LD	DE,VARIDX	;POINT TO GUESS
	LD	B,4	;NUMBER OF DIGITS
CHKKY2	LD	A,(HL)	;GET RANDOM
	EX	DE,HL
	CP	(HL)	;SAME AS GUESS?
	JR	NZ,CHKKY4	;NOT SAME
	LD	A,(IX+10)
	ADD	A,10H	;RIGHT POSITION
	LD	(IX+10),A
CHKKY3	INC	HL	;POINT TO NEXT
	EX	DE,HL	;DIGIT POSITION
	INC	HL	;AND GO
	DJNZ	CHKKY2	;CHECK OTHER POSITIONS
	JP	CHKKY8
;
; CHECK IF NUMBER IS THERE
;
CHKKY4	PUSH	BC
	PUSH	HL
	LD	B,4	;CHECK EACH DIGIT
	LD	HL,VARIDX	;TO SEE IF THIS
CHKKY5	CP	(HL)	;NUMBER IS IN
	INC	HL	;THE WRONG
	JR	NZ,CHKKY6	;POSITION
	LD	A,(IX+10)	;AND UPDATE
	INC	A	;THE RESULT
	LD	(IX+10),A
	JP	CHKKY7
CHKKY6	DJNZ	CHKKY5
CHKKY7	POP	HL
	POP	BC
	JP	CHKKY3	;CHECK NEXT DIGIT
;
; CHECK IF CORRECT
;
CHKKY8	LD	A,(IX+10)
	CP	40H	;IS IT CORRECT?
	JP	Z,CHKKY9	;YES!
	LD	A,(IX+10)	;NOT CORRECT
	CALL	DISBYT	;IN DATA DISPLAYS
	LD	A,I	;WAS THAT THE
	CP	20H	;LAST GUESS?
	RET	NZ	;NO TRY AGAIN
;
; RAN OUT OF TRYS
;
	CALL	CLRBUF	;DISPLAY
	LD	L,(IX+11)
	LD	H,(IX+12)	;THE RANDOM NUMBER
	CALL	DISADD	;AND PLAY
	LD	HL,LOSE	;THE LOSE
	JP	CHKKYA	;MUSIC
;
; GOT THE RIGHT ANSWER
;
CHKKY9	LD	A,I	;DISPLAY HOW MANY
	CALL	DISBYT	;AND PLAY THE WIN
	LD	L,(IX+11)
	LD	H,(IX+12)
	LD	HL,WIN	;MUSIC
;
; PLAY MUSIC AND WAIT FOR ANY KEY TO RESTART
;
CHKKYA	CALL	MUSIC	;PLAY THE MUSIC
	CALL	SKEYIN	;WAIT FOR A KEY
	CALL	BEEP
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	POP	HL	;AND RESTART THE GAME
	JP	SECRET
;
; WIN AND LOSE MUSIC
; FROM TALKING ELECTRONICS TEC-1
; MONITOR MON-1
; BY JOHN HARDY AND KEN STONE
;
WIN	.DB	14H,12H,14H,17H,17H,12H,14H,10H,1FH
LOSE	.DB	01H,11H,01H,11H,01H,11H,1FH
;-------------------------------
; SEPARATE BYTE INTO TWO NYBBLES
;-------------------------------
;SEPARATES A BYTE INTO TWO
;RIGHT JUSTIFIED NYBBLES
; ENTRY : A = BYTE TO BE SEPARATED
; EXIT  : H = MSN
;         L = LSN
;
SPLIT	PUSH	AF
	PUSH	BC
	LD	B,A	;SAVE BYTE
	AND	0FH	;STRIP BITS LSN
	LD	L,A	;RETURN LSN IN L
	LD	A,B
	SRL	A
	SRL	A
	SRL	A	;MOVE MSN
	SRL	A	;INTO LSN
	LD	H,A	;RETURN MSN IN H
	POP	BC
	POP	AF
	RET
;-----------------------------------
; FUNCTION D - RELAY BOARD SEQUENCER
;-----------------------------------
RELSQR	CALL	BEEP
	CALL	KEYREL
	LD	HL,RLTEST	;POINT TO TEST SEQUENCE
	CALL	RLSTEP
	JP	CANCL1
;--------------
; TEST SEQUENCE
;--------------
RLTEST	.DB	55H,01H,0AAH,01H,00H,0FFH
;----------------
; RELAY SEQUENCER
;----------------
; SEQUENCES RELAYS ON RELAY BOARD
; USES TWO BYTES TO SPECIFY OUTPUT DATA AND DELAY TIME
; DELAY TIME BYTE ALSO DETERMINES IF SEQUENCE IS TO STOP
; OR REPEAT.
;  TABLE:
;  <BYTE1>,<BYTE2>
;  BYTE1 = DATA TO GO TO OUTPUT LATCH (USES PORT IO1)
;  BYTE2 = FF - REPEAT
;          00 - FINISHED
;  ENTRY : HL POINTS TO TABLE OF OUTPUT DATA
;  EXIT : NONE MODIFIED
;
RLSTEP	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF DATA
RELSR1	LD	A,(DE)
	LD	C,A	;GET OUTPUT DATA
	INC	DE
	LD	A,(DE)	;GET TIME DELAY
	CP	0
	JR	Z,RELSR4	;END OF SEQUENCE
	CP	255
	JR	Z,RELSR3	;REPEAT SEQUENCE
	LD	B,A
	LD	A,C
#IFDEF TEC-1F
	OUT	(PORT3),A	;STROBE
#ELSE
	OUT	(IO1),A
#ENDIF
	INC	DE
RELSR2	CALL	DELONE	;1 SEC DELAY
	DJNZ	RELSR2	;MORE SECONDS TO GO
	JP	RELSR1
;
; REPEAT
;
RELSR3	POP	DE	;GET START ADDRESS
	PUSH	DE	;SAVE FOR LATER
	JP	RELSR1
;
; FINISHED
;
RELSR4	LD	A,00H
#IFDEF TEC-1F
	OUT	(PORT3),A	;STROBE
#ELSE
	OUT	(IO1),A	;CLEAR OUTPUT REG
#ENDIF
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
;
; ENTRY : NONE
; EXIT : FLAG REGISTER MODIFIED
;
DELONE	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	HL,0870H
DELON1	LD	B,92H
DELON2	DJNZ	DELON2	;INNER LOOP
	SBC	HL,DE
	JP	NC,DELON1	;OUTER LOOP
	POP	HL
	POP	DE
	POP	BC
	RET
;--------------------------
; FUNCTION E - KALEIDOSCOPE
;--------------------------
SCOPE	CALL	BEEP
	CALL	KEYREL
	CALL	RAND	;GENERATE RANDOM
	EX	DE,HL
	LD	HL,BUFFER	;NUMBER AND SET UP
	LD	A,E	;THE FIRST QUADRANT
	CALL	SEED	;WITH A RANDOM BIT
	LD	A,D	;PATTERN
	CALL	SEED
;
; GENERATE MIRROR IMAGES
;
SCOPE2	LD	B,04H
	LD	HL,BUFFER
	LD	DE,BUFFER+7
SCOPE3	LD	A,(HL)	;MIRROR THE FIRST
	LD	(DE),A	;QUADRANT INTO
	INC	HL	;THE FOURTH
	DEC	DE	;QUADRANT
	DJNZ	SCOPE3
;
; MIRROR ACROSS CENTRE OF DISPLAY
;
	LD	B,8	;MIRROR THE FIRST
	LD	HL,BUFFER	;AND FOURTH QUADRANT
	LD	A,(HL)	;ACROSS THE CENTRE
	AND	0FH	;OF THE DISPLAY
	LD	(HL),A	;INTO THE SECOND
SCOPE4	BIT	0,(HL)	;AND THIRD QUADRANTS.
	JP	Z,SCOPE5	;CHECKING IF THE
	SET	7,(HL)	;BITS IN THE LSN ARE
SCOPE5	BIT	1,(HL)	;SET, AND SETTING THE
	JP	Z,SCOPE6	;CORRESPONDING
	SET	6,(HL)	;MIRROR IMAGE
SCOPE6	BIT	2,(HL)	;BIT IN THE MSN
	JP	Z,SCOPE7	;IF THEY ARE.
	SET	5,(HL)	;DO THIS FOR
SCOPE7	BIT	3,(HL)	;THE EIGHT ROWS
	JP	Z,SCOPE8	;OF DATA BYTES
	SET	4,(HL)	;IN THE DISPLAY
SCOPE8	INC	HL
	DJNZ	SCOPE4	;MORE ROWS TO DO
;
; DISPLAY RANDOM BIT PATTERN
;
	LD	DE,0001H	;SET UP DELAY
	LD	HL,0200H
SCOPE9	PUSH	HL
	LD	HL,BUFFER
	CALL	SKATE	;SCAN 8X8
	POP	HL
	SBC	HL,DE
	JP	NZ,SCOPE9
;
; MANIPULATE BITS FOR NEXT IMAGE
;
SCOPEA	LD	HL,BUFFER
	LD	A,5
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 5 TO FIRST LSN
	INC	HL
	LD	A,03H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 3 TO SECOND LSN
	INC	HL
	LD	A,01H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 1 TO THIRD LSN
	INC	HL
	LD	A,07H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 15 TO FOURTH LSN
	JP	SCOPE2	;MIRROR BIT PATTERN
;
; SEED THE FIRST QUADRANT WITH RANDOM BITS
;
SEED	LD	B,A	;PUT THE
	AND	0FH	;RANDOM NUMBER
	LD	(HL),A	;INTO THE
	INC	HL	;FIRST QUADRANT
	LD	A,B	;OF THE
	AND	240	;DISPLAY
	RRA
	RRA
	RRA
	RRA
	LD	(HL),A
	INC	HL
	RET
;-----------------
; SCAN 8X8 DISPLAY
;-----------------
;PUT THE 8 RAM LOCATIONS POINTED TO
;BY HL ON THE 8X8 DISPLAY,LOW BYTE
;ON TOP ROW.
;  ROUTINE PERIOD IS 500uS
;  PULSE WIDTH 15uS  GIVES 3% DUTY
;
; ENTRY : HL = ADDRESS OF 8X8 BUFFER
;	EXIT : NO REGISTERS MODIFIED
;
SKATE	PUSH	AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	C,80H
SKATE1	LD	A,(HL)
#IFDEF TEC-1F
	OUT	(PORT3),A	;OUTPUT X
#ELSE
	OUT	(IO0),A	;OUTPUT X
#ENDIF
	LD	A,C
#IFDEF TEC-1F
	OUT	(PORT4),A	;OUTPUT Y
#ELSE
	OUT	(IO2),A	;OUTPUT Y
#ENDIF
	LD	B,02H
SKATE2	DJNZ	SKATE2	;ON TIME DELAY
	XOR	A
#IFDEF TEC-1F
	OUT	(PORT3),A
	OUT	(PORT4),A	;CLEAR DISPLAY LATCHES
#ELSE
	OUT	(IO0),A
	OUT	(IO2),A	;CLEAR DISPLAY LATCHES
#ENDIF
	LD	B,08H
SKATE3	DJNZ	SKATE3	;OFF TIME DELAY
	INC	HL
	RRC	C
	JR	NC,SKATE1	;MORE TO OUTPUT
	POP	HL
	POP	BC
	POP	AF
	RET
;----------------------------
; FUNCTION F - CLOCK CALENDAR
;----------------------------
TIME	CALL	BEEP
	CALL	KEYREL	;WAIT FOR KEY RELEASE
	LD	IX,VARIDX	;USE IX FOR TEMP VARIABLES
	LD	A,(ONTIM)
	LD	(IX+0),A	;SAVE DISPLAY SCAN DELAY
	LD	A,60H
	LD	(ONTIM),A	;USE NEW DELAY
	LD	(IX+1),A	;START IN TIME MODE
;
; DISPLAY TIME,CHECK FOR KEY
;
TIME1	CALL	RWATCH	;READ THE CLOCK/CALENDAR
	CALL	UPDBUF	;UPDATE THE DISPLAY BUFFER
	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A
	JR	Z,TIME1	;NO KEY KEEP LOOKING
	AND	1FH
	LD	HL,TIMKEY
	CALL	MENU
	JR	TIME1

TIMKEY	.DB	4
	.DB	10H,11H,12H,13H
	.DW	CLKEXT,SETCLK,CALKEY,CALKEY
;--------------------
; EXIT CLOCK CALENDAR
;--------------------
CLKEXT	POP	HL	;REMOVE RETURN
	LD	A,(IX+0)
	LD	(ONTIM),A	;RESTORE DELAY TIME
	JP	CANCEL
;--------------------
; TOGGLE DISPLAY MODE
;--------------------
CALKEY	CALL	BEEP
	CALL	KEYREL
	LD	A,(IX+1)
	XOR	80H	;TOGGLE DISPLAY
	LD	(IX+1),A
	RET
;----------------------
; UPDATE DISPLAY BUFFER
;----------------------
UPDBUF	BIT	7,(IX+1)	;WHICH DISPLAY MODE?
	JR	NZ,UPDBF2	;CALENDAR DISPLAY
;
; TIME DISPLAY
;
UPDBF1	LD	A,(SWREG1)
	CALL	CONBYT
#IFDEF	TEC-1F
	SET	4,L
#ELSE
	SET	7,L	;SET DECIMAL POINT
#ENDIF
	LD	(DISBUF),HL	;SHOW SECONDS (0-59)
	LD	A,(SWREG2)
	CALL	CONBYT
#IFDEF	TEC-1F
	SET	4,L
#ELSE
	SET	7,L	;SET DECIMAL POINT
#ENDIF	
	LD	(DISBUF+2),HL	;SHOW MINUTES (0-59)
	LD	A,(SWREG3)
	CALL	CONBYT
#IFDEF	TEC-1F
	SET	4,L
#ELSE
	SET	7,L	;SET DECIMAL POINT
#ENDIF
	LD	(DISBUF+4),HL	;SHOW HOURS (0-23)
	RET
;
; CALENDAR DISPLAY
;
UPDBF2	LD	A,(SWREG7)
	CALL	CONBYT
	LD	(DISBUF),HL	;SHOW YEAR (0-99)
;
; CHECK MODE FOR DD/MM/YY OR MM/DD/YY
;
	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,UPDBF3	;MM/DD/YY MODE
;
; DD/MM/YY MODE
;
	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW DATE (1-31)
	JR	UPDBF4
;
; MM/DD/YY MODE
;
UPDBF3	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW DATE (1-31)
;
; SHOW DAY
;
UPDBF4	LD	A,(SWREG4)	;GET DAY REG
	AND	07H
	JR	Z,UPDBF5	;ZERO IS ILLEGAL
	CP	07H
	JR	Z,UPDBF5	;DON'T SHOW SATURDAY
	CPL	;WORK OUT
	SUB	01H	;WHICH DECIMAL POINT
	AND	07H	;TO LIGHT
	LD	HL,DISBUF	;ADDING THE DAY
	LD	B,00H	;TO A DISPLAY
	LD	C,A	;BUFFER INDEX
	ADD	HL,BC	;AND SETTING THE
#IFDEF	TEC-1F
	SET	4,(HL)
#ELSE
	SET	7,(HL)	;DECIMAL POINT
#ENDIF	
UPDBF5	RET	;IN THAT DISPLAY
;--------------
; SET TIME/DATE
;--------------
SETCLK	CALL	BEEP
	CALL	KEYREL
;
; EDIT THE DISPLAY BUFFER
;
SETCK1	CALL	UPDBUF	;UPDATE DISPLAY BUFFER
	CALL	SKEYIN
	CALL	KEYREL
	CP	10H	;FN KEY EXITS (NO CHANGE)
	RET	Z
	CP	11H	;AD KEY SETS CLOCK/CALENDAR
	JR	Z,SETCK8
	CP	12H
	JR	Z,SETCK4	;PLUS KEY
	CP	13H
	JR	Z,SETCK6	;MINUS KEY
	CP	0AH	;NO A-F KEYS
	JR	NC,SETCK1
;
; IS IT SET CLOCK OR SET CALENDAR?
;
	BIT	7,(IX+1)
	JR	NZ,SETCK2
;
; SET CLOCK DISPLAY
;
	LD	HL,SWREG1
	RLD	;MOVE THE NEW KEY
	INC	HL	;INTO THE CLOCK BUFFER
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR DISPLAY
;
SETCK2	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,SETCK3	;MM/DD/YY MODE
;
; SET CALENDAR AS DD/MM/YY
;
	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	RLD
	DEC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR AS MM/DD/YY
;
SETCK3	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	DEC	HL
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; INC DAY
;
SETCK4	BIT	7,(IX+1)
	JR	Z,SETCK1
	LD	A,(SWREG4)
	CP	07H	;IS THE DAY SUNDAY?
	JR	NZ,SETCK5
	LD	A,00H	;SET MONDAY
SETCK5	INC	A	;DAY=DAY+1
	LD	(SWREG4),A
	JP	SETCK1
;
; DEC DAY
;
SETCK6	BIT	7,(IX+1)
	JP	Z,SETCK1
	LD	A,(SWREG4)
	CP	01H	;IS THE DAY MONDAY?
	JR	NZ,SETCK7
	LD	A,08H	;SET SUNDAY
SETCK7	DEC	A	;DAY=DAY-1
	LD	(SWREG4),A
	JP	SETCK1
;
; SET THE CLOCK/CALENDAR WITH NEW DATA
;
SETCK8	CALL	BEEP
	CALL	KEYREL
	LD	A,(SWREG3)
	AND	3FH	;24 HOUR MODE
	LD	(SWREG3),A
	LD	A,(SWREG4)
	AND	07H	;OSC ON,RST ENABLED
	LD	(SWREG4),A
	CALL	WWATCH	;WRITE CHANGES
	RET
;---------------------
; READ FROM SMARTWATCH
;---------------------
; READS DATA FROM SMARTWATCH, USES LOOKUP TABLE TO
; WRITE 64 BIT ACCESS CODE TO ENABLE THE SMARTWATCH.
; READS ALL DATA INTO REGISTERS AS RAM CANNOT BE READ
; OR WRITTEN TO WHILE WATCH IS ENABLED.
;
;  ENTRY : NONE
;  EXIT  : NO WORKING REGISTERS MODIFIED
;          (ALTERNATE SET MODIFIED)
;  CONTENTS OF SMARTWATCH WRITTEN TO SWREG0 - SWREG7
;
;
; ENABLE SMARTWATCH
;
RWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	HL,PATERN	;WRITE D0 OF ALL THE BYTES
	LD	B,64	;IN THE TABLE TO THE RAM TO
RWACH1	LD	A,(HL)	;ENABLE THE SMARTWATCH
	LD	(DALLAS),A
	INC	HL
	DJNZ	RWACH1
;
; READ DATA FROM WATCH
;
	LD	B,32
RWACH2	LD	A,(DALLAS)	;SHIFT THE FIRST 32 BITS
	SRL	A	;INTO THE 16 BIT REGISTERS
	RR	D	;DE AND HL
	RR	E	;THEN EXCHANGE THEM WITH
	RR	H	;THE ALTERNATE PAIR
	RR	L
	DJNZ	RWACH2
	EXX
	LD	B,32
RWACH3	LD	A,(DALLAS)	;NOW SHIFT THE LAST 32 BITS
	SRL	A	;INTO THE SAME 16 BIT REGISTERS
	RR	D
	RR	E
	RR	H
	RR	L
	DJNZ	RWACH3
;
; SAVE IN WATCH REGISTERS
;
	LD	(SWREG4),HL	;SMARTWATCH READ IS COMPLETE
	LD	(SWREG6),DE	;GET THE DATA
	EXX
	LD	(SWREG0),HL
	LD	(SWREG2),DE
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
; SMARTWATCH ACCESS PATTERN
;
PATERN	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
;--------------------
; WRITE TO SMARTWATCH
;--------------------
;
; WRITE DATA TO SMARTWATCH BY FIRST ACCESSING
; IT USING BIT MANIPULATION.
; DATA IS WRITTEN BY FIRSTLY PUTTING ALL 64 BITS
; INTO REGISTERS AS RAM CANNOT BE ACCESSED ONCE THE
; SMARTWATCH IS ENABLED.
;
; ENTRY : NONE
; THE DATA TO WRITE TO THE SMARTWATCH
; MUST BE IN SWREG0 - SWREG7
;  EXIT : NO WORKING REGISTERS MODIFIED
;  (ALTERNATE SET MODIFIED)
; GET DATA TO WRITE TO WATCH
;
WWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(SWREG4)	;SET UP THE
	LD	DE,(SWREG6)	;16 BIT REGISTERS
	EXX
	LD	HL,(SWREG0)	;WITH THE DATA TO BE
	LD	DE,(SWREG2)	;WRITTEN TO THE SMARTWATCH
;
; WRITE 64 BIT ACCESS CODE TO ENABLE SMARTWATCH
;
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	A,0C5H
	LD	C,80H	;NUMBER OF BYTES
WWACH1	LD	B,80H	;NUMBER OF BITS
WWACH2	LD	(DALLAS),A	;WRITE TO RAM
	RRC	A
	SRL	B
	JR	NC,WWACH2	;MORE BITS
	SRL	C
	JR	C,WWACH4	;NO MORE BYTES
	BIT	0,A
	JR	NZ,WWACH3
	RRC	A
	RRC	A
	RRC	A
	RRC	A
	JR	WWACH1
WWACH3	CPL
	JR	WWACH1
;
; WRITE DATA TO WATCH
;
WWACH4	LD	B,32	;SHIFT THE FIRST 32 BITS
WWACH5	SRL	D	;OUT OF THE 16 BIT REGISTERS
	RR	E	;ONTO D0 AND INTO
	RR	H	;THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH5
	EXX	;RESTORE REGISTERS
	LD	B,32	;GET THE OTHER 32 BITS FROM
WWACH6	SRL	D	;THE ALTERNATE REGISTER SET
	RR	E	;AND SHIFT THEM ONTO D0
	RR	H	;AND INTO THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH6
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
; USES SMARTWATCH TO DELAY FOR 1 SECOND
; BY WAITING FOR SECONDS REGISTER TO ROLLOVER
;
; FIRST READ GETS A REFERENCE, SUBSEQUENT READS
; WAIT UNTIL THE SECONDS COUNTER NO LONGER
; READS THE SAME AS THE REFERENCE VALUE,
; THEN THE ROUTINE RETURNS
;
; ENTRY : NONE
; EXIT : NONE MODIFIED
;
ONESEC	PUSH	AF
	PUSH	BC
	CALL	RWATCH	;READ WATCH
	LD	A,(SWREG1)
	LD	B,A	;SAVE REF COUNT
ONESC1	CALL	RWATCH
	LD	A,(SWREG1)
	CP	B	;SAME AS REF?
	JP	Z,ONESC1	;YES SO WAIT AGAIN
	POP	BC
	POP	AF
	RET
;---------------------
; SCBUG SERIAL MONITOR
;---------------------
; PRESS THE FUNCTION KEY TWICE TO START THE MONITOR
; COMMS PARAMETERS ARE 115200,n,8,2
;
;------------
; ASCII CODES
;------------
ESC	.EQU	1BH
CR	.EQU	0DH
LF	.EQU	0AH
;
; START UP THE MONITOR
;
SCBUG	LD	(SPSAVE),SP	;SAVE STACK POINTER
	CALL	PRNTSZ
	.DB	27,"[H",27,"[2J",0	;VT100 TERMINAL COMMANDS FOR CLEAR SCREEN,CURSOR HOME
	CALL	PCBTYP
	CALL	SNDMSG	;BOARD TYPE
	CALL	OUTSP
	CALL	MONNAME
	CALL	SNDMSG
	CALL	PRNTSZ
	.DB	" Serial Monitor ",0
	CALL	VERS
	CALL	SNDMSG	;MONITOR VERSION
	CALL	TXCRLF
	CALL	KBDTYP
	CALL	SNDMSG	;KEYBOARD TYPE
	CALL	PRNTSZ
	.DB	" Keyboard",0
	CALL	PRNTSZ
	.DB	CR,LF,"H for command list",CR,LF,0
;
; DISPLAY THE PROMPT AND WAIT FOR COMMANDS
;
START2	
	LD	A,'>'
	CALL	TXBUF	;DISPLAY THE PROMPT
START3
	CALL	WAITC	;GET A CHARACTER FROM THE CONSOLE
	LD	C,A	;SAVE FOR LATER
	AND	0DFH	;TURN LOWER CASE INTO UPPER CASE
;
; IF THE COMMAND IS NOT IN THE COMMAND LIST REJECT IT
;
	LD	HL,MONMENU
	LD	B,(HL)	;NUMBER OF COMMANDS
	INC	HL
START4	CP	(HL)	;IN THE LIST?
	JR	Z,START5	;OK DO IT
	INC	HL
	DJNZ	START4	;KEEP LOOKING
	JR	START3
START5	
	CALL	TXBUF	;ECHO THE VALID CHARACTER 
	LD	A,C	;GET THE CHARACTER BACK
	AND	0DFH	;AND TURN BACK INTO UPPER CASE
	LD	HL,MONMENU	;USE THE MENU HANDLER
	CALL	MENU	;KEY IN A, EXECUTE MENU
;
; THE MENU FUNCTION CALL LEAVES THE RETURN ADDRESS OF THE MENU CALL
; ON THE STACK SO ANY CALLED SUBROUTINES CAN COME BACK HERE WITH A RET
;
WARM	CALL	TXCRLF	;START ON A NEW LINE
	JP	START2
;
; SCBUG MONITOR COMMANDS
;
MONMENU	.DB 7
	.DB	'D','H','T','M','G','I','X'
	.DW	DSPLAY,HELP,SSTOGL,MODIFY
	.DW	GOJUMP,INTHEX,EXIT
	
;---------------------
; WAIT FOR A CHARACTER
;---------------------
WAITC	CALL	RXBUF
	JR	C,WAITC	;NO CHARACTER
	RET
;-----------------------------
; GET A BYTE FROM THE TERMINAL
;-----------------------------
GETCHR	CALL	WAITC
	CP	ESC
	JR	Z,GETOUT
	LD	B,A	;SAVE TO ECHO
	CALL	ASC2HEX
	JR	NC,GETCHR	;REJECT NON HEX CHARS
	LD	HL,DATA
	LD	(HL),A
	LD	A,B
	CALL	TXBUF	;ECHO VALID HEX
;	
GETNYB	CALL	WAITC
	CP	ESC
	JR	Z,GETOUT
	LD	B,A	;SAVE TO ECHO
	CALL	ASC2HEX
	JR	NC,GETNYB	;REJECT NON HEX CHARS
	RLD
	LD	A,B
	CALL	TXBUF	;ECHO VALID HEX
	LD	A,(HL)
	CALL	GETOUT	;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
	CCF	;AND THEN COMPLEMENTING IT
	RET
GETOUT	SCF	;SET THE CARRY FLAG TO EXIT BACK TO MENU
	RET
;---------------
; OUTPUT A SPACE
;---------------
OUTSP	LD	A,' '
	    JP	TXBUF
;-------------
; OUTPUT CRLF
;------------
TXCRLF	LD	A,CR
	CALL	TXBUF
	LD	A,LF
	JP	TXBUF
;------------------------------
; GO <ADDR>
; TRANSFERS EXECUTION TO <ADDR>
;------------------------------
GOJUMP	CALL	OUTSP
	CALL	GETCHR	;GET ADDRESS HIGH BYTE
	RET	C
	LD	(ADDR+1),A	;SAVE ADDRESS HIGH
	CALL	GETCHR	;GET ADDRESS LOW BYTE
	RET	C
	LD	(ADDR),A	;SAVE ADDRESS LOW
;
; WAIT FOR A CR OR ESC
;
GOJMP1	CALL	WAITC
	CP	ESC	;ESC KEY?
	RET	Z
	CP	CR
	JR	NZ,GOJMP1
	CALL	TXCRLF
	LD	HL,(ADDR)
	JP	(HL)	;JUMP TO USER ADDRESS
;---------------------
; DISPLAY COMMAND HELP
;---------------------
HELP	CALL	PRNTSZ
	.DB	CR,LF,"D AAAA    Display Data at Address AAAA"
	.DB	CR,LF,"          SPACE to CONTINUE, ESC to QUIT"
	.DB	CR,LF,"T         Toggle Single Stepper"
	.DB	CR,LF,"M AAAA    Modify Address AAAA"
	.DB	CR,LF,"G AAAA    GO from AAAA"
	.DB	CR,LF,"I         Download INTEL Hex"
	.DB	CR,LF,"X         Exit"
	.DB	CR,LF,"H         This Help Message",CR,LF,0
	RET
;-----------------------------------------------
; T COMMAND TOGGLE SINGLE STEPPER (IF INSTALLED)
;-----------------------------------------------
; CAN'T TELL IF THE SINGLE STEPPER IS ON OR OFF
; SO WE WILL JUST TOGGLE THE FLIP FLOP
;
SSTOGL	CALL	PRNTSZ
	.DB	CR,LF,"Single Step Toggle",CR,LF,0
#IFDEF TEC-1F
	OUT	(PORT7),A	;TOGGLE HARDWARE LATCH
#ELSE
	OUT	(IO7),A	;TOGGLE HARDWARE LATCH
#ENDIF
	RET
;----------------------------
; M DISPLAY AND MODIFY MEMORY
;----------------------------
MODIFY	CALL	OUTSP
;
;GET THE ADDRESS
;
	CALL	GETCHR
	RET	C
	LD	(ADDR+1),A	;SAVE ADDRESS HIGH
	CALL	GETCHR
	RET	C
	LD	(ADDR),A	;SAVE ADDRESS LOW
;
; DISPLAY ON A NEW LINE
;
MDIFY1	CALL	TXCRLF
	LD	DE,(ADDR)
	LD	HL,BUFFER
	CALL	WRDASC	;CONVERT ADDRESS IN DE TO ASCII
	LD	HL,BUFFER
	CALL	WRDOUT	;OUTPUT THE ADDRESS
	CALL	OUTSP
;
;GET THE DATA AT THE ADDRESS
;
	LD	HL,(ADDR)
	LD	A,(HL)
;
; DISPLAY THE DATA
;
	LD	HL,BUFFER
	CALL	BYTASC	;CONVERT THE DATA BYTE IN A TO ASCII
	LD	HL,BUFFER
	CALL	BYTOUT	;OUTPUT THE BYTE
	CALL	OUTSP
;
; GET NEW DATA,EXIT OR CONTINUE
;
	CALL	GETCHR
	RET	C
	LD	B,A	;SAVE IT FOR LATER
	LD	HL,(ADDR)
	LD	(HL),A	;PUT THE BYTE AT THE CURRENT ADDRESS
	LD	A,B
	CP	(HL)
	JR	Z,MDIFY2
	LD	A,'?'
	CALL	TXBUF	;NOT THE SAME DATA, PROBABLY NO RAM THERE
;
; INCREMENT THE ADDRESS
;
MDIFY2	INC	HL
	LD	(ADDR),HL
	JP	MDIFY1
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTHEX	CALL	PRNTSZ
	.DB	CR,LF,"Send INTEL Hex File...",0
	CALL	INTELH
	JR	NZ,ITHEX1
	CALL	PRNTSZ
	.DB	CR,LF,"File Received OK",CR,LF,0
	RET
ITHEX1	CALL	PRNTSZ
	.DB	CR,LF,"Checksum Error",CR,LF,0
	RET
;------------------------
; EXIT BACK TO SC MONITOR
;------------------------
; WE SAVED THE STACK POINTER WHEN WE ENTERED SCBUG
; WE WILL USE IT NOW TO RETURN FROM WHERE WE CAME FROM
;
EXIT	CALL	PRNTSZ
	.DB	CR,LF,"Bye...",CR,LF,0
;
	LD	SP,(SPSAVE)	;RESTORE STACK POINTER
	RET
;------------------
; DISPLAY REGISTERS
;------------------
REGSTR	CALL	DISREG	;DISPLAY REGISTERS
	LD	HL,BUFFER
	CALL	SNDMSG
	RET
;----------------------------------------
; CONVERT ASCII CHARACTER INTO HEX NYBBLE
;----------------------------------------
; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
; ENTRY OTHER THAN HEXADECIMAL KEYS
;
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : CARRY =  1
;          A= HEX 0-F IN LSN
;      : CARRY = 0
;          A= OUT OF RANGE CHARACTER & 7FH
; A AND F REGISTERS MODIFIED
;
ASC2HEX	AND	7FH	;STRIP OUT PARITY
	CP	'0'
	JR	C,AC2HEX4	;LESS THAN 0
	CP	3AH
	JR	NC,AC2HEX2	;MORE THAN 9
	AND	0FH	;CONVERT TO NYBBLE
AC2HEX1	SCF	;SET THE CARRY - IS HEX
	RET
;
AC2HEX2	CP	'A'
	JR	C,AC2HEX4	;LESS THAN A
	CP	47H
	JR	NC,AC2HEX3	;MORE THAN F
	SUB	07H	;CONVERT TO NYBBLE
	JR	AC2HEX1
	
AC2HEX3	CP	'a'
	JP	C,AC2HEX4	;LESS THAN a
	CP	67H
	JR	NC,AC2HEX4	;MORE THAN f
	AND 0DFH
	SUB 07H	;CONVERT TO NYBBLE
	JR	AC2HEX1
AC2HEX4	AND	0FFH	;RESET THE CARRY - NOT HEX
	RET
;--------------------------
; D DISPLAY MEMORY LOCATION
;--------------------------
DSPLAY	CALL	OUTSP	;A SPACE
	CALL	GETCHR
	RET	C
	LD	(ADDR+1),A	;SAVE ADDRESS HIGH
	CALL	GETCHR
	RET	C
	LD	(ADDR),A	;SAVE ADDRESS LOW
;
; WAIT FOR CR OR ESC
;
DPLAY1	CALL	WAITC
	CP	ESC
	RET	Z
	CP	CR
	JR	NZ,DPLAY1
	CALL	TXCRLF	;NEWLINE
;
; DISPLAY THE LINE
;
DPLAY2 CALL  DPLINE
	LD	(ADDR),DE	;SAVE THE NEW ADDRESS
;
; DISPLAY MORE LINES OR EXIT
;
DPLAY3	CALL	WAITC
	CP	' '	;SPACE DISPLAYS THE NEXT LINE
	JR	Z,DPLAY2
	CP	ESC	;ESC EXITS
	JR	NZ,DPLAY3
	RET
;-------------------------
; DISPLAY A LINE OF MEMORY
;-------------------------
DPLINE	LD	DE,(ADDR)	;ADDRESS TO BE DISPLAYED
	LD	HL,BUFFER	;HL POINTS TO WHERE THE OUTPUT STRING GOES
;
; DISPLAY THE ADDRESS
;
	CALL	WRDASC	;CONVERT ADDRESS IN DE TO ASCII
	CALL	SPCBUF
;
; DISPLAY 16 BYTES
;
	LD	B,16
DLINE1	LD	A,(DE)
	CALL	BYTASC
	CALL	SPCBUF
	INC	DE
	DJNZ	DLINE1
	CALL	SPCBUF
;
; NOW DISPLAY THE ASCII CHARACTER
; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
; BE DIFFERENT BETWEEN THE TWO PASSES!
;
	LD	DE,(ADDR)
	LD	B,16
DLINE2	LD	A,(DE)
	CP	20H
	JR	C,DOT
	CP	7FH
	JR	NC,DOT
	JP	NDOT
DOT	LD	A,'.'
NDOT	CALL	INBUF
	INC	DE
	DJNZ	DLINE2
;
;TERMINATE AND DISPLAY STRING
;
	CALL	BCRLF
	LD	A,00H
	LD	(HL),A
	LD	HL,BUFFER
	CALL	SNDMSG
	RET
;
; PUT A SPACE IN THE BUFFER
;
SPCBUF	LD	A,' '
INBUF	LD	(HL),A
	INC	HL
	RET
;
; PUT A CR LF IN THE BUFFER
;
BCRLF	LD	A,CR
	CALL	INBUF
	LD	A,LF
	CALL	INBUF
	RET
;----------------------
; SEND ASCII HEX VALUES
;----------------------
;
; OUTPUT THE 4 BYTE, WRDOUT
; THE 2 BYTE, BYTOUT
; OR THE SINGLE BYTE, NYBOUT
; ASCII STRING AT HL TO THE SERIAL PORT
;
WRDOUT	CALL	BYTOUT
BYTOUT	CALL	NYBOUT
NYBOUT	LD	A,(HL)
	CALL	TXBUF
	INC	HL
	RET
;----------------
;CONVERT TO ASCII
;----------------
;
; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
;
;        ENTRY :  WRDASC           DE = WORD TO CONVERT
;                 BYTASC            A = BYTE TO CONVERT
;                 NYBASC (B3-B0) OF A = NYBBLE TO CONVERT
;                  HL = CHARACTER BUFFER ADDRESS
;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
;                  AF IS MODIFIED
;
WRDASC	LD	A,D	;CONVERT AND
	CALL	BYTASC	;OUTPUT D
	LD	A,E	;THEN E
;
;CONVERT A BYTE TO ASCII 
;
BYTASC	PUSH	AF	;SAVE A FOR SECOND NYBBLE
	RRCA	;SHIFT HIGH NYBBLE ACROSS
	RRCA
	RRCA
	RRCA
	CALL	NYBASC	;CALL NYBBLE CONVERTER
	POP	AF	;RESTORE LOW NYBBLE
;
; CONVERT A NYBBLE TO ASCII
;
NYBASC	AND	0FH	;MASK OFF HIGH NYBBLE
	ADD	A,90H	;CONVERT TO
	DAA	;ASCII
	ADC	A,40H
	DAA
;
; SAVE IN STRING
; ADD A CHARACTER TO BUILD THE STRING
;
INSBUF	LD	(HL),A
	INC	HL
	XOR	A	;CLEAR A
	LD	(HL),A	;TERMINATE THE STRING
	RET
;------------------------------------------------------
; CONVERT A BYTE INTO A STRING OF ASCII ONES AND ZEROES
;------------------------------------------------------
;
;        DESCRIPTION : CONVERTS A BYTE, STARTING AT BIT 7,
;                      INTO A STRING OF ASCII
;                      ONES AND ZEROES.
;
;           ENTRY :  A = BINARY TO CONVERT
;                   HL = CHARACTER BUFFER ADDRESS
;           EXIT :  HL = POINTS TO LAST CHARACTER+1
;
;        MODIFIES : NONE
;
BITASC PUSH  BC
	LD	B,08H	;LOOK AT ALL 8 BITS
BTASC1	BIT	7,A	;A 1 OR A 0?
	JR	NZ,BTASC3
	LD	C,30H	;IT'S A ZERO
BTASC2	LD	(HL),C
	JR	BTASC4
BTASC3	LD	C,31H	;IT'S A ONE
	LD	(HL),C
BTASC4	INC	HL
	RLA
	DJNZ	BTASC1	;NEXT BIT
	POP	BC
	RET
;-----------------------------------------
; SEND AN ASCII STRING OUT THE SERIAL PORT
;-----------------------------------------
;
; SENDS A ZERO TERMINATED STRING OR 
; 255 CHARACTERS MAX. OUT THE SERIAL PORT
;
;      ENTRY : HL = POINTER TO ZERO TERMINATED STRING
;      EXIT  : SAME AS ENTRY
;
SNDMSG	PUSH	BC
	PUSH	HL
	PUSH	AF
	LD	B,255	;255 CHARS MAX
SDMSG1	LD	A,(HL)	;GET THE CHAR
	CP	00H	;ZERO TERMINATOR?
	JR	Z,SDMSG2	;FOUND A ZERO TERMINATOR, EXIT
	CALL	TXBUF	;TRANSMIT THE CHAR
	INC	HL
	DJNZ	SDMSG1	;255 CHARS MAX!
	
SDMSG2	POP	AF
	POP	HL	
	POP	BC	
	RET
;----------------------
; SERIAL SINGLE STEPPER
;----------------------
SSSTEP	POP	HL	;GET HL BACK
	PUSH	AF	;SAVE AF FOR LATER
	LD	(TMPHL),HL
	LD	(TMPDE),DE
	LD	(TMPBC),BC
	LD	(TMPIX),IX
	LD	(TMPIY),IY ;SAVE REGISTERS
	POP	HL	;GET AF BACK
	LD	(TMPAF),HL	;SAVE AF
	POP	HL	;GET PC RETURN ADDRESS
	LD	(TMPPC),HL	;SAVE PC
	LD	(TMPSP),SP	;SAVE STACK POINTER
;
	CALL	DISREG	;DISPLAY REGISTERS
	LD	HL,BUFFER
	CALL	SNDMSG
; WE HAVE DISPLAYED THE REGISTER CONTENTS NOW
; SPACE KEY CONTINUES EXECUTION, ESCAPE KEY
; RETURNS TO SERIAL MONITOR
;
SSTEP3	CALL	WAITC
	CP	' '	;IS IT SPACE
	JR	Z,SSTEP4
	CP	ESC	;ESC QUITS
	JR	NZ,SSTEP3
;
; RETURN TO MONITOR
;
	EI	;RE-ENABLE INTERRUPTS
	JP	WARM	;EXIT THE INTERRUPT ROUTINE
;
; RETURN TO PROGRAM
;
SSTEP4	LD	SP,(TMPSP)	;PUT STACK POINTER BACK
	LD	HL,(TMPPC)	;PUT RETURN
	PUSH	HL	;ADDRESS BACK ON STACK
	LD	HL,(TMPAF)
	PUSH	HL	 ;SAVE AF REG FOR LATER
	LD	IY,(TMPIY)
	LD	IX,(TMPIX)
	LD	BC,(TMPBC)
	LD	DE,(TMPDE)	;RESTORE REGISTERS
	POP	AF	;RESTORE AF
	LD	HL,(TMPHL)	;RESTORE HL
	EI		;RE-ENABLE INTERRUPTS
	RET		;AND RETURN TO PROGRAM
;----------------------------
; DISPLAY THE SAVED REGISTERS
;----------------------------
DISREG	CALL	PRNTSZ
	.DB	CR,LF,"PC   AF   BC   DE   HL   IX   IY   SP   SZ-H-VNC",CR,LF,0
;
; DISPLAY THE REGISTERS
;
	LD	B,08H
	LD	HL,BUFFER
	LD	IX,TMPPC
DSREG1	LD	A,(IX+1)
	CALL	BYTASC
	LD	A,(IX+0)
	CALL	BYTASC
	INC	IX
	INC	IX
	LD	A,' '
	LD	(HL),A
	INC	HL
	DJNZ	DSREG1
;
; DISPLAY THE FLAGS
;
	LD	A,(TMPAF)	;GET THE FLAGS AND
	CALL	BITASC	;SHOW THEM AS BITS

SZCRLF CALL  BCRLF
	LD	A,0
	LD	(HL),A	;TERMINATE THE STRING
	RET
;-----------------------------------------
; PRINT AN-INLINE, ZERO TERMINATED STRING
;-----------------------------------------
; PUT THE STRING IN THE CODE LIKE THE EXAMPLE BELOW
; THE ROUTINE SENDS THE STRING FROM THE RETURN ADDRESS,
; (THE ADDRESS PUT ON THE STACK AS THE RETURN ADDRESS FROM THE 'CALL PRNTSZ') TO THE ZERO TERMINATOR.
; THEN JUMPS TO THE 'NEXT INSTRUCTION ADDRESS' (AFTER THE ZERO TERMINATOR) TO RESUME THE PROGRAM. 
;
;      CALL PRNTSZ
;      .DB  "STRING TO PRINT",0
;      NEXT INSTRUCTION
;
PRNTSZ	
	POP	HL	;RETURN ADDRESS IS START OF STRING
PRTSZ1	
	LD	A,(HL)	;GET CHARACTER
	OR	A
	JP	Z,PRTSZ2	;RETURN IF CHAR = 0
	CALL	TXBUF	;SEND IT
	INC	HL	;POINT TO NEXT CHARACTER
	JR	PRTSZ1	;AND DO IT AGAIN
PRTSZ2	INC	HL
	JP	(HL)	;RETURN TO ADDRESS AFTER ZERO TERMINATOR
;----------------------------------------------
; MC6850 INTERRUPT DRIVEN BUFFERED SERIAL COMMS
;----------------------------------------------
;
;CLOCK DIVISOR
;
MRESET	.EQU  03H	;MASTER RESET THE ACIA
DIV0	.EQU  00H	;CLOCK/1
DIV16	.EQU  01H	;CLOCK/16
DIV64	.EQU  02H	;CLOCK/64
;---------------------
; COMMUNICATION FORMAT
;---------------------
F7E2	.EQU	00H	;7 DATA BITS, EVEN PARITY, 2 STOP BITS (1+7+1+2= 11 BITS)
F7O2	.EQU	04H	;7 DATA BITS, ODD PARITY, 2 STOP BITS (1+7+1+2= 11 BITS)
F7E1	.EQU	08H	;7 DATA BITS, EVEN PARITY, 1 STOP BIT (1+7+1+1= 10 BITS)
F7O1	.EQU	0CH	;7 DATA BITS, ODD PARITY, 1 STOP BIT (1+7+1+1= 10 BITS)
F8N2	.EQU	10H	;8 DATA BITS, NO PARITY, 2 STOP BITS (1+8+0+2= 11 BITS)
F8N1	.EQU	14H	;8 DATA BITS, NO PARITY, 1 STOP BIT (1+8+0+1= 10 BITS)
F8E1	.EQU	18H	;8 DATA BITS, EVEN PARITY, 1 STOP BIT (1+8+1+1= 11 BITS)
F8O1	.EQU	1CH	;8 DATA BITS, ODD PARITY,1 STOP BIT (1+8+1+1= 11 BITS)
;--------------------
; TRANSMITTER CONTROL
;--------------------
RTSLID .EQU	00H	;RTS LOW, TRANSMIT INTERRUPT DISABLED
RTSLIE .EQU	20H	;RTS LOW, TRANSMIT INTERRUPT ENABLED
RTSHID .EQU	40H	;RTS HIGH, TRANSMIT INTERRUPT DISABLED
RTSLIDB .EQU  60H	;RTS LOW, TRANSMIT INTERRUPT DISABLED AND 'BREAK' TRANSMITTED
;
; RECEIVER INTERRUPT
;
RIE	.EQU	80H	;RECEIVER INTERRUPT ENABLED
;---------------------
; STATUS REGISTER BITS
;---------------------
RDRF	.EQU	0	;RECEIVE DATA REGISTER FULL
TDRE	.EQU	1	;TRANSMIT DATA REGISTER EMPTY
DCD	.EQU	2	;DATA CARRIER DETECT
CTS	.EQU	3	;CLEAR TO SEND
FE	.EQU	4	;FRAMING ERROR
OVRN	.EQU	5	;OVERRUN
PE	.EQU	6	;PARITY ERROR
IRQ	.EQU	7	;INTERRUPT REQUEST
;-------------------------------
;INITIALISE THE ACIA AND BUFFERS
;-------------------------------
SERINIT
	CALL	SERRST
	CALL	SERVEC
	CALL	SEREN
	RET
;RESET THE ACIA
SERRST
	LD	A,MRESET
	OUT	(CONTROL),A	;RESET THE ACIA
	RET
; POINT THE INTERRUPT VECTOR AT THE SERIAL INTERRUPT ROUTINE
SERVEC
	LD	HL,SERISR
	LD	(RST38),HL
	RET
;INITIALISE THE ACIA AND SERIAL BUFFERS
SEREN
;
;INITIALISE THE SERIAL BUFFERS
;
	CALL	TXFLUSH
	CALL	RXFLUSH
;
; INITIALISE THE ACIA; 8 BIT WORD, NO PARITY 2 STOP, DIVIDE BY 64 FOR 115200 BAUD ( 7.3728 MHZ CRYSTAL)
; ENABLE THE RECEIVE INTERRUPT
; DISABLE THE TRANSMIT INTERRUPT UNTIL WE HAVE CHARACTERS TO SEND
;
	LD	A,RTSLID+F8N2+DIV64+RIE
	OUT	(CONTROL),A
	RET
;--------------------------------
;ANY CHARS IN THE RECEIVE BUFFER?
;--------------------------------
ANYCHR	DI
	LD	A,(RXCOUNT)	;GET THE RECEIVED CHAR COUNT
	OR	A	;SET THE FLAGS
	EI
	RET
;---------------------
;FLUSH TRANSMIT BUFFER
;---------------------
; CLEAR THE POINTERS TO EMPTY THE BUFFER
TXFLUSH	DI
	XOR	A
	LD	(TXHEAD),A
	LD	(TXTAIL),A	;HEAD = TAIL = BUFFER IS EMPTY
	LD	(TXCOUNT),A	;CLEAR THE CHARACTER COUNT
	EI
	RET
;--------------------
;FLUSH RECEIVE BUFFER
;--------------------
; CLEAR THE POINTERS TO EMPTY THE BUFFER
RXFLUSH	DI
	XOR	A
	LD	(RXHEAD),A
	LD	(RXTAIL),A	;HEAD = TAIL = BUFFER IS EMPTY
	LD	(RXCOUNT),A	;CLEAR THE CHARACTER COUNT
	EI
	RET
;---------------------------------------
; PUT A CHARACTER IN THE TRANSMIT BUFFER
;---------------------------------------
; ENTRY: CHARACTER IN A
; EXIT: CHARACTER IN A
; IF UNSUCCESSFUL, CARRY SET
; IF SUCCESSFUL, CARRY CLEAR
; NO OTHER REGISTERS MODIFIED
;
TXBUF
	DI	;NO INTERRUPTS WHILE USING THE BUFFER
	PUSH	BC
	PUSH	HL
	LD	B,A	;SAVE BYTE TO TRANSMIT
	LD	A,(TXTAIL)
	LD	L,A
	LD	A,(TXHEAD)	;IF HEAD+1 = TAIL THE BUFFER IS FULL
	INC	A
	CP	L	;IS BUFFER FULL?
	JR	NZ,TXBUF1
	LD	A,B	;GET CHARACTER BACK
	SCF	;SET CARRY FLAG
	JR	TXBUF2	;BUFFER IS FULL, RETURN
;
; PUT THE CHARACTER IN THE BUFFER
;
TXBUF1
	LD	A,(TXCOUNT)
	INC	A
	LD	(TXCOUNT),A	;INCREMENT THE CHARACTER COUNT
;
	LD	HL,TXBUFFER
	LD	A,(TXHEAD)	;HEAD POINTER
	LD	L,A
	INC	A	;HEAD = HEAD + 1
	LD	(TXHEAD),A	;SAVE THE NEW HEAD POINTER
	LD	A,B	;GET CHARACTER
	LD	(HL),A	;PUT THE CHAR AT HEAD
;
; ENABLE THE TRANSMIT INTERRUPT
;
	LD	A,RTSLIE+F8N2+DIV64+RIE
	OUT	(CONTROL),A
	LD	A,B	;CHARACTER SUCCESSFULLY INSERTED
	OR	A	;CLEAR CARRY FLAG
TXBUF2
	POP	HL
	POP	BC
	EI	;RE-ENABLE INTERRUPTS AND RETURN
	RET
;----------------------------------------
; GET A CHARACTER FROM THE RECEIVE BUFFER
;----------------------------------------
; ENTRY: NONE
; EXIT: 
; IF SUCCESSFUL, CARRY CLEAR
; A= RECEIVED CHARACTER
; IF UNSUCCESSFUL, CARRY SET
; A= 0
; NO OTHER REGISTERS MODIFIED
;
RXBUF
	DI	;NO INTERRUPTS WHILE USING THE BUFFER
	PUSH	HL
	LD	A,(RXTAIL)
	LD	L,A
	LD	A,(RXHEAD)	;IF HEAD = TAIL THE BUFFER IS EMPTY
	CP	L	;IS BUFFER EMPTY?
	JR	NZ,RXBUF1
	XOR	A	;BUFFER IS EMPTY - CLEAR A
	SCF	;SET CARRY FLAG
	JR	RXBUF2	;AND RETURN
;
; GET A CHARACTER FROM THE BUFFER
;
RXBUF1
	LD	A,(RXCOUNT)
	DEC	A
	LD	(RXCOUNT),A	;DECREMENT THE CHARACTER COUNT
;
	LD	HL,RXBUFFER
	LD	A,(RXTAIL)	;TAIL POINTER
	LD	L,A
	INC	A	;TAIL = TAIL+1
	LD	(RXTAIL),A	;SAVE THE NEW TAIL POINTER
	LD	A,(HL)	;GET THE CHARACTER FROM TAIL
	OR	A		;CLEAR CARRY FLAG
RXBUF2
	POP	HL
	EI	;RE-ENABLE INTERRUPTS AND RETURN
	RET
;-----------------------
; ACIA INTERRUPT ROUTINE
;-----------------------
SERISR
	IN	A,(STATUS)
	BIT	IRQ,A	;DID THE ACIA CAUSE THE INTERRUPT?
	JR	Z,ISREND	;NOT THE ACIA

	BIT	RDRF,A	;RECEIVE DATA REGISTER FULL?
	JR	NZ,RXINTR

	BIT	TDRE,A	;TRANSMIT DATA REGISTER EMPTY?
	JR	NZ,TXINTR
;
; RESTORE REGISTERS AND RETURN FROM INTERRUPT
; LINK OTHER ISR'S HERE...
ISREND
	EXX
	EX	AF,AF'
	EI
	RET
;
; RECEIVE DATA REGISTER FULL (RDRF) HANDLER
;
RXINTR
	LD	A,(RXTAIL)
	LD	L,A
	LD	A,(RXHEAD)	;IF HEAD+1 = TAIL  THE BUFFER IS FULL
	INC	A
	CP	L	;IS BUFFER FULL?
	JR	NZ,RXINTA
	IN	A,(TDR)	;BUFFER OVERFLOW - JUST READ AND DROP THE CHARACTER
	EXX
	EX	AF,AF'
	EI
	RET
RXINTA
	LD	HL,RXBUFFER
	LD	A,(RXHEAD)	;HEAD POINTER
	LD	L,A
	INC	A	;HEAD = HEAD+1
	LD	(RXHEAD),A		;SAVE THE NEW HEAD POINTER
	IN	A,(TDR)
	LD	(HL),A	;PUT THE CHAR AT HEAD
;
;INCREMENT THE CHARACTER COUNT IN THE RECEIVE BUFFER
;
	LD	A,(RXCOUNT)
	INC	A
	LD	(RXCOUNT),A
	EXX
	EX	AF,AF'
	EI
	RET
;-----------------------------------
;TRANSMIT DATA REGISTER EMPTY (TDRE)
;-----------------------------------
TXINTR
	LD	A,(TXHEAD)
	LD	L,A
	LD	A,(TXTAIL)	;IF TAIL+1 = HEAD  ONLY ONE CHAR IN BUFFER
	INC	A
	CP	L
	JR	NZ,TXINTA
;
;DISABLE THE TRANSMIT INTERRUPT
;
	LD	A,RTSLID+F8N2+DIV64+RIE
	OUT	(CONTROL),A
;
; OUTPUT THE CHARACTER
;
TXINTA
	LD	HL,TXBUFFER
	LD	A,(TXTAIL);TAIL POINTER
	LD	L,A
	INC	A	;TAIL = TAIL + 1
	LD	(TXTAIL),A	;SAVE THE NEW TAIL POINTER
	LD	A,(HL)	;GET THE CHARACTER FROM TAIL
	OUT	(TDR),A
;
;DECREMENT THE CHARACTER COUNT IN THE TRANSMIT BUFFER
;
	LD	A,(TXCOUNT)
	DEC	A
	LD	(TXCOUNT),A
	EXX
	EX	AF,AF'
	EI
	RET
	.END

