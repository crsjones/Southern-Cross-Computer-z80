;--------------------------------------------
; S O U T H E R N   C R O S S   M O N I T O R
;--------------------------------------------
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
; 
;
; VERSION : 1.2  01/93. V1.21 7/93
;
; Version 1.3  02/2003  ADDED SOFTWARE SCANNED KEYBOARD (UNRELEASED)
; Version 1.4  03/2021  MADE INTELH A SYSTEM CALL, REMOVED CANCEL FUNCTIONALITY FROM RXDATA
;
;
;-----------------
; SYSTEM VARIABLES
;-----------------
RAMSRT	EQU	2000H	;START OF USER RAM
RAMEND	EQU	3BFFH	;END OF USER RAM
SYSTEM	EQU	3F00H	;SYSTEM POINTER
;
; BAUD RATE CONSTANTS
;
B300	EQU	0220H	;300 BAUD
B1200	EQU	0080H	;1200 BAUD
B2400	EQU	003FH	;2400 BAUD
B4800	EQU	001BH	;4800 BAUD
B9600	EQU	000BH	;9600 BAUD
;
; I/O PORT ADDRESSES
;
IO0	EQU	80H	;IO PORT 0
IO1	EQU	81H	;IO PORT 1
IO2	EQU	82H	;IO PORT 2
IO3	EQU	83H	;IO PORT 3
DISPLY	EQU	84H	;DISPLAY LATCH
SCAN	EQU	85H	;DISPLAY SCAN LATCH
KEYBUF	EQU	86H	;KEYBOARD BUFFER
IO7	EQU	87H	;SPARE IO ADDRESS
;-------------------------
; MONITOR GLOBAL VARIABLES
;-------------------------
SYSFLG	EQU	3FB3H	;SYSTEM FLAGS  BIT 0=KEYBOARD FLAG
FUNTBL	EQU	3FB4H	;FN TABLE ADDRESS
;
; DALLAS SMARTWATCH REGISTERS
;
CALMDE	EQU	3FB6H	;CALENDAR MODE
SWREG0	EQU	3FB8H	;10THS, 100THS
SWREG1	EQU	3FB9H	;SECONDS
SWREG2	EQU	3FBAH	;MINUTES
SWREG3	EQU	3FBBH	;HOURS
SWREG4	EQU	3FBCH	;DAY
SWREG5	EQU	3FBDH	;DATE
SWREG6	EQU	3FBEH	;MONTH
SWREG7	EQU	3FBFH	;YEAR
;
BAUD	EQU	3FC0H	;BAUD RATE
KEYTIM	EQU	3FC2H	;BEEP DELAY
SPTEMP	EQU	3FC4H	;TEMP SYSTEM CALL SP
;
; BLOCK FUNCTIONS
;
COUNT	EQU	3FC6H	;NUMBER OF BYTES TO MOVE
BLKSRT	EQU	3FC8H	;BLOCK START ADDRESS
BLKEND	EQU	3FCAH	;BLOCK END ADDRESS
BLKDST	EQU	3FCCH	;DESTINATION ADDRESS
;
FUNJMP	EQU	3FCEH	;FN FN KEY JUMP ADDRESS
;
; DISPLAY SCAN REGISTERS
;
DISBUF	EQU	3FD0H	;DISPLAY BUFFER
ONTIM	EQU	3FD6H	;DISPLAY SCAN ON TIME
OFTIM	EQU	3FD7H	;DISPLAY SCAN OFF TIME
;
; MONITOR VARIABLES
;
MODE	EQU	3FD8H	;DISPLAY MODE
ADRESS	EQU	3FDAH	;USER ADDRESS
KEYDEL	EQU	3FDCH	;AUTO INCREMENT DELAY
;
; TEMPORARY REGISTER STORAGE
;
REGPNT	EQU	3FDEH	;REGISTER POINTER
PC_REG	EQU	3FE0H	;PROGRAM COUNTER
AF_REG	EQU	3FE2H	;ACCUMULATOR,FLAG
BC_REG	EQU	3FE4H	;BC REGISTER PAIR
DE_REG	EQU	3FE6H	;DE REGISTER PAIR
HL_REG	EQU	3FE8H	;HL REGISTER PAIR
IX_REG	EQU	3FEAH	;INDEX REGISTER X
IY_REG	EQU	3FECH	;INDEX REGISTER Y
SP_REG	EQU	3FEEH	;STACK POINTER
;
; RESTART JUMP TABLE AND HARWARE TEST
;
RST08	EQU	3FF0H	;RESTART 08H JUMP
RST10	EQU	3FF2H	;RESTART 10H JUMP
RST18	EQU	3FF4H	;RESTART 18H JUMP
RST20	EQU	3FF6H	;RESTART 20H JUMP
RST28	EQU	3FF8H	;RESTART 28H JUMP
RST38	EQU	3FFAH	;INT INTERRUPT JUMP
RST66	EQU	3FFCH	;NMI INTERRUPT JUMP
RAMSUM	EQU	3FFEH	;USER RAM CHECKSUM
DALLAS	EQU	3FFFH	;RAM TEST LOCATION
;----------------
; RESTART VECTORS
;----------------
;
;  RESTART 00H - RST 0
;WHEN POWER IS APPLIED TO THE SOUTHERN CROSS
;THE Z80 STARTS EXECUTING INSTRUCTIONS FROM HERE
;
	ORG	0000H
RSTVEC	JP	RESET
;
; RESTART 08H - RST 1
;
	ORG	0008H
	PUSH	HL
	LD	HL,(RST08)
	JP	(HL)
;
; RESTART 10H - RST 2
;
	ORG	0010H
	PUSH	HL
	LD	HL,(RST10)
	JP	(HL)
;
; RESTART 18H - RST 3
;
	ORG	0018H
	PUSH	HL
	LD	HL,(RST18)
	JP	(HL)
;
; RESTART 20H - RST 4
;
	ORG	0020H
	PUSH	HL
	LD	HL,(RST20)
	JP	(HL)
;
; RESTART 28H - RST 5
;
	ORG	0028H
	PUSH	HL
	LD	HL,(RST28)
	JP	(HL)
;
; RESTART 30H - RST 6 - MONITOR ROUTINES ENTRY POINT
;
	ORG	0030H
RST30	JP	SYSCALL
;
; RESTART 38H - RST 7     BREAKPOINT HANDLER
;IF INTERRUPTS ARE ENABLED,AND AN
;INT OCCURS- FURTHER INTERRUPTS
;ARE DISABLED, THE PROGRAM COUNTER
;IS PUSHED ONTO THE STACK, AND EXECUTION
;STARTS HERE
;
	ORG	0038H
	PUSH	HL
	LD	HL,(RST38)
	JP	(HL)
;
; RESTART 66H NMI VECTOR
; SAME AS ABOVE BUT NMI CANNOT BE DISABLED.
;
	ORG	0066H
	PUSH	HL
	LD	HL,(RST66)
	JP	(HL)
;--------------------
; SYSTEM CALL HANDLER
;--------------------
;CALLS TO BASIC I/O AND OTHER ROUTINES
;WITHIN THE MONITOR HAVE BEEN ASSIGNED
;SYSTEM CALL NUMBERS TO AVOID RE-WRITING
;USER SOFTWARE IF MONITOR ABSOLUTE ADDRESSES
;CHANGE IN SUBSEQUENT MONITORS
;
;ENTRY : C = CALL NUMBER
;SEE ROUTINES FOR ENTRY AND EXIT
;PARAMETERS
;
SYSCALL	DEC	SP
	DEC	SP	;LEAVE SPACE FOR SYSCALL
	LD	(SPTEMP),SP	;POINTS TO SYSCALL LO
	PUSH	AF
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	LD	A,C	;GET CALL NUMBER
	AND	127	;ENSURE IN LIMITS
	SLA	A	;MULTIPLY BY TWO
	LD	H,1	;LOAD JUMP TABLE HIGH BYTE
	LD	L,A	;LOAD INDEX
	LD	A,(HL)
	INC	HL
	LD	D,(HL)	;GET JUMP ADDRESS
	LD	HL,(SPTEMP)	;POINT TO SYSCALL LO
	LD	(HL),A	;PUT SYSCALL LO ON STACK
	INC	HL
	LD	A,D
	LD	(HL),A	;PUT SYSCALL HI ON STACK
	POP	HL
	POP	DE
	POP	AF	;RESTORE REGISTERS
	RET		;JUMPS TO SYSTEM CALL
;-----------------------
; SYSTEM CALL JUMP TABLE
;-----------------------
	ORG	0100H
SYSJMP	.DW	MAIN,VERS
	.DW	DISADD,DISBYT,CLRBUF,SCAND
	.DW	CONBYT,CONVHI,CONVLO
	.DW	SKEYIN,SKEYRL,KEYIN,KEYREL
	.DW	MENU,CHKSUM
	.DW	MUL16,RAND
	.DW	INDEXB,INDEXW
	.DW	MUSIC,TONE,BEEP
	.DW	SKATE
	.DW	TXDATA,RXDATA,ASCHEX
	.DW	WWATCH,RWATCH,ONESEC
	.DW	RLSTEP,DELONE,SCANKEY
    .DW INTELH
;------------------------------
; POWER UP RESET / MANUAL RESET
;------------------------------
	ORG	0200H
;
; WAIT FOR SMART SOCKET
; TO RECOVER FROM POWER DOWN
;
RESET	LD	A,55H
	LD	(DALLAS),A	;WRITE TO RAM
	XOR	A
	OUT	(DISPLY),A	;WRITE NOTHING TO
	OUT	(SCAN),A	;ON BOARD I/O
	IN	A,(KEYBUF)	;TO HELP DEBUGGING
	LD	A,(DALLAS)	;READ FROM RAM
	CP	55H	;IS IT READY?
	JP	NZ,RESET	;KEEP TRYING
;
; LOAD STACK POINTER
;
RESET1	LD	SP,SYSTEM
;
; SET UP RESTART VECTORS
;
	LD	HL,RESET1
	LD	(RST08),HL
	LD	(RST10),HL
	LD	(RST18),HL
	LD	(RST20),HL
	LD	(RST28),HL
	LD	(RST66),HL	;NMI INTERRUPT
	LD	HL,SSTEP
	LD	(RST38),HL	;SINGLE STEPPER
;
; SET INTERRUPT MODE 1 - USE THE AUTOMATED INTERRUPT
;
	IM	1
	EI		;ENABLE INTERRUPTS
;
; PERFORM CHECKSUM ON USER RAM
;
	LD	HL,RAMSRT	;START OF USER RAM
	LD	DE,RAMEND	;END OF USER RAM
	CALL	CHKSUM
	LD	(RAMSUM),A	;RAM CHECKSUM
;
; SET UP DEFAULT VARIABLES
;
	LD	HL,FUNLST
	LD	(FUNTBL),HL	;FUNCTION KEY TABLE
	LD	HL,CANCEL
	LD	(FUNJMP),HL	;FN FN JUMP
	LD	A,00H
	LD	(REGPNT),A	;INIT SINGLE STEPPER
	LD	HL,B4800
	LD	(BAUD),HL	;DEFAULT SERIAL=4800 BAUD
	LD	HL,0100H
	LD	(KEYDEL),HL	;AUTO-INC/DEC DELAY
	LD	A,0AH
	LD	(OFTIM),A	;DISPLAY OFF TIME
	CALL	BEEP
	CALL	BEEP
;
; SOFTWARE KEYBOARD ENCODER
;
	LD	A,00H
	SET	0,A		        ;SOFTWARE SCANNED
	LD	(SYSFLG),A
	LD	A,20H
	LD	(ONTIM),A	    ;DISPLAY ON TIME FOR SOFTWARE KEYBOARD	
	IN  A,(KEYBUF)      ;READ KEY BUFFER
	BIT	5,A		        ;DA HIGH? MUST BE SOFTWARE SCANNING
	JR	NZ,MAIN
;
; HARDWARE KEYBOARD ENCODER
;
	LD	A,(SYSFLG)	    ;GET SYSTEM FLAGS
	RES	0,A		        ;HARDWARE ENCODER
	LD	(SYSFLG),A
	LD	A,20H
	LD	(ONTIM),A	;DISPLAY ON TIME FOR KEYBOARD ENCODER
;-----------------
; SET UP MAIN LOOP
;-----------------
MAIN	LD	SP,SYSTEM	;SET STACK
	LD	HL,RAMSRT
	LD	(ADRESS),HL	;DEFAULT ADDRESS
	LD	A,(MODE)
	OR	80H	;START OFF IN DATA MODE
	LD	(MODE),A
;
; SCAN THE DISPLAYS UNTIL A KEY IS PRESSED
;
MAIN1	CALL	UPDATE
MAIN2	CALL	SKEYIN	;WAIT FOR A KEY
	LD	HL,MENLST	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
	CALL	UPDATE	;UPDATE BUFFER AND
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	MAIN2
;
; MAIN MENU KEY TABLE
;
MENLST	.DB	20
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	HEXKEY,HEXKEY,HEXKEY,HEXKEY
	.DW	FUNKEY,ADDKEY,INCKEY,DECKEY
;---------------------------------------------------
; ENTER HEX KEY AS LEAST SIGNIFICANT ADDRESS OR DATA
;---------------------------------------------------
HEXKEY	CALL	BEEP
	LD	HL,MODE
	BIT	7,(HL)	;ADDR OR DATA MODE?
	JP	Z,HEXKY2	;IN ADDR MODE
;
; IN DATA MODE
;
HEXKY1	LD	HL,(ADRESS)
	SLA	(HL)	;FROM THE CURRENT
	SLA	(HL)	;ADDRESS,MOVE THE
	SLA	(HL)	;LSN TO THE MSN.
	SLA	(HL)	;PUT THE KEY IN
	OR	(HL)	;THE NEW DATA BACK AT
	LD	(HL),A	;THE CURRENT ADDRESS.
	RET
;
; IN ADDRESS MODE
;
HEXKY2	LD	HL,(ADRESS)
	SLA	L	;CURRENT ADDRESS
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(ADRESS),HL	;SAVE CURRENT ADDRESS
	RET
;-------------
; CHANGE MODES
;-------------
ADDKEY	CALL	BEEP
	LD	A,(MODE)
	XOR	80H	;TOGGLE MODE
	LD	(MODE),A
	RET
;------------------
; INCREMENT ADDRESS
;------------------
INCKEY	CALL	BEEP
INCKY1	LD	HL,(ADRESS)
	INC	HL	;INC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)
INCKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF +
	JR	Z,INCKY3	;KEY RELEASED
	CP	32H
	JR	NZ,INCKY3	;NOT INC KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,INCKY2
	JP	INCKY1
INCKY3	RET
;------------------
; DECREMENT ADDRESS
;------------------
DECKEY	CALL	BEEP
DECKY1	LD	HL,(ADRESS)
	DEC	HL	;DEC ADDRESS
	LD	(ADRESS),HL
	CALL	UPDATE
	LD	HL,(KEYDEL)
DECKY2	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A	;RETURN IF
	JR	Z,DECKY3	; - KEY RELEASED
	CP	33H
	JR	NZ,DECKY3	;NOT DEC KEY
	LD	DE,0001H
	SBC	HL,DE
	JP	NC,DECKY2
	JP	DECKY1
DECKY3	RET
;-----------------------------------------
; UPDATE DISPLAY BUFFER TO CURRENT ADDRESS
;-----------------------------------------
UPDATE	LD	HL,(ADRESS)
	CALL	DISADD	;AND DATA, PUT IN
	LD	A,(HL)
	CALL	DISBYT	;DISPLAY BUFFER
;
; IN ADDRESS OR DATA MODE?
;
	LD	HL,MODE
	BIT	7,(HL)	;DATA OR ADDR MODE?
	JP	Z,ADMODE	;ADDRESS MODE
;
; SHOW DATA MODE
;
	LD	HL,DISBUF
	LD	B,2	;IN THE DATA
	JP	SETDP	;DISPLAY
;
; SHOW ADDRESS MODE
;
ADMODE	LD	HL,DISBUF+2
	LD	B,4	;SET THE DP'S IN THE
;
; SET DECIMAL POINT
;
;SET BIT 7 IN THE BYTE POINTED TO BY HL
;
SETDP	SET	7,(HL)	;SET BIT 7
	INC	HL	;POINT TO NEXT BYTE
	DJNZ	SETDP	;MORE BITS TO SET
	RET
;---------------
; VERSION NUMBER
;---------------
;RETURNS THE SOFTWARE VERSION NUMBER
;SHOULD FUTURE MONITORS EXHIBIT DIFFERENCES
;THE VERSION NUMBER CAN BE USED TO COMPENSATE
;
;	ENTRY : NONE
; EXIT : H = ASCII MINOR VERSION NUMBER
;        L = ASCII MAJOR VERSION NUMBER
;
VERS	LD	HL,3134H
	RET
;-------------------------
; ADDRESS > DISPLAY BUFFER
;-------------------------
;CONVERT HL TO SEVEN SEGMENT CODE
;AND PUT IN ADDRESS DISPLAY BUFFER.
;
; ENTRY : HL = ADDRESS TO BE DISPLAYED
;
; EXIT  : NO REGISTERS MODIFIED
;
DISADD	PUSH	AF
	PUSH	HL
	PUSH	 HL
	LD	A,H
	CALL	CONBYT
	LD	(DISBUF+4),HL
	POP	HL
	LD	A,L
	CALL	CONBYT
	LD	(DISBUF+2),HL
	POP	HL
	POP	AF
	RET
;---------------------------
; DATA BYTE > DISPLAY BUFFER
;---------------------------
;CONVERT THE ACC TO SEVEN SEGMENT CODE
;AND PUT IN DATA DISPLAY BUFFER.
;
; ENTRY :  A = DATA DISPLAY BYTE
;
; EXIT  : NO REGISTERS MODIFIED
;
DISBYT	PUSH	HL
	CALL	CONBYT
	LD	(DISBUF),HL
	POP	HL
	RET
;---------------------------------------
; CONVERT BYTE TO 7 SEGMENT DISPLAY CODE
;---------------------------------------
; CONVERTS BYTE IN ACC TO SEVEN SEGMENT CODE
; FOR DISPLAY
; ENTRY : A = BYTE TO BE CONVERTED
; EXIT  : H = HI NYBBLE SEVEN SEGMENT CODE
;         L = LO NYBBLE SEVEN SEGMENT CODE
;         A = NOT MODIFIED
CONBYT	PUSH	AF
	PUSH	AF
	CALL	CONVHI	;CONVERT HI NYBBLE
	LD	H,A
	POP	AF
	CALL	CONVLO	;CONVERT LO NYBBLE
	LD	L,A
	POP	AF
	RET
;---------------------------------------------
; HEXADECIMAL TO SEVEN SEGMENT CODE CONVERSION
;---------------------------------------------
; CONVERTS NYBBLE IN ACC TO SEVEN SEGMENT CODE
; FOR SEVEN SEGMENT DISPLAYS
; CONVHI = CONVERTS HIGH NYBBLE
; CONVLO = CONVERTS LO NYBBLE
;
; ENTRY : A = NYBBLE TO BE CONVERTED
; EXIT  : A = SEVEN SEGMENT CODE
;
CONVHI	RLCA
	RLCA
	RLCA	;MOVE TO LO NYBBLE
	RLCA	;FOR CONVERSION
CONVLO	PUSH	BC
	PUSH	HL
	LD	HL,SEGMNT	;USE THE HEX VALUE
	AND	0FH	;TO INDEX TO THE
	LD	C,A	;THE SEVEN SEGMENT
	LD	B,00H	;CODE FOR THAT VALUE
	ADD	HL,BC	;AND RETURN WITH
	LD	A,(HL)	;CODE IN A
	POP	HL
	POP	BC
	RET
;
; HEXADECIMAL TO 7 SEGMENT DISPLAY CODE TABLE
;
SEGMNT	.DB	3FH,06H,5BH,4FH ;0,1,2,3
	.DB	66H,6DH,7DH,07H ;4,5,6,7
	.DB	7FH,6FH,77H,7CH ;8,9,A,B
	.DB	39H,5EH,79H,71H ;C,D,E,F
;-------------
; SCAN DISPLAY
;-------------
;AS THE DISPLAYS ARE MULTIPLEXED, THE DATA FOR EACH
;DISPLAY MUST BE LATCHED INTO THE DISPLAY SEGMENT
;LATCH IN TURN AND THE CORRESPONDING BIT IN THE DISPLAY
;SCAN LATCH TURNED ON TO DISPLAY THE DATA.
;TWO SHORT DELAYS ARE USED TO ADJUST THE DUTY
;CYCLE AND HENCE DISPLAY BRIGHTNESS.
;
; ENTRY : NONE
; EXIT  : NO REGISTERS MODIFIED
;
SCAND   PUSH    AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	HL,DISBUF+5
	LD	C,20H
SCAND1	LD	A,(HL)
	OUT	(DISPLY),A	;OUTPUT CHARACTER
	LD	A,C
	OUT	(SCAN),A	;TURN ON DISPLAY
	LD	A,(ONTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST ON TIME
SCAND2	DJNZ	SCAND2	;OF DISPLAY
	LD	A,B	;B IS NOW CLEAR, USE
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	LD	A,(OFTIM)	;DO A SHORT DELAY
	LD	B,A	;TO ADJUST OFF TIME
SCAND3	DJNZ	SCAND3	;OF DISPLAY
	DEC	HL	;POINT TO NEXT
	RRC	C	;ELEMENT IN BUFFER
	JR	NC,SCAND1	;DISPLAY NEXT ELEMENT
	LD	A,B	;B IS NOW CLEAR, USE
	OUT	(SCAN),A	;IT TO TURN OFF SCAN
	OUT	(DISPLY),A	;AND CLEAR DISPLAY LATCH
	POP	HL
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;---------------------
; CLEAR DISPLAY BUFFER
;---------------------
CLRBUF	PUSH	HL
	PUSH	BC
	LD	HL,DISBUF
	LD	B,6
CLRBF1	LD	(HL),00H	;PUT ZERO IN 6
	INC	HL	;LOCATIONS POINTED
	DJNZ	CLRBF1	;TO BY HL
	POP	BC
	POP	HL
	RET
;--------------
; SCAN KEYBOARD
;--------------
; USE DISPLAY SCAN DRIVERS FOR COLUMNS
; AND KEYBOARD BUFFER AS ROWS.
; MAKE EACH DATA LINE HIGH IN TURN AND CHECK
; IF EACH INDIVIDUAL PUSHBUTTON IS PRESSED.
;
; NEW ROUTINE VERSION 1.3
;
; ENTRY : NONE
; EXIT  : A = 00H IF NO KEY DETECTED
;         A = DETECTED KEY WITH BIT 5 SET
;         BIT 5 USED AS DATA AVAILABLE LIKE 74C922 KEYBOARD ENCODER
SCANKEY PUSH    BC
	PUSH    DE              ;SAVE REGISTERS
	PUSH	HL
	LD	A,(SYSFLG)
	BIT	0,A
	JR	NZ,SCANKY1
	IN	A,(KEYBUF)	;READ HARDWARE ENCODER
	AND	3FH		;STRIP UNUSED BITS
	JR	SCANKY7		;EXIT
;
; SOFTWARE SCAN KEYBOARD
;
SCANKY1	LD      A,00H
	OUT     (DISPLY),A      ;CLEAR DISPLAY LATCH
	LD      B,A		;KEY
	LD	D,A		;COUNT
	LD      E,01H           ;MASK
SCANKY2 LD      C,08H           ;SCAN
SCANKY3 LD      A,C
	OUT     (SCAN),A        ;OUTPUT SCAN
	NOP
	NOP
	NOP
	IN      A,(KEYBUF)      ;READ KEY BUFFER
	AND     E               ;MASK 
	JR      Z,SCANKY4       ;KEY NOT DETECTED
	INC	D
	LD	L,B		;SAVE KEY
;
; END OF ROWS?
;
SCANKY4 INC     B               ;NEXT KEY
	SRA     C               ;SHIFT SCAN RIGHT
	JR      NC,SCANKY3      ;NEXT ROW
;
; END OF COLUMNS?
;
	SLA     E               ;SHIFT MASK LEFT
	BIT     5,E             ;END OF KEYSCAN?
	JR      Z,SCANKY2	;NEXT COLUMN
;
; END OF SCAN
;
	LD	A,D
	CP	00H
	JR	Z,SCANKY6	;NO KEY PRESSED
	CP	01H
	JR	NZ,SCANKY1	;MORE THAN ONE KEY PRESSED
;
; ONE KEY DETECTED
;
	LD	A,00H
	OUT	(SCAN),A	;CLEAR SCAN REG
	LD	A,L		;RETURN KEY IN A
	SET	5,A		;SET DATA AVAILABLE FLAG
	JR	SCANKY7
;
; NO KEY
;	
SCANKY6	LD	A,00H
	OUT	(SCAN),A	;CLEAR SCAN REG
SCANKY7 POP	HL
	POP     DE
	POP     BC
	RET
;-----------------------------
; SCAN DISPLAY UNTIL KEY PRESS
;-----------------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
SKEYIN	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A	;DA  HIGH?
	JR	Z,SKEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
; ENTRY : NONE
; EXIT  : NONE
;
SKEYRL	PUSH	AF
SKEYL1	CALL	SCAND	;SCAN DISPLAY
	CALL	SCANKEY
	BIT	5,A	;DA LOW?
	JR	NZ,SKEYL1	;KEY NOT RELEASED
	POP	AF
	RET
;-------------------
; WAIT FOR KEY PRESS
;-------------------
; ENTRY : NONE
; EXIT  : A = KEY VALUE 00H TO 1FH
;         FLAG REGISTER MODIFIED
;
KEYIN	CALL	SCANKEY
	BIT	5,A
	JR	Z,KEYIN	;NO KEY PRESS
	AND	1FH	;STRIP UNUSED BITS
	RET
;---------------------
; WAIT FOR KEY RELEASE
;---------------------
; ENTRY : NONE
; EXIT  : NONE
;
KEYREL	PUSH	AF
KEYRL1  CALL	SCANKEY
	BIT	5,A
	JR	NZ,KEYRL1
	POP	AF
	RET
;-----------------
; KEY MENU HANDLER
;-----------------
; COMPARES ACC AGAINST TABLE OF ELEMENTS,
; IF FOUND JUMP TO ADDRESS CORRESPONDING TO
; THAT ELEMENT, RETURNS IF ELEMENT NOT FOUND.
; ENTRY :  A = ELEMENT TO LOOK FOR
;         HL = POINTS TO TABLE
; EXIT  :  ELEMENT NOT FOUND
;           HL HOLDS ADDRESS OF LAST ELEMENT
;          ELEMENT FOUND
;           CONTROL PASSES TO JUMP ADDRESS WITH
;          RETURN ADDRESS OF MENU CALL ON STACK
;
MENU	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
	PUSH	HL	;CALCULATE ADDRESS
	LD	D,00H	;OF THE JUMP TABLE BY
	LD	E,(HL)	;ADDING THE INDEX TO
	INC	HL	;THE ELEMENTS
	ADD	HL,DE	;TO THE ADDR OF THE
	LD	D,H	;TABLE
	LD	E,L
	POP	HL
	LD	B,(HL)	;GET NUMBER OF ENTRIES
	INC	HL	;POINT TO LIST OF ENTRIES
MENU1	CP	(HL)	;COMPARE WITH ENTRY
	JR	Z,MENU2	;FOUND VALUE IN TABLE
	INC	HL	;NEXT ENTRY IN LIST
	INC	DE	;NEXT ENTRY IN
	INC	DE	;JUMP TABLE
	DJNZ	MENU1	;CHECK MORE ENTRIES
	POP	DE
	POP	BC
	POP	AF
	RET	;NOT IN TABLE
;
; FOUND ELEMENT IN THE TABLE
; PASS CONTROL TO THE JUMP HANDLER
;
MENU2	LD	A,(DE)	;GET THE JUMP ADDR
	LD	L,A	;FROM THE TABLE
	INC	DE	;AND JUMP TO
	LD	A,(DE)	;THE JUMP ADDRESS
	LD	H,A	;FOR THAT ENTRY
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	JP	(HL)
;-------------------
; CALCULATE CHECKSUM
;-------------------
;CALCULATES CHECKSUM BETWEEN START AND END (INCLUSIVE)
;
; ENTRY : HL = START OF BLOCK TO SUM
;         DE = END OF BLOCK TO SUM
; EXIT  : A =  CHECKSUM
;         FLAG REGISTER MODIFIED
;
CHKSUM	PUSH	HL
	PUSH	DE
	INC	DE	;END OF BLOCK+1
	XOR	A	;CLEAR CHECKSUM
CHKSM1	ADD	A,(HL)	;COMPUTE CHEKSUM
	INC	HL	;POINT TO NEXT ELEMENT
	AND	A	;SET CARRY
	PUSH	HL
	SBC	HL,DE	;SUBTRACT
	POP	HL
	JR	C,CHKSM1	;MORE ELEMENTS
	POP	DE
	POP	HL
	RET
;--------------------------
; ACCESS BYTE LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS BYTE LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF ELEMENT A
;
INDEXB	PUSH	DE
	LD	E,A	;USE DE AS INDEX
	LD	D,0	;TO ELEMENT IN TABLE
	ADD	HL,DE	;BY ADDING TO HL
	POP	DE
	RET
;--------------------------
; ACCESS WORD LOOK UP TABLE
;--------------------------
; USE 8 BIT INDEX TO ACCESS WORD LOOK
; UP TABLE
; ENTRY :  A = NUMBER OF ELEMENT IN TABLE
;         HL = ADDRESS OF LOOK UP TABLE
; EXIT : HL = ADDRESS OF 2 BYTE ELEMENT A
;
INDEXW	PUSH	DE
	LD	E,A
	SLA	E	;MULTIPLY BY TWO
	LD	D,0
	ADD	HL,DE
	POP	DE
	RET
;-------------------------------
; GENERATE A QUASI-RANDOM NUMBER
;-------------------------------
; GENERATE AN 16 BIT RANDOM NUMBER
; USING LINEAR CONGRUENTIAL METHOD.
;     Rn+1 = (aRn+c) MOD m
; REFRESH REGISTER USED FOR Rn AND c
;	ENTRY : NONE
;	EXIT  : HL = RANDOM WORD
;	NO REGISTERS MODIFIED
;
RAND	PUSH	AF
	PUSH	BC
	PUSH	DE	;SAVE REGISTERS
;
; CALCULATE aRn
;
	LD	A,R	;MULTIPLY RANDOM NUMBER
	LD	E,A	;(Rn) BY
	LD	D,0
	LD	HL,0548H	;CONSTANT (a)
	CALL	MUL16
;
; CALCULATE aRn+c
;
	LD	A,R	;ADD IT TO ANOTHER
	LD	B,0	;READ OF THE
	LD	C,A	;THE REFRESH
	ADD	HL,BC	;REGISTER (c)
	POP	DE
	POP	BC
	POP	AF	;RESTORE REGISTERS
	RET
;----------------------
; 16 BIT MULTIPLICATION
;----------------------
;16 BIT MULTIPLY
; ENTRY : HL = MULTIPLICAND (MPD)
;         DE = MULTIPLIER (MPR)
; EXIT : HL = RESULT
;SEE ZAKS 'PROGRAMMING THE Z80'
;
MUL16	PUSH	AF
	PUSH	BC
	LD	C,H	;MPR(H)
	LD	A,L	;MPR(L)
	LD	B,16	;BIT COUNTER
	LD	HL,0	;CLEAR RESULT
MULT	SRL	C	;MPR (H)
	RRA	;MPR (L)
	JR	NC,MULT1	;TEST CARRY
	ADD	HL,DE	;ADD MPD TO RESULT
MULT1	EX	DE,HL
	ADD	HL,HL	;DOUBLE -SHIFT MPD LEFT
	EX	DE,HL
	DJNZ	MULT	;DONE?
	POP	BC
	POP	AF
	RET
;----------------
; MUSIC SEQUENCER
;----------------
; SEQUENCES THROUGH A TABLE OF NOTES
; 1EH = REPEAT TUNE UNTIL RESET
; 1FH = PLAY ONCE AND RETURN
; ENTRY : HL = ADDRESS OF NOTE TABLE
; EXIT : NO REGISTERS MODIFIED
MUSIC	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF MUSIC
;
; PLAY EACH NOTE IN TURN
;
STEP	LD	A,(DE)	;GET ELEMENT FROM TABLE
	AND	1FH	;STRIP UNUSED BITS
;
; IF ELEMENT IS 00H PAUSE FOR A WHILE
;
	CP	00H
	JP	NZ,STEP1
	LD	BC,1000H
PAUSE	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,PAUSE	;LOOP UNTIL DE = 0
	INC	DE	;POINT TO NEXT ELEMENT
	JP	STEP
;
; IF ELEMENT IS 1EH REPEAT TUNE
;
STEP1	CP	1EH
	JP	NZ,STEP2
	POP	DE	;GET TABLE ADDRESS BACK
	PUSH	DE	;SAVE IT FOR LATER
	JP	STEP
;
; IF ELEMENT IS 1FH RETURN
;
STEP2	CP	1FH	;END OF TUNE TABLE?
	JP	NZ,STEP3
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
;NOW PLAY THE NOTE
;
STEP3	LD	B,A	;SAVE ELEMENT IN B
	LD	HL,PERIOD	;POINT TO PERIOD/2 TABLE
	CALL	INDEXB	;GET PERIOD/2
	LD	A,(HL)	;GET ELEMENT
	PUSH	AF	;SAVE FOR LATER
	LD	A,B	;GET ELEMENT BACK IN A
	LD	HL,LENGTH	;POINT TO DURATION/2 TABLE
	CALL	INDEXB	;GET DURATION/2
	LD	A,(HL)	;GET ELEMENT
	LD	L,A
	LD	H,0	;HL = DURATION/2
	POP	AF
	CALL	TONE	;DO NOTE ROUTINE
	INC	DE
	JP	STEP	;STEP TO NEXT ELEMENT
;
; PERIOD/2 OF NOTE
;
PERIOD	.DB	8CH,83H,7CH,75H,70H,67H,62H,5CH
	.DB	57H,52H,4EH,48H,45H,41H,3CH,39H
	.DB	36H,32H,2FH,2CH,2AH,27H,25H,23H
;
; NOTE DURATION/2
;
LENGTH	.DB	19H,1AH,1CH,1DH,1EH,20H,23H,25H
	.DB	27H,29H,2CH,2EH,31H,33H,37H,3AH
	.DB	3DH,41H,45H,49H,4DH,52H,57H,5CH
	.DB	10H
;--------------
; OUTPUT A TONE
;--------------
;
; ENTRY : A = PERIOD/2 OF NOTE
;         HL = DURATION/2 OF NOTE
; EXIT NO REGISTERS MODIFIED
TONE	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	C,A
	ADD	HL,HL	;DOUBLE DURATION
	XOR	A
TONE1	XOR	80H	;TOGGLE SPEAKER BIT
	OUT	(SCAN),A	;OUTPUT SPEAKER BIT
	LD	B,C
TONE2	PUSH	BC
	LD	B,02H
TONE3	DJNZ	TONE3	;DELAY FOR PERIOD/2
	POP	BC
	DJNZ	TONE2	; DELAY FOR PERIOD/2
	SBC	HL,DE	;END OF NOTE?
	JR	NZ,TONE1	;DO AGAIN
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;---------------
; KEY ENTRY BEEP
;---------------
BEEP	PUSH	HL
	PUSH	AF
	LD	HL,MODE
	BIT	6,(HL)	;BEEP ENABLED?
	JR	Z,BEEP2	;BEEP IS ENABLED
;
; DO KEYPRESS DELAY
;
	PUSH	DE	;DO A SHORT
	LD	DE,0001H	;DELAY TO PREVENT
	LD	HL,(KEYTIM)	;RECOGNITION
BEEP1	SBC	HL,DE	;OF DOUBLE
	JR	NC,BEEP1	;KEY STROKES
	POP     DE
	JR	BEEP3
;
; OUTPUT KEYPRESS TONES
;
BEEP2	LD	A,24H
	LD	HL,0030H
	CALL	TONE	;DO FIRST TONE
	LD	A,0EH
	LD	HL,0050H
	CALL	TONE	;DO SECOND TONE
BEEP3	POP	AF
	POP	HL
	RET
;----------------------------------------
; BREAKPOINT AND SINGLE STEPPING ROUTINES
;----------------------------------------
;DISPLAYS AND MODIFIES REGISTERS AFTER BREAKPOINT
; (RST 38H) OR SINGLE STEP INTERRUPT (IF HARDWARE
; ATTACHED).
;INSERT RST 38H (FFH) IN PROGRAM TO EXAMINE
; AND MODIFY REGISTERS.
;
SSTEP	POP	HL	;GET HL BACK
	PUSH	AF	;SAVE AF FOR LATER
	LD	(HL_REG),HL
	LD	(DE_REG),DE
	LD	(BC_REG),BC
	LD	(IX_REG),IX
	LD	(IY_REG),IY	;SAVE REGISTERS
	POP	HL	;GET AF BACK
	LD	(AF_REG),HL	;SAVE AF
	POP	HL	;GET PC RETURN ADDRESS
	LD	(PC_REG),HL	;SAVE PC
	LD	(SP_REG),SP	;SAVE STACK POINTER
;
; STEP THROUGH,DISPLAY AND EDIT REGISTERS
;
	CALL	BEEP
	LD	A,(REGPNT)	;GET CURRENT REG
	AND	7	;MAKE SURE IN LIMITS
	LD	(REGPNT),A	;SAVE IT
DISREG	CALL	SETREG	;SET UP DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR A KEY
	CALL	SKEYIN	;WAIT FOR KEY RELEASE
	LD	HL,REGTBL	;HANDLE THE KEY
	CALL	MENU	;AND UPDATE DISPLAY
	JP	DISREG	;BEFORE RETURNING TO LOOP
;
; REGISTER DISPLAY KEY TABLE
;
REGTBL	.DB	14H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H,12H,13H
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	REGKEY,REGKEY,REGKEY,REGKEY
	.DW	RETMON,RETPGM,INCSTP,DECSTP
;
; REGISTER NAME CHARACTERS
;
REGNAM	.DW	7339H
	.DW	7771H,7C39H,5E79H
	.DW	7438H,0676H,066EH
	.DW	6D73H
;--------------
; EDIT REGISTER
;--------------
REGKEY	CALL	BEEP
	PUSH	AF	;SAVE KEY FOR LATER
	LD	A,(REGPNT)
;
; EDIT REGISTER
;
	LD	HL,PC_REG
	CALL	INDEXW
	LD	C,(HL)
	INC	HL
	LD	B,(HL)	;GET REG CONTENTS
	SLA	C
	RL	B
	SLA	C
	RL	B
	SLA	C
	RL	B	;SHIFT REGISTER
	SLA	C	;FOUR BITS
	RL	B	;LEFT AND
	POP	AF	;PUT THE KEY
	OR	C	;INTO THE LSN
	LD	C,A	;AND PUT THE
	LD	(HL),B	;REGISTER BACK
	DEC	HL	;WHERE IT BELONGS
	LD	(HL),C
	RET
;------------------
; RETURN TO MONITOR
;------------------
RETMON	CALL	BEEP
	CALL	SKEYRL
	EI	;ENABLE INTERRUPTS AGAIN
	JP	MAIN
;------------------
; RETURN TO PROGRAM
;------------------
RETPGM	LD	SP,(SP_REG)	;PUT STACK POINTER BACK
	LD	HL,(PC_REG)	;PUT RETURN
	PUSH	HL	;ADDRESS BACK ON STACK
	LD	HL,(AF_REG)
	PUSH	HL	;SAVE AF REG FOR LATER
	LD	IY,(IY_REG)
	LD	IX,(IX_REG)
	LD	BC,(BC_REG)
	LD	DE,(DE_REG)	;RESTORE REGISTERS
	POP	AF	;RESTORE AF
	LD	HL,(HL_REG)	;RETORE HL
	EI	;ENABLE INTERRUPTS
	RET	;AND RETURN TO PROGRAM
;----------------------
; DISPLAY NEXT REGISTER
;----------------------
INCSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	A,7	;END OF REG TABLE?
	JP	Z,INCSP1
	INC	A
	LD	(REGPNT),A
	RET
INCSP1	XOR	A
	LD	(REGPNT),A
	RET
;--------------------------
; DISPLAY PREVIOUS REGISTER
;--------------------------
DECSTP	CALL	BEEP
	LD	A,(REGPNT)
	CP	A,0	;START OF REG TABLE?
	JP	Z,DECSP1
	DEC	A
	LD	(REGPNT),A
	RET
DECSP1	LD	A,7
	LD	(REGPNT),A
	RET
;-----------------
; DISPLAY REGISTER
;-----------------
SETREG	LD	A,(REGPNT)
	LD	HL,PC_REG	;START OF TABLE
	CALL	INDEXW	;GET ELEMENT ADDRESS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL	;LOAD REGISTER CONTENTS
	CALL	DISADD
;
; DISPLAY REGISTER NAME
;
	LD	HL,REGNAM
	CALL	INDEXW
	LD	A,(HL)
	LD	(DISBUF+0),A
	INC	HL
	LD	A,(HL)
	LD	(DISBUF+1),A
	RET
;------------------
; FUNCTION KEY MENU
;------------------
; WHEN THE FN KEY IS PRESSED, Fn IS DISPLAYED IN THE
; DATA DISPLAYS, THE CURRENT ADDRESS REMAINS IN THE
; ADDRESS DISPLAYS THE PROGRAM THEN WAITS FOR A
; KEYPRESS WHICH WILL SELECT 1 OF 16 ROUTINES.
;
FUNKEY	POP	HL	;REMOVE RETURN ADDRESS
	CALL	BEEP
FUNKY1	LD	HL,(ADRESS)
	CALL	DISADD	;DISP ADDR TO REMOVE DP'S
	LD	HL,7154H
	LD	(DISBUF),HL	;DISPLAY FN
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
FUNKY2	CALL	SKEYIN
	LD	HL,(FUNTBL)	;USE THE MENU HANDLER
	CALL	MENU	;ROUTINE FOR EACH KEY
	JP	FUNKY2	;TRY AGAIN
;
; RETURN TO MAIN
;
CANCEL	CALL	BEEP
CANCL1	CALL	UPDATE	;UPDATE DISPLAY BUFFER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	POP	HL	;REMOVE MENU RETURN
	JP	MAIN2
;
; FUNCTION MENU KEY TABLE
;
FUNLST	.DB	11H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H
	.DW	GOEXEC,INTELFN,ADDRA,ADDRB
	.DW	BLKMVE,BLKSUM,BRANCH,TRACE
	.DW	PLAY1,PLAY2,PLAY3,SWBEEP
	.DW	SECRET,RELSQR,SCOPE,TIME
	.DW	FUNFUN
;--------------------------
; JUMP TO FUNCTION FUNCTION
;--------------------------
FUNFUN	LD	HL,(FUNJMP)
	JP	(HL)
;------------------------------------------
; FUNCTION 0 - EXECUTE FROM CURRENT ADDRESS
;------------------------------------------
GOEXEC	CALL	BEEP
	CALL	KEYREL
	POP	HL	;REMOVE EXEC RETURN
	LD	HL,(ADRESS)
	JP	(HL)	;START EXECUCTION
;------------------------------------
; FUNCTION 1 RECEIVE INTEL HEX FORMAT
;------------------------------------
INTELFN	CALL	BEEP
	    CALL	KEYREL
        CALL  INTELH
        JP    NZ,BLKMV1      ;SHOW THE ERROR 
        JP    CANCEL         ;JUST RETURN IF ALL OK
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTELH	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
;
; WAIT FOR RECORD MARK
;
INTEL1	XOR	A
	LD	(IX+3),A	;CLEAR CHECKSUM
	CALL	RXDATA	;WAIT FOR THE RECORD MARK
	CP	':'	;TO BE TRANSMITTED
	JR	NZ,INTEL1	;NOT RECORD MARK
;
; GET RECORD LENGTH
;
	CALL	GETBYT
	LD	(IX+0),A	;NUMBER OF DATA BYTES
;
; GET ADDRESS FIELD
;
	CALL	GETBYT
	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
	CALL	GETBYT
	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
;
; GET RECORD TYPE
;
	CALL	GETBYT
	JR	NZ,INTEL4	;END OF FILE RECORD
;
; READ IN THE DATA
;
	LD	B,(IX+0)	;NUMBER OF DATA BYTES
	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE

INTEL2	CALL	GETBYT	;GET DATA BYTE
	LD	(HL),A	;STORE DATA BYTE
	INC	HL
	DJNZ	INTEL2	;LOAD MORE BYTES
;
; GET CHECKSUM AND COMPARE
;
	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE RECORD CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
    RET             ;NZ=CHECKSUM ERROR
;
; END OF FILE RECORD
;
INTEL4	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE EOF CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	RET  	    ;NZ=CHECKSUM ERROR
;--------------------------
; GET BYTE FROM SERIAL PORT
;--------------------------
GETBYT	PUSH	BC
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT1
	ADD	A,09H
GETBT1	AND	0FH
	SLA 	A
	SLA	A
	SLA	A
	SLA	A
	LD	C,A
;
; GET LOW NYBBLE
;
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT2
	ADD	A,09H
GETBT2	AND	0FH
	OR	C
	LD	B,A
	ADD	A,(IX+3)
	LD	(IX+3),A	;ADD TO CHECKSUM
	LD	A,B
	AND	A	;CLEAR CARRY
    POP	BC
	RET
;-------------------------------
; CONVERT ASCII CHARACTER TO HEX
;-------------------------------
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : A= HEX 0-F IN LSN
; A AND F REGISTERS MODIFIED
;
ASCHEX	BIT	6,A
	JR	Z,ASCHX1
	ADD	A,09H
ASCHX1	AND	0FH
	RET
;------------------------
; SERIAL TRANSMIT ROUTINE
;------------------------
;TRANSMIT BYTE SERIALLY ON DOUT
;
; ENTRY : A = BYTE TO TRANSMIT
;  EXIT : NO REGISTERS MODIFIED
;
TXDATA	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(BAUD)
	LD	C,A
;
; TRANSMIT START BIT
;
	XOR	A
	OUT	(SCAN),A
	CALL	BITIME
;
; TRANSMIT DATA
;
	LD	B,08H
	RRC	C
NXTBIT	RRC	C	;SHIFT BITS TO D6,
	LD	A,C	;LSB FIRST AND OUTPUT
	AND	40H	;THEM FOR ONE BIT TIME.
	OUT	(SCAN),A
	CALL	BITIME
	DJNZ	NXTBIT
;
; SEND STOP BITS
;
	LD	A,40H
	OUT	(SCAN),A
	CALL	BITIME
	CALL	BITIME
	POP	HL
	POP	BC
	POP	AF
	RET
;-----------------------
; SERIAL RECEIVE ROUTINE
;-----------------------
;RECEIVE SERIAL BYTE FROM DIN
;
; ENTRY : NONE
;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
;
; REGISTERS MODIFIED A AND F
;
RXDATA	PUSH	BC
	PUSH	HL
;
; WAIT FOR START BIT 
;
RXDAT1 IN	A,(KEYBUF)
	   BIT	7,A
	   JR	NZ,RXDAT1	;NO START BIT
;
; DETECTED START BIT
;
	LD	HL,(BAUD)
	SRL	H
	RR	L 	;DELAY FOR HALF BIT TIME
	CALL 	BITIME
	IN	A,(KEYBUF)
	BIT	7,A
	JR	NZ,RXDAT1	;START BIT NOT VALID
;
; DETECTED VALID START BIT,READ IN DATA
;
	LD	B,08H
RXDAT2	LD	HL,(BAUD)
	CALL	BITIME	;DELAY ONE BIT TIME
	IN	A,(KEYBUF)
	RL	A
	RR	C	;SHIFT BIT INTO DATA REG
	DJNZ	RXDAT2
	LD	A,C
	OR	A	;CLEAR CARRY FLAG
    POP	HL
	POP	BC
	RET
;---------------
; BIT TIME DELAY
;---------------
;DELAY FOR ONE SERIAL BIT TIME
;ENTRY : HL = DELAY TIME
; NO REGISTERS MODIFIED
;
BITIME	PUSH	HL
	PUSH	DE
	LD	DE,0001H
BITIM1	SBC	HL,DE
	JP	NC,BITIM1
	POP	DE
	POP	HL
	RET
;-----------------------------
; FUNCTION 2 - ENTER ADDRESS 1
;-----------------------------
ADDRA	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKSRT),HL	;ADDRESS AS START
	LD	HL,3900H	;ADDRESS
	CALL	SDELAY
	JP	CANCL1
;-----------------------------
; FUNCTION 3 - ENTER ADDRESS 2
;-----------------------------
ADDRB	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKEND),HL	;ADDRESS AS END
	LD	HL,000FH	;ADDRESS
	CALL	SDELAY
	JP	CANCL1
;------------------------
; FUNCTION 4 - BLOCK MOVE
;------------------------
BLKMVE	CALL	BEEP
	LD	HL,(ADRESS)	;COPY CURRENT
	LD	(BLKDST),HL	;ADDRESS AS
	LD	HL,390FH	;DESTINATION
	CALL	SDELAY
;
; CALCULATE NUMBER OF BYTES TO MOVE
;
	LD	HL,(BLKEND)
	LD	DE,(BLKSRT)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE MOVE INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKMV3	;IF OK MOVE BLOCK
;
; SHOW ERROR
;
BLKMV1	LD	HL,0079H	;SHOW ERROR
BLKMV2	CALL	BEEP
	LD	(DISBUF),HL	;AND WAIT
	CALL	SKEYIN	;FOR KEYPRESS
	CALL	BEEP
	CALL	SKEYRL
	JP	CANCL1
;
; MOVE BLOCK
;
BLKMV3	CALL	MOVE
	JP	CANCL1
;-----------
; BLOCK MOVE
;-----------
MOVE	LD	BC,(COUNT)
	LD	HL,(BLKSRT)	;START ADDR
	LD	DE,(BLKDST)	;DESTINATION ADDR
	LDIR
	RET
;-------------------------------
; SCAN DISPLAY UNTIL KEY RELEASE
;-------------------------------
SDELAY	LD	(DISBUF),HL	;SHOW HL
	LD	B,255	;IN DATA DISPLAYS
SDELY1	CALL	SCAND	;UNTIL KEY
	DJNZ SDELY1	;IS RELEASED
	CALL	SKEYRL
	RET
;---------------------------
;FUNCTION 5 - BLOCK CHECKSUM
;---------------------------
BLKSUM	CALL	BEEP
	LD	HL,396DH
	CALL	SDELAY	;SHOW PROMPT
	LD	DE,(BLKSRT)
	LD	HL,(BLKEND)
	AND	A
	SBC	HL,DE
	INC	HL	;MAKE CHECKSUM INCLUSIVE
	LD	(COUNT),HL
	JR	NC,BLKSM1	;IF OK SUM BLOCK
;
; SHOW ERROR
;
	JP	BLKMV1
;
; CALCULATE CHECKSUM
;
BLKSM1	LD	HL,(BLKSRT)
	LD	DE,(BLKEND)
	CALL	CHKSUM	;DO THE CHECKSUM,
	CALL	DISBYT	;DISPLAY
	LD	HL,(COUNT)	;NUMBER OF BYTES
	CALL	DISADD	;SUMMED AND
	CALL	BEEP
	CALL	SKEYIN	;CHECKSUM UNTIL
	CALL	BEEP	;A KEY IS PRESSED
	CALL	SKEYRL
	JP	CANCL1
;----------------------------------------
; FUNCTION 6 - RELATIVE BRANCH CALCULATOR
;----------------------------------------
BRANCH	CALL	BEEP
	LD	HL,507CH
	CALL	SDELAY
	LD	HL,(ADRESS)	;GET CURRENT ADDRESS
	LD	DE,(BLKSRT)
	INC	DE	;POINT TO PC+2
	AND	A
	SBC	HL,DE	;SUBTRACT
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF BACKWARD BRANCH
;
	LD	A,H
	CP	255	;BACKWARD BRANCH?
	JP	NZ,BRNCH1	;CHECK IF FORWARD
;
;CHECK IF WE HAVE BRANCHED BEYOND -128
;
	LD	A,L
	BIT	7,A
	JR	NZ,BRNCH2	;BRANCH IS WITHIN LIMITS
	JP	BLKMV1	;TOO FAR BACK
;
;TEST HIGH BYTE OF RESULT TO
;DETERMINE IF FORWARD BRANCH
;
BRNCH1	CP	0	;FORWARD BRANCH?
	JP	NZ,BLKMV1	;TOO FAR IN ANY DIRECTION
;
; CHECK IF WE HAVE BRANCHED BEYOND +128
;
	LD	A,L
	BIT	7,A
	JP	NZ,BLKMV1	;TOO FAR FORWARD
;
; WITHIN LIMITS PUT IN RAM
; AND SHOW AS CURRENT ADDRESS
;
BRNCH2	LD	HL,(BLKSRT)
	LD	(ADRESS),HL
	LD	(HL),A
	JP	CANCL1
;-----------------------------------------
; FUNCTION 7 - TOGGLE HARDWARE SINGLE STEP
;-----------------------------------------
TRACE	CALL	BEEP
	OUT	(IO7),A	;TOGGLE HARDWARE LATCH
	LD	HL,0070H	;SHOW T
	CALL	SDELAY
	JP	CANCL1
;-------------------------
; FUNCTION 8 - PLAY TUNE 1
;-------------------------
PLAY1	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE1
	CALL	MUSIC
	JP	CANCL1
;-------------------------
; FUNCTION 9 - PLAY TUNE 2
;-------------------------
PLAY2	CALL	BEEP
	CALL	KEYREL
	LD	HL,TUNE2
	CALL	MUSIC
	JP	CANCL1
;------------------------------
; FUNCTION A - PLAY TUNE IN RAM
;------------------------------
PLAY3	CALL	BEEP
	CALL	KEYREL
	LD	HL,(ADRESS)
	CALL	MUSIC
	JP	CANCL1
;-----------------------------
; FUNCTION B - TOGGLE KEY BEEP
;-----------------------------
SWBEEP	CALL	BEEP
	LD	A,(MODE)
	XOR	40H
	LD	(MODE),A
	JP	CANCL1
;
; TUNE 1
;
TUNE1	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,0FH,0AH,0DH,0FH
	.DB	06H,06H,0AH,0DH,06H,0DH,0AH,0DH
	.DB	12H,16H,14H,12H,0FH,11H,12H,0FH
	.DB	0DH,0DH,0DH,0AH,12H,0FH,0DH,0AH
	.DB	08H,06H,08H,0AH,06H,12H,00H,1EH
;
; TUNE 2
;
TUNE2	.DB	0BH,0AH,08H,0AH,0AH,0AH,06H,06H
	.DB	06H,0BH,0AH,08H,0AH,0AH,0AH,0AH
	.DB	0AH,0AH,0BH,0AH,08H,0AH,0AH,0AH
	.DB	06H,06H,06H,0AH,08H,0AH,0DH,0DH
	.DB	0DH,0DH,0DH,00H,0DH,05H,08H,0BH
	.DB	0BH,0BH,06H,06H,06H,0BH,0AH,08H
	.DB	0AH,0AH,0AH,06H,06H,06H,0BH,0AH
	.DB	06H,08H,08H,08H,08H,08H,0AH,0BH
	.DB	0AH,08H,06H,06H,06H,06H,06H,06H
	.DB	00H,00H,00H,1EH
;---------------------------
; FUNCTION C - SECRET NUMBER
;---------------------------
SECRET	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND CLEAR DISPLAY
	CALL	CLRBUF	;BUFFER
	LD	IX,SYSTEM	;USE IX FOR LOCAL VARIABLES
;
; SEPARATE NYBBLES IN RANDOM NUMBER
;
	CALL	RAND
	LD	(IX+11),L
	LD	(IX+12),H	;RANDOM NUMBER
	LD	A,(IX+11)	;SEPARATE THE RANDOM
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+4),L	;FOUR NYBBLES
	LD	(IX+5),H	;TO MAKE CHECKING
	LD	A,(IX+12)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+6),L
	LD	(IX+7),H
	XOR	A
	LD	I,A	;CLEAR NUMBER OF TRIES
	LD	HL,0
	LD	(IX+8),L
	LD	(IX+9),H
	CALL	DISADD	;AND DISPLAY GUESS
;
; SCAN THE KEYBOARD
;
SECRT1	CALL	SKEYIN	;WAIT FOR KEY
	LD	HL,SECNUM
	CALL	MENU	;EXECUTE KEY HANDLER
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	JP	SECRT1
;
; SECRET NUMBER KEY TABLE
;
SECNUM	.DB	12H
	.DB	00H,01H,02H,03H,04H,05H,06H,07H
	.DB	08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
	.DB	10H,11H
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	EDTKEY,EDTKEY,EDTKEY,EDTKEY
	.DW	ENDKEY,CHKKEY
;---------------
; EDIT GUESS KEY
;---------------
EDTKEY	PUSH	AF
	LD	L,(IX+8)
	LD	H,(IX+9)	;GET CURRENT GUESS
	SLA	L
	RL	H	;AND DO A 16 BIT
	SLA	L	;LEFT SHIFT 4 TIMES
	RL	H	;TO MAKE  ROOM
	SLA	L	;FOR THE NEW KEY
	RL	H
	SLA	L
	RL	H
	POP	AF
	OR	L	;IT IN THE LEAST
	LD	L,A	;SIGNIFICANT NYBBLE
	LD	(IX+8),L
	LD	(IX+9),H	;SAVE GUESS
	CALL	DISADD
	CALL	BEEP
	RET
;----------
; QUIT GAME
;----------
ENDKEY	CALL	BEEP	;WAIT FOR KEY RELEASE
	CALL	KEYREL	;AND RETURN TO
	JP	MAIN	;MONITOR
;---------------------------
; SEE IF ITS THE RIGHT GUESS
;---------------------------
CHKKEY	CALL	BEEP
	LD	A,I
	INC	A
	DAA	;INC BCD NO. OF TRIES
;
; BRIEFLY SHOW GUESS NO.
;
	LD	I,A
	CALL	DISBYT
	LD	B,255
CHKKY1	CALL	SCAND
	DJNZ	CHKKY1
;
; SEPARATE GUESS INTO NYBBLES
;
	LD	A,(IX+8)	;GET CURRENT GUESS
	CALL	SPLIT	;NUMBER INTO
	LD	(IX+0),L	;FOUR NYBBLES
	LD	(IX+1),H	;TO MAKE CHECKING
	LD	A,(IX+9)	;AGAINST THE
	CALL	SPLIT	;GUESS EASIER
	LD	(IX+2),L
	LD	(IX+3),H
;
; CHECK FOR CORRECT NUMBER,CORRECT SPOT
;
	XOR	A
	LD	(IX+10),A	;CLEAR RESULT
	LD	HL,SYSTEM+4	;POINT TO RANDOM
	LD	DE,SYSTEM	;POINT TO GUESS
	LD	B,4	;NUMBER OF DIGITS
CHKKY2	LD	A,(HL)	;GET RANDOM
	EX	DE,HL
	CP	(HL)	;SAME AS GUESS?
	JR	NZ,CHKKY4	;NOT SAME
	LD	A,(IX+10)
	ADD	A,10H	;RIGHT POSITION
	LD	(IX+10),A
CHKKY3	INC	HL	;POINT TO NEXT
	EX	DE,HL	;DIGIT POSITION
	INC	HL	;AND GO
	DJNZ	CHKKY2	;CHECK OTHER POSITIONS
	JP	CHKKY8
;
; CHECK IF NUMBER IS THERE
;
CHKKY4	PUSH	BC
	PUSH	HL
	LD	B,4	;CHECK EACH DIGIT
	LD	HL,SYSTEM	;TO SEE IF THIS
CHKKY5	CP	(HL)	;NUMBER IS IN
	INC	HL	;THE WRONG
	JR	NZ,CHKKY6	;POSITION
	LD	A,(IX+10)	;AND UPDATE
	INC	A	;THE RESULT
	LD	(IX+10),A
	JP	CHKKY7
CHKKY6	DJNZ	CHKKY5
CHKKY7	POP	HL
	POP	BC
	JP	CHKKY3	;CHECK NEXT DIGIT
;
; CHECK IF CORRECT
;
CHKKY8	LD	A,(IX+10)
	CP	40H	;IS IT CORRECT?
	JP	Z,CHKKY9	;YES!
	LD	A,(IX+10)	;NOT CORRECT
	CALL	DISBYT	;IN DATA DISPLAYS
	LD	A,I	;WAS THAT THE
	CP	20H	;LAST GUESS?
	RET	NZ	;NO TRY AGAIN
;
; RAN OUT OF TRYS
;
	CALL	CLRBUF	;DISPLAY
	LD	L,(IX+11)
	LD	H,(IX+12)	;THE RANDOM NUMBER
	CALL	DISADD	;AND PLAY
	LD	HL,LOSE	;THE LOSE
	JP	CHKKYA	;MUSIC
;
; GOT THE RIGHT ANSWER
;
CHKKY9	LD	A,I	;DISPLAY HOW MANY
	CALL	DISBYT	;AND PLAY THE WIN
	LD	L,(IX+11)
	LD	H,(IX+12)
	LD	HL,WIN	;MUSIC
;
; PLAY MUSIC AND WAIT FOR ANY KEY TO RESTART
;
CHKKYA	CALL	MUSIC	;PLAY THE MUSIC
	CALL	SKEYIN	;WAIT FOR A KEY
	CALL	BEEP
	CALL	SKEYRL	;WAIT FOR KEY RELEASE
	POP	HL	;AND RESTART THE GAME
	JP	SECRET
;
; WIN AND LOSE MUSIC
;
WIN	.DB	14H,12H,14H,17H,17H,12H,14H,10H,1FH
LOSE	.DB	01H,11H,01H,11H,01H,11H,1FH
;-------------------------------
; SEPARATE BYTE INTO TWO NYBBLES
;-------------------------------
;SEPARATES A BYTE INTO TWO
;RIGHT JUSTIFIED NYBBLES
; ENTRY : A = BYTE TO BE SEPARATED
; EXIT  : H = MSN
;         L = LSN
;
SPLIT	PUSH	AF
	PUSH	BC
	LD	B,A	;SAVE BYTE
	AND	0FH	;STRIP BITS LSN
	LD	L,A	;RETURN LSN IN L
	LD	A,B
	SRL	A
	SRL	A
	SRL	A	;MOVE MSN
	SRL	A	;INTO LSN
	LD	H,A	;RETURN MSN IN H
	POP	BC
	POP	AF
	RET
;-----------------------------------
; FUNCTION D - RELAY BOARD SEQUENCER
;-----------------------------------
RELSQR	CALL	BEEP
	CALL	KEYREL
	LD	HL,RLTEST	;POINT TO TEST SEQUENCE
	CALL	RLSTEP
	JP	CANCL1
;--------------
; TEST SEQUENCE
;--------------
;RLTEST	.DB	55H,01H,AAH,01H,00H,0FFH
RLTEST	.DB	0x55,0x01,0xAA,0x01,0x00,0xFF
;----------------
; RELAY SEQUENCER
;----------------
; SEQUENCES RELAYS ON RELAY BOARD
; USES TWO BYTES TO SPECIFY OUTPUT DATA AND DELAY TIME
; DELAY TIME BYTE ALSO DETERMINES IF SEQUENCE IS TO STOP
; OR REPEAT.
;  TABLE:
;  <BYTE1>,<BYTE2>
;  BYTE1 = DATA TO GO TO OUTPUT LATCH (USES PORT IO1)
;  BYTE2 = FF - REPEAT
;          00 - FINISHED
;  ENTRY : HL POINTS TO TABLE OF OUTPUT DATA
;  EXIT : NONE MODIFIED
;
RLSTEP	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL	;SAVE REGISTERS
	PUSH	HL
	EX	DE,HL	;GET ADDRESS OF DATA
RELSR1	LD	A,(DE)
	LD	C,A	;GET OUTPUT DATA
	INC	DE
	LD	A,(DE)	;GET TIME DELAY
	CP	0
	JR	Z,RELSR4	;END OF SEQUENCE
	CP	255
	JR	Z,RELSR3	;REPEAT SEQUENCE
	LD	B,A
	LD	A,C
	OUT	(IO1),A
	INC	DE
RELSR2	CALL	DELONE	;1 SEC DELAY
	DJNZ	RELSR2	;MORE SECONDS TO GO
	JP	RELSR1
;
; REPEAT
;
RELSR3	POP	DE	;GET START ADDRESS
	PUSH	DE	;SAVE FOR LATER
	JP	RELSR1
;
; FINISHED
;
RELSR4	LD	A,00H
	OUT	(IO1),A	;CLEAR OUTPUT REG
	POP	HL
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
;
; ENTRY : NONE
; EXIT : FLAG REGISTER MODIFIED
;
DELONE	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	HL,0870H
DELON1	LD	B,92H
DELON2	DJNZ	DELON2	;INNER LOOP
	SBC	HL,DE
	JP	NC,DELON1	;OUTER LOOP
	POP	HL
	POP	DE
	POP	BC
	RET
;--------------------------
; FUNCTION E - KALEIDOSCOPE
;--------------------------
SCOPE	CALL	BEEP
	CALL	KEYREL
	CALL	RAND	;GENERATE RANDOM
	EX	DE,HL
	LD	HL,SYSTEM	;NUMBER AND SET UP
	LD	A,E	;THE FIRST QUADRANT
	CALL	SEED	;WITH A RANDOM BIT
	LD	A,D	;PATTERN
	CALL	SEED
;
; GENERATE MIRROR IMAGES
;
SCOPE2	LD	B,04H
	LD	HL,SYSTEM
	LD	DE,SYSTEM+7
SCOPE3	LD	A,(HL)	;MIRROR THE FIRST
	LD	(DE),A	;QUADRANT INTO
	INC	HL	;THE FOURTH
	DEC	DE	;QUADRANT
	DJNZ	SCOPE3
;
; MIRROR ACROSS CENTRE OF DISPLAY
;
	LD	B,8	;MIRROR THE FIRST
	LD	HL,SYSTEM	;AND FOURTH QUADRANT
	LD	A,(HL)	;ACROSS THE CENTRE
	AND	0FH	;OF THE DISPLAY
	LD	(HL),A	;INTO THE SECOND
SCOPE4	BIT	0,(HL)	;AND THIRD QUADRANTS.
	JP	Z,SCOPE5	;CHECKING IF THE
	SET	7,(HL)	;BITS IN THE LSN ARE
SCOPE5	BIT	1,(HL)	;SET, AND SETTING THE
	JP	Z,SCOPE6	;CORRESPONDING
	SET	6,(HL)	;MIRROR IMAGE
SCOPE6	BIT	2,(HL)	;BIT IN THE MSN
	JP	Z,SCOPE7	;IF THEY ARE.
	SET	5,(HL)	;DO THIS FOR
SCOPE7	BIT	3,(HL)	;THE EIGHT ROWS
	JP	Z,SCOPE8	;OF DATA BYTES
	SET	4,(HL)	;IN THE DISPLAY
SCOPE8	INC	HL
	DJNZ	SCOPE4	;MORE ROWS TO DO
;
; DISPLAY RANDOM BIT PATTERN
;
	LD	DE,0001H	;SCAN THE DISPLAY
	CALL	RAND	;A RANDOM
	LD	A,H	;TIME
	AND	7	;NOT GREATER THAN
	OR	1	;NOT LESS THAN
	LD	H,A
SCOPE9	PUSH	HL
	LD	HL,SYSTEM
	CALL	SKATE	;SCAN 8X8
	POP	HL
	SBC	HL,DE
	JP	NZ,SCOPE9
;
; MANIPULATE BITS FOR NEXT IMAGE
;
SCOPEA	LD	HL,SYSTEM
	LD	A,5
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 5 TO FIRST LSN
	INC	HL
	LD	A,03H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 3 TO SECOND LSN
	INC	HL
	LD	A,01H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 1 TO THIRD LSN
	INC	HL
	LD	A,07H
	ADD	A,(HL)
	AND	0FH
	LD	(HL),A	;ADD 15 TO FOURTH LSN
	JP	SCOPE2	;MIRROR BIT PATTERN
;
; SEED THE FIRST QUADRANT WITH RANDOM BITS
;
SEED	LD	B,A	;PUT THE
	AND	0FH	;RANDOM NUMBER
	LD	(HL),A	;INTO THE
	INC	HL	;FIRST QUADRANT
	LD	A,B	;OF THE
	AND	240	;DISPLAY
	RRA
	RRA
	RRA
	RRA
	LD	(HL),A
	INC	HL
	RET
;-----------------
; SCAN 8X8 DISPLAY
;-----------------
;PUT THE 8 RAM LOCATIONS POINTED TO
;BY HL ON THE 8X8 DISPLAY,LOW BYTE
;ON TOP ROW.
;  ROUTINE PERIOD IS 500uS
;  PULSE WIDTH 15uS  GIVES 3% DUTY
;
; ENTRY : HL = ADDRESS OF 8X8 BUFFER
;	EXIT : NO REGISTERS MODIFIED
;
SKATE	PUSH	AF
	PUSH	BC
	PUSH	HL	;SAVE REGISTERS
	LD	C,80H
SKATE1	LD	A,(HL)
	OUT	(IO0),A	;OUTPUT X
	LD	A,C
	OUT	(IO2),A	;OUTPUT Y
	LD	B,02H
SKATE2	DJNZ	SKATE2	;ON TIME DELAY
	XOR	A
	OUT	(IO0),A
	OUT	(IO2),A	;CLEAR DISPLAY LATCHES
	LD	B,08H
SKATE3	DJNZ	SKATE3	;OFF TIME DELAY
	INC	HL
	RRC	C
	JR	NC,SKATE1	;MORE TO OUTPUT
	POP	HL
	POP	BC
	POP	AF
	RET
;----------------------------
; FUNCTION F - CLOCK CALENDAR
;----------------------------
TIME	CALL	BEEP
	CALL	KEYREL	;WAIT FOR KEY RELEASE
	LD	IX,SYSTEM	;USE IX FOR TEMP VARIABLES
	LD	A,(ONTIM)
	LD	(IX+0),A	;SAVE DISPLAY SCAN DELAY
	LD	A,60H
	LD	(ONTIM),A	;USE NEW DELAY
	LD	(IX+1),A	;START IN TIME MODE
;
; DISPLAY TIME,CHECK FOR KEY
;
TIME1	CALL	RWATCH	;READ THE CLOCK/CALENDAR
	CALL	UPDBUF	;UPDATE THE DISPLAY BUFFER
	CALL	SCAND
	CALL	SCANKEY
	BIT	5,A
	JR	Z,TIME1	;NO KEY KEEP LOOKING
	AND	1FH
	LD	HL,TIMKEY
	CALL	MENU
	JR	TIME1

TIMKEY	.DB	4
	.DB	10H,11H,12H,13H
	.DW	CLKEXT,SETCLK,CALKEY,CALKEY
;--------------------
; EXIT CLOCK CALENDAR
;--------------------
CLKEXT	POP	HL	;REMOVE RETURN
	LD	A,(IX+0)
	LD	(ONTIM),A	;RESTORE DELAY TIME
	JP	CANCEL
;--------------------
; TOGGLE DISPLAY MODE
;--------------------
CALKEY	CALL	BEEP
	CALL	KEYREL
	LD	A,(IX+1)
	XOR	80H	;TOGGLE DISPLAY
	LD	(IX+1),A
	RET
;----------------------
; UPDATE DISPLAY BUFFER
;----------------------
UPDBUF	BIT	7,(IX+1)	;WHICH DISPLAY MODE?
	JR	NZ,UPDBF2	;CALENDAR DISPLAY
;
; TIME DISPLAY
;
UPDBF1	LD	A,(SWREG1)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF),HL	;SHOW SECONDS (0-59)
	LD	A,(SWREG2)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF+2),HL	;SHOW MINUTES (0-59)
	LD	A,(SWREG3)
	CALL	CONBYT
	SET	7,L	;SET DECIMAL POINT
	LD	(DISBUF+4),HL	;SHOW HOURS (0-23)
	RET
;
; CALENDAR DISPLAY
;
UPDBF2	LD	A,(SWREG7)
	CALL	CONBYT
	LD	(DISBUF),HL	;SHOW YEAR (0-99)
;
; CHECK MODE FOR DD/MM/YY OR MM/DD/YY
;
	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,UPDBF3	;MM/DD/YY MODE
;
; DD/MM/YY MODE
;
	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW DATE (1-31)
	JR	UPDBF4
;
; MM/DD/YY MODE
;
UPDBF3	LD	A,(SWREG6)
	CALL	CONBYT
	LD	(DISBUF+4),HL	;SHOW MONTH (1-12)
	LD	A,(SWREG5)
	CALL	CONBYT
	LD	(DISBUF+2),HL	;SHOW DATE (1-31)
;
; SHOW DAY
;
UPDBF4	LD	A,(SWREG4)	;GET DAY REG
	AND	07H
	JR	Z,UPDBF5	;ZERO IS ILLEGAL
	CP	07H
	JR	Z,UPDBF5	;DON'T SHOW SATURDAY
	CPL	;WORK OUT
	SUB	01H	;WHICH DECIMAL POINT
	AND	07H	;TO LIGHT
	LD	HL,DISBUF	;ADDING THE DAY
	LD	B,00H	;TO A DISPLAY
	LD	C,A	;BUFFER INDEX
	ADD	HL,BC	;AND SETTING THE
	SET	7,(HL)	;DECIMAL POINT
UPDBF5	RET	;IN THAT DISPLAY
;--------------
; SET TIME/DATE
;--------------
SETCLK	CALL	BEEP
	CALL	KEYREL
;
; EDIT THE DISPLAY BUFFER
;
SETCK1	CALL	UPDBUF  ;UPDATE DISPLAY BUFFER
	CALL	SKEYIN
	CALL	KEYREL
	CP	10H	;FN KEY EXITS (NO CHANGE)
	RET	Z
	CP	11H	;AD KEY SETS CLOCK/CALENDAR
	JR	Z,SETCK8
	CP	12H
	JR	Z,SETCK4	;PLUS KEY
	CP	13H
	JR	Z,SETCK6	;MINUS KEY
	CP	0AH	;NO A-F KEYS
	JR	NC,SETCK1
;
; IS IT SET CLOCK OR SET CALENDAR?
;
	BIT	7,(IX+1)
	JR	NZ,SETCK2
;
; SET CLOCK DISPLAY
;
	LD	HL,SWREG1
	RLD	;MOVE THE NEW KEY
	INC	HL	;INTO THE CLOCK BUFFER
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR DISPLAY
;
SETCK2	LD	HL,CALMDE
	BIT	7,(HL)
	JR	NZ,SETCK3	;MM/DD/YY MODE
;
; SET CALENDAR AS DD/MM/YY
;
	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	RLD
	DEC	HL
	RLD
	JR	SETCK1
;
; SET CALENDAR AS MM/DD/YY
;
SETCK3	LD	HL,SWREG7
	RLD	;MOVE THE NEW KEY
	DEC	HL	;INTO THE CAL BUFFER
	DEC	HL
	RLD
	INC	HL
	RLD
	JR	SETCK1
;
; INC DAY
;
SETCK4	BIT	7,(IX+1)
	JR	Z,SETCK1
	LD	A,(SWREG4)
	CP	07H	;IS THE DAY SUNDAY?
	JR	NZ,SETCK5
	LD	A,00H	;SET MONDAY
SETCK5	INC	A	;DAY=DAY+1
	LD	(SWREG4),A
	JP	SETCK1
;
; DEC DAY
;
SETCK6	BIT	7,(IX+1)
	JP	Z,SETCK1
	LD	A,(SWREG4)
	CP	01H	;IS THE DAY MONDAY?
	JR	NZ,SETCK7
	LD	A,08H	;SET SUNDAY
SETCK7	DEC	A	;DAY=DAY-1
	LD	(SWREG4),A
	JP	SETCK1
;
; SET THE CLOCK/CALENDAR WITH NEW DATA
;
SETCK8	CALL	BEEP
	CALL	KEYREL
	LD	A,(SWREG3)
	AND	3FH	;24 HOUR MODE
	LD	(SWREG3),A
	LD	A,(SWREG4)
	AND	07H	;OSC ON,RST ENABLED
	LD	(SWREG4),A
	CALL	WWATCH	;WRITE CHANGES
	RET
;---------------------
; READ FROM SMARTWATCH
;---------------------
; READS DATA FROM SMARTWATCH, USES LOOKUP TABLE TO
; WRITE 64 BIT ACCESS CODE TO ENABLE THE SMARTWATCH.
; READS ALL DATA INTO REGISTERS AS RAM CANNOT BE READ
; OR WRITTEN TO WHILE WATCH IS ENABLED.
;
;  ENTRY : NONE
;  EXIT  : NO WORKING REGISTERS MODIFIED
;          (ALTERNATE SET MODIFIED)
;  CONTENTS OF SMARTWATCH WRITTEN TO SWREG0 - SWREG7
;
;
; ENABLE SMARTWATCH
;
RWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	HL,PATERN	;WRITE D0 OF ALL THE BYTES
	LD	B,64	;IN THE TABLE TO THE RAM TO
RWACH1	LD	A,(HL)	;ENABLE THE SMARTWATCH
	LD	(DALLAS),A
	INC	HL
	DJNZ	RWACH1
;
; READ DATA FROM WATCH
;
	LD	B,32
RWACH2	LD	A,(DALLAS)	;SHIFT THE FIRST 32 BITS
	SRL	A	;INTO THE 16 BIT REGISTERS
	RR	D	;DE AND HL
	RR	E	;THEN EXCHANGE THEM WITH
	RR	H	;THE ALTERNATE PAIR
	RR	L
	DJNZ	RWACH2
	EXX
	LD	B,32
RWACH3	LD	A,(DALLAS)	;NOW SHIFT THE LAST 32 BITS
	SRL	A	;INTO THE SAME 16 BIT REGISTERS
	RR	D
	RR	E
	RR	H
	RR	L
	DJNZ	RWACH3
;
; SAVE IN WATCH REGISTERS
;
	LD	(SWREG4),HL	;SMARTWATCH READ IS COMPLETE
	LD	(SWREG6),DE	;GET THE DATA
	EXX
	LD	(SWREG0),HL
	LD	(SWREG2),DE
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;
; SMARTWATCH ACCESS PATTERN
;
PATERN	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
	.DB	0C5H,0E2H,71H,0B8H,5CH,2EH,17H,8BH
	.DB	3AH,1DH,8EH,47H,0A3H,0D1H,0E8H,74H
	.DB	0A3H,0D1H,0E8H,74H,3AH,1DH,8EH,47H
	.DB	5CH,2EH,17H,8BH,0C5H,0E2H,71H,0B8H
;--------------------
; WRITE TO SMARTWATCH
;--------------------
;
; WRITE DATA TO SMARTWATCH BY FIRST ACCESSING
; IT USING BIT MANIPULATION.
; DATA IS WRITTEN BY FIRSTLY PUTTING ALL 64 BITS
; INTO REGISTERS AS RAM CANNOT BE ACCESSED ONCE THE
; SMARTWATCH IS ENABLED.
;
; ENTRY : NONE
; THE DATA TO WRITE TO THE SMARTWATCH
; MUST BE IN SWREG0 - SWREG7
;  EXIT : NO WORKING REGISTERS MODIFIED
;  (ALTERNATE SET MODIFIED)
; GET DATA TO WRITE TO WATCH
;
WWATCH	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(SWREG4)	;SET UP THE
	LD	DE,(SWREG6)	;16 BIT REGISTERS
	EXX
	LD	HL,(SWREG0)	;WITH THE DATA TO BE
	LD	DE,(SWREG2)	;WRITTEN TO THE SMARTWATCH
;
; WRITE 64 BIT ACCESS CODE TO ENABLE SMARTWATCH
;
	LD	A,(DALLAS)	;INITIATE PATTERN
	LD	A,0C5H
	LD	C,80H	;NUMBER OF BYTES
WWACH1	LD	B,80H	;NUMBER OF BITS
WWACH2	LD	(DALLAS),A	;WRITE TO RAM
	RRC	A
	SRL	B
	JR	NC,WWACH2	;MORE BITS
	SRL	C
	JR	C,WWACH4	;NO MORE BYTES
	BIT	0,A
	JR	NZ,WWACH3
	RRC	A
	RRC	A
	RRC	A
	RRC	A
	JR	WWACH1
WWACH3	CPL
	JR	WWACH1
;
; WRITE DATA TO WATCH
;
WWACH4	LD	B,32	;SHIFT THE FIRST 32 BITS
WWACH5	SRL	D	;OUT OF THE 16 BIT REGISTERS
	RR	E	;ONTO D0 AND INTO
	RR	H	;THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH5
	EXX	;RESTORE REGISTERS
	LD	B,32	;GET THE OTHER 32 BITS FROM
WWACH6	SRL	D	;THE ALTERNATE REGISTER SET
	RR	E	;AND SHIFT THEM ONTO D0
	RR	H	;AND INTO THE SMARTWATCH
	RR	L
	RLA
	LD	(DALLAS),A
	DJNZ	WWACH6
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;-----------------
; ONE SECOND DELAY
;-----------------
; USES SMARTWATCH TO DELAY FOR 1 SECOND
; BY WAITING FOR SECONDS REGISTER TO ROLLOVER
;
; FIRST READ GETS A REFERENCE, SUBSEQUENT READS
; WAIT UNTIL THE SECONDS COUNTER NO LONGER
; READS THE SAME AS THE REFERENCE VALUE,
; THEN THE ROUTINE RETURNS
;
; ENTRY : NONE
; EXIT : NONE MODIFIED
;
ONESEC	PUSH	AF
	PUSH	BC
	CALL	RWATCH	;READ WATCH
	LD	A,(SWREG1)
	LD	B,A	;SAVE REF COUNT
ONESC1	CALL	RWATCH
	LD	A,(SWREG1)
	CP	B	;SAME AS REF?
	JP	Z,ONESC1	;YES SO WAIT AGAIN
	POP	BC
	POP	AF
	RET
	END
